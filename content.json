{"pages":[],"posts":[{"title":"","text":"第一次 初体验 第二次 快速幂 第三次 贪心hdoj 1009 fatmouse trade 1050 移动桌子 1789 doing homework again 第四次 递推与递归第五次 动态规划1087 超级跳跳跳 搬寝室 humble number 第七次 背包问题bone collector 123Before ACM can do anything, a budget must be prepared and the necessary financial support obtained. The main income for this action comes from Irreversibly Bound Money (IBM). The idea behind is simple. Whenever some ACM member has any small money, he takes all the coins and throws them into a piggy-bank. You know that this process is irreversible, the coins cannot be removed without breaking the pig. After a sufficiently long time, there should be enough cash in the piggy-bank to pay everything that needs to be paid.But there is a big problem with piggy-banks. It is not possible to determine how much money is inside. So we might break the pig into pieces only to find out that there is not enough money. Clearly, we want to avoid this unpleasant situation. The only possibility is to weigh the piggy-bank and try to guess how many coins are inside. Assume that we are able to determine the weight of the pig exactly and that we know the weights of all coins of a given currency. Then there is some minimum amount of money in the piggy-bank that we can guarantee. Your task is to find out this worst case and determine the minimum amount of cash inside the piggy-bank. We need your help. No more prematurely broken pigs! piggy bank 12Nowadays, we all know that Computer College is the biggest department in HDU. But, maybe you don't know that Computer College had ever been split into Computer College and Software College in 2002.The splitting is absolutely a big event in HDU! At the same time, it is a trouble thing too. All facilities must go halves. First, all facilities are assessed, and two facilities are thought to be same if they have the same value. It is assumed that there is N (0&lt;N&lt;1000) kinds of facilities (different value, different kinds). 冰封王座 秋秋吃货日志 1Speakless很早就想出国，现在他已经考完了所有需要的考试，准备了所有要准备的材料，于是，便需要去申请学校了。要申请国外的任何大学，你都要交纳一定的申请费用，这可是很惊人的。Speakless没有多少钱，总共只攒了n万美元。他将在m个学校中选择若干的（当然要在他的经济承受范围内）。每个学校都有不同的申请费用a（万美元），并且Speakless估计了他得到这个学校offer的可能性b。不同学校之间是否得到offer不会互相影响。“I NEED A OFFER”，他大叫一声。帮帮这个可怜的人吧，帮助他计算一下，他可以收到至少一份offer的最大概率。（如果Speakless选择了多个学校，得到任意一个学校的offer都可以） fate 1最近xhd正在玩一款叫做FATE的游戏，为了得到极品装备，xhd在不停的杀怪做任务。久而久之xhd开始对杀怪产生的厌恶感，但又不得不通过杀怪来升完这最后一级。现在的问题是，xhd升掉最后一级还需n的经验值，xhd还留有m的忍耐度，每杀一个怪xhd会得到相应的经验，并减掉相应的忍耐度。当忍耐度降到0或者0以下时，xhd就不会玩这游戏。xhd还说了他最多只杀s只怪。请问他能升掉这最后一级吗？ 第八次 宽搜strange lift 12There is a strange lift.The lift can stop can at every floor as you want, and there is a number Ki(0 &lt;= Ki &lt;= N) on every floor.The lift have just two buttons: up and down.When you at floor i,if you press the button \"UP\" , you will go up Ki floor,i.e,you will go to the i+Ki th floor,as the same, if you press the button \"DOWN\" , you will go down Ki floor,i.e,you will go to the i-Ki th floor. Of course, the lift can't go up high than N,and can't go down lower than 1. For example, there is a buliding with 5 floors, and k1 = 3, k2 = 3,k3 = 1,k4 = 2, k5 = 5.Begining from the 1 st floor,you can press the button \"UP\", and you'll go up to the 4 th floor,and if you press the button \"DOWN\", the lift can't do it, because it can't go down to the -2 th floor,as you know ,the -2 th floor isn't exist.Here comes the problem: when you are on floor A,and you want to go to floor B,how many times at least he has to press the button \"UP\" or \"DOWN\"? 非常可乐 1大家一定觉的运动以后喝可乐是一件很惬意的事情，但是seeyou却不这么认为。因为每次当seeyou买了可乐以后，阿牛就要求和seeyou一起分享这一瓶可乐，而且一定要喝的和seeyou一样多。但seeyou的手中只有两个杯子，它们的容量分别是N 毫升和M 毫升 可乐的体积为S （S&lt;101）毫升 (正好装满一瓶) ，它们三个之间可以相互倒可乐 (都是没有刻度的，且 S==N+M，101＞S＞0，N＞0，M＞0) 。聪明的ACMER你们说他们能平分吗？如果能请输出倒可乐的最少的次数，如果不能输出\"NO\"。 1234A friend of you is doing research on the Traveling Knight Problem (TKP) where you are to find the shortest closed tour of knight moves that visits each square of a given set of n squares on a chessboard exactly once. He thinks that the most difficult part of the problem is determining the smallest number of knight moves between two given squares and that, once you have accomplished this, finding the tour would be easy.Of course you know that it is vice versa. So you offer him to write a program that solves the \"difficult\" part.Your job is to write a program that takes two squares a and b as input and then determines the number of knight moves on a shortest route from a to b. 123Ignatius被魔王抓走了,有一天魔王出差去了,这可是Ignatius逃亡的好机会.魔王住在一个城堡里,城堡是一个A*B*C的立方体,可以被表示成A个B*C的矩阵,刚开始Ignatius被关在(0,0,0)的位置,离开城堡的门在(A-1,B-1,C-1)的位置,现在知道魔王将在T分钟后回到城堡,Ignatius每分钟能从一个坐标走到相邻的六个坐标中的其中一个.现在给你城堡的地图,请你计算出Ignatius能否在魔王回来前离开城堡(只要走到出口就算离开城堡,如果走到出口的时候魔王刚好回来也算逃亡成功),如果可以请输出需要多少分钟才能离开,如果不能则输出-1. 12345Angel was caught by the MOLIGPY! He was put in prison by Moligpy. The prison is described as a N * M (N, M &lt;= 200) matrix. There are WALLs, ROADs, and GUARDs in the prison.Angel's friends want to save Angel. Their task is: approach Angel. We assume that \"approach Angel\" is to get to the position where Angel stays. When there's a guard in the grid, we must kill him (or her?) to move into the grid. We assume that we moving up, down, right, left takes us 1 unit time, and killing a guard takes 1 unit time, too. And we are strong enough to kill all the guards.You have to calculate the minimal time to approach Angel. (We can move only UP, DOWN, LEFT and RIGHT, to the neighbor grid within bound, of course.) 第九次 二分Now,given the equation 8x^4 + 7x^3 + 2x^2 + 3x + 6 == Y,can you find its solution between 0 and 100;Now please try your lucky. Now, here is a fuction: F(x) = 6 * x^7+8x^6+7x^3+5x^2-yx (0 &lt;= x &lt;=100)Can you find the minimum value when x is between 0 and 100. My birthday is coming up and traditionally I’m serving pie. Not just one pie, no, I have a number N of them, of various tastes and of various sizes. F of my friends are coming to my party and each of them gets a piece of pie. This should be one piece of one pie, not several small pieces since that looks messy. This piece can be one whole pie though. My friends are very annoying and if one of them gets a bigger piece than the others, they start complaining. Therefore all of them should get equally sized (but not necessarily equally shaped) pieces, even if this leads to some pie getting spoiled (which is better than spoiling the party). Of course, I want a piece of pie for myself too, and that piece should also be of the same size. What is the largest possible piece size all of us can get? All the pies are cylindrical in shape and they all have the same height 1, but the radii of the pies can be different. Fermat’s theorem states that for any prime number p and for any integer a &gt; 1, a^p == a (mod p). That is, if we raise a to the pth power and divide by p, the remainder is a. Some (but not very many) non-prime values of p, known as base-a pseudoprimes, have this property for some a. (And some, known as Carmichael Numbers, are base-a pseudoprimes for all a.)Given 2 &lt; p ≤ 1,000,000,000 and 1 &lt; a &lt; p, determine whether or not p is a base-a pseudoprime. Every girl likes shopping,so does dandelion.Now she finds the shop is increasing the price every day because the Spring Festival is coming .She is fond of a shop which is called “memory”. Now she wants to know the rank of this shop’s price after the change of everyday. Give you three sequences of numbers A, B, C, then we give you a number X. Now you need to calculate if you can find the three numbers Ai, Bj, Ck, which satisfy the formula Ai+Bj+Ck = X. The doggie found a bone in an ancient maze, which fascinated him a lot. However, when he picked it up, the maze began to shake, and the doggie could feel the ground sinking. He realized that the bone was a trap, and he tried desperately to get out of this maze. The maze was a rectangle with sizes N by M. There was a door in the maze. At the beginning, the door was closed and it would open at the T-th second for a short period of time (less than 1 second). Therefore the doggie had to arrive at the door on exactly the T-th second. In every second, he could move one block to one of the upper, lower, left and right neighboring blocks. Once he entered a block, the ground of this block would start to sink and disappear in the next second. He could not stay at one block for more than one second, nor could he move into a visited block. Can the poor doggie survive? Please help him. 第十次 记忆化搜索 FatMouse has stored some cheese in a city. The city can be considered as a square grid of dimension n: each grid location is labelled (p,q) where 0 &lt;= p &lt; n and 0 &lt;= q &lt; n. At each grid location Fatmouse has hid between 0 and 100 blocks of cheese in a hole. Now he’s going to enjoy his favorite food. FatMouse begins by standing at location (0,0). He eats up the cheese where he stands and then runs either horizontally or vertically to another location. The problem is that there is a super Cat named Top Killer sitting near his hole, so each time he can run at most k locations to get into the hole before being caught by Top Killer. What is worse – after eating up the cheese at one location, FatMouse gets fatter. So in order to gain enough energy for his next run, he has to run to a location which have more blocks of cheese than those that were at the current hole. Given n, k, and the number of blocks of cheese at each grid location, compute the maximum amount of cheese FatMouse can eat before being unable to move. 穿过幽谷意味着离大魔王lemon已经无限接近了！可谁能想到，yifenfei在斩杀了一些虾兵蟹将后，却再次面临命运大迷宫的考验，这是魔王lemon设下的又一个机关。要知道，不论何人，若在迷宫中被困1小时以上，则必死无疑！可怜的yifenfei为了去救MM，义无返顾地跳进了迷宫。让我们一起帮帮执着的他吧！命运大迷宫可以看成是一个两维的方格阵列，如下图所示：yifenfei一开始在左上角，目的当然是到达右下角的大魔王所在地。迷宫的每一个格子都受到幸运女神眷恋或者痛苦魔王的诅咒，所以每个格子都对应一个值，走到那里便自动得到了对应的值。现在规定yifenfei只能向右或者向下走，向下一次只能走一格。但是如果向右走，则每次可以走一格或者走到该行的列数是当前所在列数倍数的格子，即：如果当前格子是（x,y），下一步可以是（x+1,y），(x,y+1)或者(x,y*k) 其中k&gt;1。为了能够最大把握的消灭魔王lemon，yifenfei希望能够在这个命运大迷宫中得到最大的幸运值。 第十一次 并查集hdoj 1232 畅通工程 hdoj 1272 十二次 计算几何 第十三次 博弈论 第十四次 最短路径","link":"/2019/11/20/ACM实训记录/"},{"title":"卡特兰数","text":"hdoj 113412345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;using namespace std;int a[110][110];int b[110];void Catalan(){ int i, j, len, carry; a[1][0] = a[1][1] = 1; a[2][0] = 1, a[2][1] = 2; len = 1; for (i = 3; i &lt; 105; i++) { carry = 0; for (j = 1; j &lt;= len; j++) //做乘法 { int temp = a[i - 1][j] * (4 * i - 2) + carry; a[i][j] = temp % 10; carry = temp / 10; } while (carry) //进位处理,要注意几个点，进位的话可能是进位100，即进了两位 { // ++len之所以可以，是因为每次乘一个数，至少比前一个数位数多或者相同 a[i][++len] = carry % 10; // len一直保持着加 carry /= 10; } carry = 0; for (j = len; j &gt;= 1; j--) //做除法 { int temp = carry * 10 + a[i][j]; a[i][j] = temp / (i + 1); carry = temp % (i + 1); } while (!a[i][len]) //高位零处理 len--; a[i][0] = len; }}int main(){ int n; Catalan(); while (scanf(\"%d\", &amp;n) &amp;&amp; n != -1) { for (int i = a[n][0]; i &gt; 0; i--) printf(\"%d\", 2*a[n][i]); printf(\"\\n\"); } return 0;} hdoj 2067123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;using namespace std;int a[110][110];int b[110];void Catalan(){ int i, j, len, carry; a[1][0] = a[1][1] = 1; a[2][0] = 1, a[2][1] = 2; len = 1; for (i = 3; i &lt; 105; i++) { carry = 0; for (j = 1; j &lt;= len; j++) //做乘法 { int temp = a[i - 1][j] * (4 * i - 2) + carry; //不能在里面乘以2，因为记录的上一个数字会被改变 a[i][j] = temp % 10; carry = temp / 10; } while (carry) //进位处理,要注意几个点，进位的话可能是进位100，即进了两位 { // ++len之所以可以，是因为每次乘一个数，至少比前一个数位数多或者相同 a[i][++len] = carry % 10; // len一直保持着加 carry /= 10; } carry = 0; for (j = len; j &gt;= 1; j--) //做除法 { int temp = carry * 10 + a[i][j]; a[i][j] = temp / (i + 1); carry = temp % (i + 1); } while (!a[i][len]) //高位零处理 len--; a[i][0] = len; }}int main(){ int n; int count=0; Catalan(); while (scanf(\"%d\", &amp;n) &amp;&amp; n != -1) { count++; int carry=0; printf(\"%d %d \",count,n); int len=a[n][0]; for (int j = 1; j &lt;= len; j++) //做乘法 { int temp = a[n][j] * 2 + carry; //不能在里面乘以2，因为记录的上一个数字会被改变 a[n][j] = temp % 10; carry = temp / 10; } while (carry) //进位处理,要注意几个点，进位的话可能是进位100，即进了两位 { // ++len之所以可以，是因为每次乘一个数，至少比前一个数位数多或者相同 a[n][++len] = carry % 10; // len一直保持着加 carry /= 10; } while (!a[n][len]) //高位零处理 len--; a[n][0] = len; for (int i = a[n][0]; i &gt; 0; i--) printf(\"%d\",a[n][i]); printf(\"\\n\"); } return 0;}","link":"/2019/10/23/Catalan Number/"},{"title":"BFS","text":"预备知识队列特点 先进先出 理解为单向的管道 用数组来模拟队列 头指针往后移一个位置 虚拟的头尾指针 从队头删除元素 在队尾加入元素 常见操作 判断队列是否为空 查询队列大小 STL队列的基本用法push和pop，pull 宽度优先搜索二叉树的层次遍历想象一下族谱 维护队列 把孩子加到队列里面 最早扩展到的就是最短路径 hdoj 1548 strange lift主要是记录每一层的那个地方不会设计 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;bits/stdc++.h&gt;using namespace std;const int MAXN = 200;queue&lt;int&gt; q;int vis[MAXN];struct Floor{ int number; int step; //Floor(){} //Floor(int n,int s):{number=n,step=s}; //我想在这个地方把所有的step都赋值为0} floor[MAXN];int main(){ int N, A, B; while (~scanf(\"%d %d %d\", &amp;N, &amp;A, &amp;B)) { //int step = 0; if (N == 0) break; for (int i = 0; i &lt; N; i++) { cin &gt;&gt; floor[i].number; floor[i].step = i + 1; } q.push(1); vis[1] = 1; while (!q.empty()) { //int flag=0; //step++;//直接i+1 if (q.front() + floor[i].number &lt;= B &amp;&amp; vis[q.front() + floor[i].number] != 1) { q.push(q.front() + floor[i].number); vis[q.front() + floor[i].number] = 1; if (q.back() == B) break; //flag=1; } if (q.front() - floor[i].number &gt;= 1 &amp;&amp; vis[q.front() - floor[i].number] != 1) { q.push(q.front() - floor[i].number); vis[q.front() - floor[i].number] = 1; if (q.back() == B) break; //flag=1; } //if(flag==1) q.pop(); } //应该是直接循环 for (int i = 0; i &lt; n; i++) { } } return 0;} 我这样做有什么不好的呢？主要是有以下几个问题没有解决： 走的步数不太清楚，即走到当前位，我不知道我走到了哪一步 我们什么时候进入队列没有想清楚 什么时候才能进入队列呢？ 其实根本不要以为是深搜，我在做递归什么的。其实并没有，我们要做的只是查找到一个节点，我就把这个节点能搜索到的节点进入队列，因为他会进入到最后面，所以根本不用担心 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;math.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;vector&gt;using namespace std;const int MAX = 11000;struct Node //定义一个结构体关于{ int to, step;} node, nextnode;int v[MAX], f[MAX]; //v用来标记int main(){ int cas, m, n, i; while (scanf(\"%d\", &amp;cas) &amp;&amp; cas) //cas表示几楼的数据 { scanf(\"%d%d\", &amp;m, &amp;n); //m表示起点，n表示终点 memset(v, 0, sizeof(v)); //数组初始化 memset(f, 0, sizeof(f)); for (i = 1; i &lt;= cas; i++) scanf(\"%d\", &amp;f[i]); //输入每层的数据 queue&lt;Node&gt; qu; //定义队列 while (!qu.empty()) //清空队列 { qu.pop(); } int t1, t2, flag = 0; node.step = 0; //起始点的步数 node.to = m; qu.push(node); //把结点的情况输入 v[node.to] = 1; //标记这个点已经走过了 while (!qu.empty()) { node = qu.front(); //取出首元素 qu.pop(); //下面是三种分类讨论：到达终点，向上走，向下走 if (node.to == n) //如果到达终点 { printf(\"%d\\n\", node.step); flag = 1; break; } t1 = node.to + f[node.to]; //向上走 if (t1 &lt;= cas &amp;&amp; !v[t1]) //条件的控制 { v[t1] = 1; nextnode.to = t1; nextnode.step = node.step + 1; qu.push(nextnode); } t1 = node.to - f[node.to]; //向下走 if (t1 &gt;= 1 &amp;&amp; !v[t1]) { v[t1] = 1; nextnode.to = t1; nextnode.step = node.step + 1; qu.push(nextnode); } } if (!flag) //如果走不到 printf(\"-1\\n\"); } return 0;} 结构体可以理解为一个圈，里面包含了两个信息 hdoj 1495非常可乐有几个问题解决不了： 怎么判断现在是处于哪个杯子 怎么判断它用了这个杯子 二维就够了，因为加起来是固定的。这里指的是我们自己创建的三维判断矩阵 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;queue&gt;using namespace std;int v[5];int sign[110][110][100];struct cup //记录遍历中3个水杯容藏可乐情况{ int v[5]; int step;} temp;void pour(int a, int b) //倒水函数，把a杯子中的可乐倒到b杯子中{ int sum = temp.v[a] + temp.v[b]; if (sum &gt;= v[b]) temp.v[b] = v[b]; else temp.v[b] = sum; temp.v[a] = sum - temp.v[b];}void bfs(){ int i, j; queue&lt;cup&gt; q; cup cnt; cnt.v[1] = v[1]; cnt.v[2] = 0; cnt.v[3] = 0; cnt.step = 0; q.push(cnt); memset(sign, 0, sizeof(sign)); sign[v[1]][0][0] = 1; while (!q.empty()) { cnt = q.front(); q.pop(); if (cnt.v[1] == cnt.v[3] &amp;&amp; cnt.v[2] == 0) { printf(\"%d\\n\", cnt.step); return; } for (i = 1; i &lt; 4; ++i) { for (j = 1; j &lt; 4; ++j) { if (i != j) //自己不倒水给自己 { temp = cnt; //每个水位情况都要把所有操作枚举一遍，所以都要赋值为原始水位情况 pour(i, j); if (!sign[temp.v[1]][temp.v[2]][temp.v[3]]) { temp.step++; q.push(temp); sign[temp.v[1]][temp.v[2]][temp.v[3]] = 1; } } } } } printf(\"NO\\n\");}int main(){ while (scanf(\"%d%d%d\", &amp;v[1], &amp;v[2], &amp;v[3]) &amp;&amp; v[1] || v[2] || v[3]) { if (v[2] &gt; v[3]) { int t = v[2]; v[2] = v[3]; v[3] = t; } bfs(); } return 0;} 最先出现的目标是最少的次数 隐式图 hdoj 1372 Knight move(模板题)组成一个移动的数组，循环八次的数组 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;queue&gt;#define N 10using namespace std;int step[N][N][N][N], visit[N][N];int dir[][2] = { {1, 2}, {1, -2}, {-1, 2}, {-1, -2}, {2, 1}, {2, -1}, {-2, 1}, {-2, -1}};struct Node{ int x, y, s;};int bfs(int sx, int sy, int ex, int ey){ queue&lt;Node&gt; q; Node head = {sx, sy, 0}; q.push(head); memset(visit, -1, sizeof(visit)); visit[sx][sy] = 0; while (q.size()) { Node f = q.front(); q.pop(); if (f.x == ex &amp;&amp; f.y == ey) return f.s; for (int i = 0; i &lt; 8; i++) { int dx = dir[i][0] + f.x, dy = dir[i][1] + f.y; if (dx &gt;= 0 &amp;&amp; dx &lt; 8 &amp;&amp; dy &gt;= 0 &amp;&amp; dy &lt; 8 &amp;&amp; visit[dx][dy]) { visit[dx][dy] = 0; Node t = {dx, dy, f.s + 1}; q.push(t); } } }}int main(){ cin.sync_with_stdio(false); memset(step, -1, sizeof(step)); for (int i = 0; i &lt; 8; i++) for (int j = 0; j &lt; 8; j++) for (int k = 0; k &lt; 8; k++) for (int l = 0; l &lt; 8; l++) if (step[i][j][k][l] != -1) continue; else if (i == k &amp;&amp; j == l) step[i][j][k][l] = 0; else { int temp = bfs(i, j, k, l); step[i][j][k][l] = step[k][l][i][j] = temp; step[j][i][l][k] = step[l][k][j][i] = temp; } char c1, c2; int x1, y2; while (cin &gt;&gt; c1 &gt;&gt; x1 &gt;&gt; c2 &gt;&gt; y2) { printf(\"To get from %c%d to %c%d takes %d knight moves.\\n\", c1, x1, c2, y2, step[c1 - 'a'][x1 - 1][c2 - 'a'][y2 - 1]); } return 0;} 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;queue&gt;#include&lt;string&gt;#include&lt;cstring&gt;using namespace std;typedef pair&lt;int,int&gt; P;int next1[8][2]={{1,2},{2,1},{2,-1},{1,-2},{-1,-2},{-2,-1},{-2,1},{-1,2}};int num[10][10];int bfs(int sx,int sy,int ex,int ey){ queue&lt;P&gt;q; while(!q.empty()) q.pop(); q.push(P(sx,sy)); num[sx][sy]=1; while(!q.empty()) { P fx=q.front(); if(fx.first==ex&amp;&amp;fx.second==ey) return num[ex][ey]; for(int i=0;i&lt;8;i++) { int nx=fx.first+next1[i][0],ny=fx.second+next1[i][1]; if(nx&gt;=1&amp;&amp;nx&lt;=8&amp;&amp;ny&gt;=1&amp;&amp;ny&lt;=8&amp;&amp;!num[nx][ny]) { q.push(P(nx,ny)); num[nx][ny]=num[fx.first][fx.second]+1; } } q.pop(); }}int main(){ string ch1,ch2; int a,b,c,d; while(cin&gt;&gt;ch1&gt;&gt;ch2)//cin遇空格结束输入。。。。。。 { memset(num,0,sizeof(num)); b=ch1[0]-'a'+1;a=ch1[1]-'0';d=ch2[0]-'a'+1;c=ch2[1]-'0'; cout&lt;&lt;\"To get from \"&lt;&lt;ch1&lt;&lt;\" to \"&lt;&lt;ch2&lt;&lt;\" takes \"&lt;&lt;bfs(a,b,c,d)-1&lt;&lt;\" knight moves.\"&lt;&lt;endl; } return 0;}//用pair来做 hdoj 1312 red and black12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;using namespace std;const int maxn = 25;int w, h;//int ans;char maze[maxn][maxn];int start_x, start_y;int dir[4][2] = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};struct Node{ int x, y; int step;};bool check(int x,int y){ if(x&gt;=0 &amp;&amp; x&lt;w &amp;&amp; y&gt;=0 &amp;&amp; y&lt;h) return true; return false;}int bfs(){ queue&lt;Node&gt; q; while (!q.empty()) q.pop(); Node now = {start_x,start_y,1}; int ans =1; q.push(now); while (!q.empty()) { Node next = q.front(); q.pop(); for (int i = 0; i &lt; 4; i++) { int dx = next.x + dir[i][0]; int dy = next.y + dir[i][1]; if(maze[dx][dy]=='.' &amp;&amp; check(dx,dy)) { maze[dx][dy] = '#'; Node f ={dx,dy,next.step+1}; ans++; q.push(f); } } } return ans;}int main(){ while (~scanf(\"%d %d\", &amp;w, &amp;h) &amp;&amp; w+h) { start_x = 0; start_y = 0; for (int i = 0; i &lt; h; i++) { for (int j = 0; j &lt; w; j++) { cin &gt;&gt; maze[j][i]; if (maze[j][i] == '@') { start_x = j; start_y = i; } } } cout&lt;&lt;bfs()&lt;&lt;endl; }} 把bfs写成函数 可以不用写vis数组，如果是迷宫的话可以通过字符的形态来决定有没有走过 如果数据不一样可能是x，y反了，试着改一改 hdoj 1253胜利大逃亡123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int MAXN = 51;int status[MAXN][MAXN][MAXN];int vis[MAXN][MAXN][MAXN];int dir[6][3] = {{1, 0, 0}, {0, 1, 0}, {0, -1, 0}, {-1, 0, 0}, {0, 0, 1}, {0, 0, -1}};struct Ignatius{ int x; int y; int z; int step;};int main(){ int A, B, C, T; int K; cin &gt;&gt; K; while (K--) { queue&lt;Ignatius&gt; q; //队列清空 cin &gt;&gt; A &gt;&gt; B &gt;&gt; C &gt;&gt; T; Ignatius head = {0, 0, 0, 0}; //memset(status, 0, sizeof(status)); 会在后面输入 memset(vis, 0, sizeof(vis)); q.push(head); vis[0][0][0] = 1; for (int i = 0; i &lt; A; i++) { for (int j = 0; j &lt; B; j++) for (int k = 0; k &lt; C; k++) { scanf(\"%d\", &amp;status[i][j][k]); } } //int flag = -1; int ans = -1; while (!q.empty()) { Ignatius t = q.front(); q.pop(); if (t.x == A - 1 &amp;&amp; t.y == B - 1 &amp;&amp; t.z == C - 1) { if (t.step &lt;= T) { ans = t.step; break; } } for (int i = 0; i &lt; 6; i++) { int dx = t.x + dir[i][0]; int dy = t.y + dir[i][1]; int dz = t.z + dir[i][2]; if (dx &lt; A &amp;&amp; dy &lt; B &amp;&amp; dz &lt; C &amp;&amp; !vis[dx][dy][dz] &amp;&amp; status[dx][dy][dz] != 1 &amp;&amp; dx &gt;= 0 &amp;&amp; dy &gt;= 0 &amp;&amp; dz &gt;= 0) { vis[dx][dy][dz] = 1; Ignatius f = {dx, dy, dz, t.step + 1}; // 直接在里面加步数 q.push(f); } } //怎么判断是找不到路还是时间不够 } cout &lt;&lt; ans &lt;&lt; endl; //省去了flag的 自己引用t.step的话没有定义 } return 0;} 2717 catch that cow123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;using namespace std;const int maxn = 100010;int vis[maxn];int main(){ int n, k; while (~scanf(\"%d %d\", &amp;n, &amp;k)) { memset(vis, 0, sizeof(vis)); queue&lt;int&gt; q; while (!q.empty()) q.pop(); q.push(n); vis[n] = 0; while (!q.empty()) { int temp = q.front(); if (temp == k) break; if (temp + 1 &lt;= 100000 &amp;&amp; !vis[temp + 1] &amp;&amp; temp + 1 &gt;= 0) { q.push(temp + 1); vis[temp + 1] = vis[temp] + 1; //ans++; 步数在里面加，因为如果是在外面的话算的是提取队列的次数 } if (temp - 1 &gt;= 0 &amp;&amp; !vis[temp - 1] &amp;&amp; temp - 1 &lt;= 100000) { q.push(temp - 1); vis[temp - 1] = vis[temp] + 1; } if (temp * 2 &lt;= 100000 &amp;&amp; !vis[temp * 2] &amp;&amp; temp * 2 &gt;= 0) { q.push(temp * 2); vis[temp * 2] = vis[temp] + 1; } q.pop(); } cout &lt;&lt; vis[k] &lt;&lt; endl; } return 0;} 每次都要清空队列，也就是while不空，就一直pop 有些东西可以整合到一起，比如说进队列的过程，可以一起放到循环里面来 判断是否满足条件要注意在哪个地方判断，是否会多走一次 要包含步数的话，可以写在结构体里面或者用vis数组 hdoj prime path123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;using namespace std;char a[5];char b[5];bool vis[12][12][12][12];bool Is_prime[10005];int ans;struct Num{ int num[4]; // 一开始想构造一个函数的 int step;};void bfs(){ memset(vis,0,sizeof(vis)); queue&lt;Num&gt; q; while (!q.empty()) q.pop(); Num start, des; ans = 0; for (int i = 0; i &lt; 4; i++) { start.num[i] = a[i] - '0'; des.num[i] = b[i] - '0'; } start.step = 0; vis[start.num[0]][start.num[1]][start.num[2]][start.num[3]] = 1; q.push(start); while (!q.empty()) { Num now = q.front(); q.pop(); if (now.num[0] == des.num[0] &amp;&amp; now.num[1] == des.num[1] &amp;&amp; now.num[2] == des.num[2] &amp;&amp; now.num[3] == des.num[3]) { ans = now.step; return; } for (int i = 0; i &lt; 4; i++) { if (i == 0) { for (int j = 1; j &lt;= 9; j++) { int temp = j * 1000 + now.num[1] * 100 + now.num[2] * 10 + now.num[3]; if (!vis[j][now.num[1]][now.num[2]][now.num[3]] &amp;&amp; !Is_prime[temp]) { Num f; //= {j,now.num[1],now.num[1],now.num[1]} f.num[0] = j; f.num[1] = now.num[1]; f.num[2] = now.num[2]; f.num[3] = now.num[3]; f.step = now.step + 1; vis[j][now.num[1]][now.num[2]][now.num[3]] = 1; q.push(f); } } } if (i == 1) { for (int j = 0; j &lt;= 9; j++) { int temp = now.num[0] * 1000 + j * 100 + now.num[2] * 10 + now.num[3]; if (!vis[now.num[0]][j][now.num[2]][now.num[3]] &amp;&amp; !Is_prime[temp]) { Num f; //= {j,now.num[1],now.num[1],now.num[1]} f.num[0] = now.num[0]; f.num[1] = j; f.num[2] = now.num[2]; f.num[3] = now.num[3]; f.step = now.step + 1; vis[now.num[0]][j][now.num[2]][now.num[3]] = 1; q.push(f); } } } if (i == 2) { for (int j = 0; j &lt;= 9; j++) { int temp = now.num[0] * 1000 + now.num[1] * 100 + j * 10 + now.num[3]; if (!vis[now.num[0]][now.num[1]][j][now.num[3]] &amp;&amp; !Is_prime[temp]) { Num f; //= {j,now.num[1],now.num[1],now.num[1]} f.num[0] = now.num[0]; f.num[1] = now.num[1]; f.num[2] = j; f.num[3] = now.num[3]; f.step = now.step + 1; vis[now.num[0]][now.num[1]][j][now.num[3]] = 1; q.push(f); } } } if (i == 3) { for (int j = 0; j &lt;= 9; j++) { int temp = now.num[0] * 1000 + now.num[1] * 100 + now.num[2] * 10 + j; if (!vis[now.num[0]][now.num[1]][now.num[2]][j] &amp;&amp; !Is_prime[temp]) { Num f; //= {j,now.num[1],now.num[1],now.num[1]} f.num[0] = now.num[0]; f.num[1] = now.num[1]; f.num[2] = now.num[2]; f.num[3] = j; f.step = now.step + 1; vis[now.num[0]][now.num[1]][now.num[2]][j] = 1; q.push(f); } } } } }}int main(){ int t; for (int i = 2; i * i &lt;= 10000; i++) // true为非素数 { if (!Is_prime[i]) for (int j = i * i; j &lt;= 10000; j += i) { Is_prime[j] = true; } } cin &gt;&gt; t; while (t--) { scanf(\"%s %s\", a, b); bfs(); cout&lt;&lt;ans&lt;&lt;endl; }} BFS总结生成的状态放到数组里面 优先队列priority queuehdoj 1242 rescue优先队列方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include &lt;stdio.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string.h&gt;#include &lt;queue&gt;#define MAXN 10000using namespace std;char map[1100][1100];int vis[1100][1100];int n, m;int mi;int sx, sy, ex, ey;int dx[5] = {1, -1, 0, 0};int dy[5] = {0, 0, 1, -1};struct st{ int x; int y; int time; bool friend operator&lt;(st a, st b) { return a.time &gt; b.time; }};bool judge(st a){ if (a.x &lt; 0 || a.x &gt;= n || a.y &lt; 0 || a.y &gt;= m || map[a.x][a.y] == '#' || vis[a.x][a.y]) return false; return true;}int bfs(int x, int y){ priority_queue&lt;st&gt; q; while (!q.empty()) q.pop(); st a; a.x = x; a.y = y; a.time = 0; vis[x][y] = 1; q.push(a); while (!q.empty()) { st b = q.top(); q.pop(); if (map[b.x][b.y] == 'a') return b.time; for (int i = 0; i &lt; 4; i++) { st end; end.x = b.x + dx[i]; end.y = b.y + dy[i]; end.time = b.time; if (judge(end)) { if (map[end.x][end.y] == 'x') end.time++; end.time++; q.push(end); vis[end.x][end.y] = 1; } } } return 0;}int main(){ while (~scanf(\"%d%d\", &amp;n, &amp;m)) { memset(map, 0, sizeof(map)); for (int i = 0; i &lt; n; i++) { scanf(\"%s\", map[i]); } for (int i = 0; i &lt; n; i++) for (int j = 0; j &lt; m; j++) { if (map[i][j] == 'r') { memset(vis, 0, sizeof(vis)); int ans = bfs(i, j); if (ans &lt; mi) mi = ans; } } memset(vis, 0, sizeof(vis)); if (mi == 0) printf(\"Poor ANGEL has to stay in the prison all his life.\\n\"); else printf(\"%d\\n\", mi); } return 0;} 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include &lt;stdio.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string.h&gt;#include &lt;queue&gt;#define MAXN 10000using namespace std;char map[1100][1100];int vis[1100][1100];int n, m;int sx, sy, ex, ey;int dx[5] = {1, -1, 0, 0};int dy[5] = {0, 0, 1, -1};struct st{ int x; int y; int time; bool friend operator&lt;(st a, st b) { return a.time &gt; b.time; }};bool judge(st a){ if (a.x &lt; 0 || a.x &gt;= n || a.y &lt; 0 || a.y &gt;= m || map[a.x][a.y] == '#' || vis[a.x][a.y]) return false; return true;}int bfs(int x, int y){ priority_queue&lt;st&gt; q; while (!q.empty()) q.pop(); st a; a.x = x; a.y = y; a.time = 0; vis[x][y] = 1; q.push(a); while (!q.empty()) { st b = q.top(); q.pop(); if (map[b.x][b.y] == 'a') return b.time; for (int i = 0; i &lt; 4; i++) { st end; end.x = b.x + dx[i]; end.y = b.y + dy[i]; end.time = b.time; if (judge(end)) { if (map[end.x][end.y] == 'x') end.time++; end.time++; q.push(end); vis[end.x][end.y] = 1; } } } return 9999999;}int main(){ while (~scanf(\"%d%d\", &amp;n, &amp;m)) { int mi=9999999; memset(map, 0, sizeof(map)); for (int i = 0; i &lt; n; i++) { scanf(\"%s\", map[i]); } for (int i = 0; i &lt; n; i++) for (int j = 0; j &lt; m; j++) { if (map[i][j] == 'r') { memset(vis, 0, sizeof(vis)); int ans = bfs(i, j); if (ans &lt; mi) mi = ans; } } memset(vis, 0, sizeof(vis)); if (mi == 9999999) printf(\"Poor ANGEL has to stay in the prison all his life.\\n\"); else printf(\"%d\\n\", mi); } return 0;} 老刘说了一句话，你们在掉了几百块钱很伤心，但是很多人不来我的课。其实我讲课几百块钱一小时。你想交钱我还不一定教 定义好一类规则就行了，长得最帅的出去，全部都出去了 优先队列其实是一个大顶堆，什么是堆呢？堆就是一个拟满二叉树，最后一层的上面全是满的。最后一层全部靠左 前缀编码里面没有前缀 我去找老师—学生找到我 在一个命名空间可以少打两次 greater表示小顶堆 硬着头皮写，问同学 不理解不要写上去，为每一句话负责 收获信息港 剪枝优化，动态规划和搜索都是最优的子问题 https://www.cnblogs.com/ECJTUACM-873284962/p/6750320.html hdoj 1053 https://blog.csdn.net/dzyhenry/article/details/8887956 1242 https://blog.csdn.net/sdc1992/article/details/7875813 2717 https://blog.csdn.net/rnzhiw/article/details/81414837 1612 https://blog.csdn.net/simoncoder/article/details/44803559","link":"/2019/10/30/BFS/"},{"title":"DFS","text":"c语言实践课 深搜应用大于宽搜 SG函数 搜索枚举 充分发挥计算机的优势 人—顿悟 DFS吃饭的时候突然想通了 递归，先写特殊情况，然后再正常 1234先把不能用的去掉小数点后四位什么时候停止呢导数是否单调递增 要么在中间，要么左边一块—和二分有什么不同 二分查找满足单调性 STL里面的二分， 中序更加抽象 先序可以确定根 中序根据根可以把它分成左右两个部分 2004年第一届省赛 c语言好的 门关上了，暗箭乱飞 停不了，班主任亲自设计的 剪枝是非常形象的 解答树，用已知的判断这些不行 流氓剪枝，限定深度剪枝找到她怎么办，暴力搜索，每个寝室搜一下 女生一定在女生宿舍，有这种情况不如不找。一个东西少走很多搜索 必须是偶数点 奇数旁边全部是偶数 如果小狗学的—痛苦是因为自己知道的太多 悔棋，一步一步悔棋 深搜走到底，摸着墙一定能走出来 宽搜 赖利，理学院，乘胜， 暴力是王道 hdoj 1010 tempter of the bone 奇偶性剪枝12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;stdio.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;math.h&gt;#define xps 1e-12using namespace std;char map[9][9];int dir[4][2] = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};int N, M, T;int flag = 0;void dfs(int x, int y, int time){ if (time &gt; T) // 这个返回条件好像不对，因为深搜会走到底 { return; //如何控制返回和有返回值的东西 } if (map[x][y] == 'D') { flag = 1; } else { for (int i = 0; i &lt; 4; i++) { int dx = x + dir[i][0]; int dy = y + dir[i][1]; if (map[dx][dy] != 'X' &amp;&amp; dx &lt; M &amp;&amp; dx &gt;= 0 &amp;&amp; dy &lt; N &amp;&amp; dy &gt;= 0) { map[dx][dy] == 'X'; dfs(dx, dx, time++); map[dx][dy] == '.'; } } } flag = 0;}int main(){ while (~scanf(\"%d %d %d\", &amp;N, &amp;M, &amp;T) &amp;&amp; N + M + T) { for (int i = 0; i &lt; N; i++) { for (int j = 0; j &lt; M; j++) { cin &gt;&gt; map[i][j]; } } dfs(0, 0, 0) } return 0;} 我们发现从0走一步一定走到1，从1走一步一定走到0。 也就是说，如果当前的狗所在的坐标与D的坐标奇偶性不一样，那么狗需要走奇数步。 同理，如果狗所在坐标与D的坐标奇偶性一样，那么狗需要走偶数步数。 也就是说，狗的坐标x、y和对2取余是它的奇偶性，Dxy和对2取余是D的奇偶性。 两个奇偶性一加再对2取余，拿这个余数去与剩下时间对2取余的余数作比较即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;bits/stdc++.h&gt;using namespace std;char Map[9][9];int n, m, t, di, dj;bool escape;int dir[4][2] = {{0, -1}, {0, 1}, {1, 0}, {-1, 0}};void dfs(int si, int sj, int cnt){ int i, temp; if (si &gt; n || sj &gt; m || si &lt;= 0 || sj &lt;= 0) // 放在前面的话有利于第一次判断 return; if (cnt == t &amp;&amp; si == di &amp;&amp; sj == dj) escape = 1; if (escape) // 已经ok了那就直接return，一次成功之后他也不会改变次数 return; temp = (t - cnt) - abs(si - di) - abs(sj - dj); // 剪枝，其实也包含了曼哈顿距离剪枝 if (temp &lt; 0 || temp % 2 == 1) // 小于0的意思是，你以最快的速度都在规定时间内到不了，后面就更不要想到了 return; for (i = 0; i &lt; 4; i++) { //int dx=si + dir[i][0]; //int dy=si + dir[i][1]; if (Map[si + dir[i][0]][dir[i][1]] != 'X') { Map[si + dir[i][0]][sj + dir[i][1]] = 'X'; dfs(si + dir[i][0], sj + dir[i][1], cnt + 1); Map[si + dir[i][0]][sj + dir[i][1]] = '.'; } } return; // escape没有改变}int main(){ int i, j, si, sj; while (cin &gt;&gt; n &gt;&gt; m &gt;&gt; t) { if (n == 0 &amp;&amp; m == 0 &amp;&amp; t == 0) break; int wall = 0; for (i = 1; i &lt;= n; i++) for (j = 1; j &lt;= m; j++) { cin &gt;&gt; Map[i][j]; if (Map[i][j] == 'S') { si = i; sj = j; } else if (Map[i][j] == 'D') // 记录一下终点比较好，不要用碰到D来做 { di = i; dj = j; } else if (Map[i][j] == 'X') wall++; } if (n * m - wall &lt;= t) // 我要踏T个格子，但是这里的障碍数比T还大 { cout &lt;&lt; \"NO\" &lt;&lt; endl; continue; } escape = 0; Map[si][sj] = 'X'; dfs(si, sj, 0); if (escape) cout &lt;&lt; \"YES\" &lt;&lt; endl; else cout &lt;&lt; \"NO\" &lt;&lt; endl; } return 0;} 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;bits/stdc++.h&gt;using namespace std;char Map[9][9];int n, m, t, di, dj;bool escape;int dir[4][2] = {{0, -1}, {0, 1}, {1, 0}, {-1, 0}};void dfs(int si, int sj, int cnt){ int i, temp; if (si &gt; n || sj &gt; m || si &lt;= 0 || sj &lt;= 0) return; if (cnt == t &amp;&amp; si == di &amp;&amp; sj == dj) escape = 1; if (escape) return; temp = (t - cnt) - abs(si - di) - abs(sj - dj); if (temp &lt; 0 || temp % 2 == 1) return; for (i = 0; i &lt; 4; i++) { int dx = si + dir[i][0]; int dy = sj + dir[i][1]; if (Map[dx][dy] != 'X') { Map[dx][dy] = 'X'; dfs(dx, dy, cnt + 1); Map[dx][dy] = '.'; } } return;}int main(){ int i, j, si, sj; while (cin &gt;&gt; n &gt;&gt; m &gt;&gt; t) { if (n == 0 &amp;&amp; m == 0 &amp;&amp; t == 0) break; int wall = 0; for (i = 1; i &lt;= n; i++) for (j = 1; j &lt;= m; j++) { cin &gt;&gt; Map[i][j]; if (Map[i][j] == 'S') { si = i; sj = j; } else if (Map[i][j] == 'D') // 记录一下终点比较好，不要用碰到D来做 { di = i; dj = j; } else if (Map[i][j] == 'X') wall++; } if (n * m - wall &lt;= t) // 我要踏T个格子，但是这里的障碍数比T还大 { cout &lt;&lt; \"NO\" &lt;&lt; endl; continue; } escape = 0; Map[si][sj] = 'X'; dfs(si, sj, 0); if (escape) cout &lt;&lt; \"YES\" &lt;&lt; endl; else cout &lt;&lt; \"NO\" &lt;&lt; endl; } return 0;} 记忆化搜索效率接近递推(递推就是固定的dp)，形式接近深搜 记忆化的话需要开辟另一个空间来存 搜索比较慢，那我直接递推不就好了么?下面来看一道例题: hdoj 1078 fat mouse and cheese有一个n*n的网格，每次最多走k个位置，{1，2，3…,k} dp怎么做，搜索怎么做，为什么选择记忆化 dp起来不方便，不是线性的，四个方向 dp:按照奶酪的数量排序，先算左边的，再算右边的 搜索:搜索的关键就是定义状态。那么怎么定义状态呢？ 回想一下之前我们定义状态。非常可乐—首先定义三个状态，三个可乐里面还剩多少可乐。行号，列号，时间，步数其实就是时间 12345678910111213141516171819202122232425262728293031323334#include &lt;bits/stdc++.h&gt;using namespace std;int n, k;int a[105][105], dp[105][105];int go[4][2] = {-1, 0, 0, 1, 1, 0, 0, -1};int dfs(int x, int y){ if (dp[x][y] &gt;= 0) return dp[x][y]; // 如果从这个点出发能吃到最多的奶酪数已经知道，则接下来的路不用走了 dp[x][y] = a[x][y]; for (int i = 0; i &lt; 4; ++i) //这里不能用else for (int j = 1; j &lt;= k; ++j) { int xx = x + j * go[i][0], yy = y + j * go[i][1]; if (xx &gt;= 0 &amp;&amp; xx &lt; n &amp;&amp; yy &gt;= 0 &amp;&amp; yy &lt; n &amp;&amp; a[xx][yy] &gt; a[x][y]) dp[x][y] = max(dfs(xx, yy) + a[x][y], dp[x][y]); // 用dfs是因为这里要不断地往下搜，max是动态规划的体现 dfs(dx,dy)+a[x][y]当前位置加上从下一个位置搜索的值 } return dp[x][y];}int main(){ while (~scanf(\"%d%d\", &amp;n, &amp;k) &amp;&amp; n != -1) { for (int i = 0; i &lt; n; ++i) for (int j = 0; j &lt; n; ++j) scanf(\"%d\", &amp;a[i][j]); memset(dp, -1, sizeof(dp)); // 赋值为-1是因为，有些地方没有奶酪 printf(\"%d\\n\", dfs(0, 0)); } return 0;} 这是一道典型的记忆化搜索模板题,思路如下: 先介绍记忆化搜索，本质是搜索+DP。 一般说来，动态规划总要遍历所有的状态，而搜索可以排除一些无效状态。更重要的是搜索还可以剪枝，可能剪去大量不必要的状态，因此在空间开销上往往比动态规划要低很多。记忆化算法在求解的时候还是按着自顶向下的顺序，但是每求解一个状态，就将它的解保存下来，以后再次遇到这个状态的时候，就不必重新求解了。这种方法综合了搜索和动态规划两方面的优点，因而还是很有实用价值的。 记忆化搜索（Memory Search），其实还是用递归函数实现的，通常函数名依然叫做dfs。核心语句就是那两部分关键的语句块： 1.函数一开始的判断出口：if(搜索过) return 数组中的值。因为这里涉及到是否搜索过，所以一般将数组初始化为-1。 2.函数的递归前进语句：return fib[i]=fib[i-1]+fib[i-2];（没有具体的例子实在不好说了，所以这里用fib数列来做演示）。这样就做到了数组的每个值只计算了一次，不会有多余的时间消耗。 下面就这道题来讲记忆化搜索基本模板，用dp[i][j]表示从(i,j)出发吃到的cheese最多的值，用(x,y)表示其邻点，则： $dp[i][j]=max(dp[i][j],a[i][j]+dp[x][y])$（满足a[x][y]&gt;a[i][j]时）。在这个递推式中，如果dp[i][j]被计算过一次，其值就是最终值，不用再计算。但是如果使用一般的dfs，则会出现大量重复计算一个值的情况，必然会超时。所以采用记忆化搜索，在递推过程中如果一个值被计算过(&gt;=0)，直接返回即可，否则计算其最终值并赋给它。也可以使用DP做这道题，但是要先排序，按照顺序来DP，但比较麻烦。而记忆化搜索则简洁自然许多，其实质当然就是DP。 16的和 12的一半不是16 6，123加起来还是6 组数和n都是50w 数组初始化为1，然后2的倍数加2 一次运行多测试几组数据 n*n+1生成一个临时变量存在里面 先乘后除和先除后乘有什么区别 直接复制 回车空格都是字符 一兆，4个字节数组超过二十多万就要定义为全局变量rre爆栈 正数，没说 输入输出保证在10^18次方之内，隐含的信息就是n很小不是爆栈，内存也爆了 其实最大的不会超过 听了课没有练习，勇敢地去写，迈出这一步，越过去就好了 hdoj 2571 命运1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 101;int row, col;int a[25][1005];int dp[25][1005];int dfs(int x, int y){ if (dp[x][y] &gt;= 0) //不能单纯这样判断搜索过，因为这个图里面是有正负的 return dp[x][y]; //等于0也算来过 dp[x][y] = a[x][y]; //int temp=-1; if (x &lt; row) { dp[x][y] = max(dp[x][y], dfs(x + 1, y) + a[x][y]); } if (y &lt; col) { dp[x][y] = max(dp[x][y], dfs(x, y + 1) + a[x][y]); } for (int i = 2 * y; i &lt; col; i += y) dp[x][y] = max(dp[x][y], dfs(x, i) + a[x][y]); return dp[x][y];}int main(){ int n; cin &gt;&gt; n; while (n--) { scanf(\"%d %d\", &amp;row, &amp;col); for (int i = 0; i &lt; row; i++) for (int j = 0; j &lt; col; j++) cin &gt;&gt; a[i][j]; memset(dp, -1, sizeof(dp)); printf(\"%d\\n\", dfs(0, 0)); } return 0;} AC代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#define INF 0x3f3f3f3fusing namespace std; int n,m;int vis[25][1005],mp[25][1005]; int maxx(int a,int b){ return a&gt;b?a:b;} int dfs(int x,int y){ if(x==n &amp;&amp; y==m) return mp[x][y]; // 不用|| 是因为这个代表队是走到最后一步要走回去了 if(vis[x][y]!=-INF) return vis[x][y]; int tmp=-INF; if(x&lt;n) tmp=maxx(tmp,dfs(x+1,y)); if(y&lt;m) tmp=maxx(tmp,dfs(x,y+1)); for(int i=2*y;i&lt;=m;i+=y) //不用0是因为会导致这里死循环 tmp=maxx(tmp,dfs(x,i)); return vis[x][y]=tmp+mp[x][y];}int main(){ int T; scanf(\"%d\",&amp;T); while(T--) { scanf(\"%d%d\",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) { for(int j=1;j&lt;=m;j++) { scanf(\"%d\",&amp;mp[i][j]); vis[i][j]=-INF; } } printf(\"%d\\n\",dfs(1,1)); } return 0;} 这个程序有几点需要注意: 以后迷宫题最好从1开始算 赋值语句，最后返回的是自己本身？ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#define INF 0x3f3f3f3fusing namespace std; int n,m;int vis[25][1005],mp[25][1005]; int maxx(int a,int b){ return a&gt;b?a:b;} int dfs(int x,int y){ if(x==n &amp;&amp; y==m) return mp[x][y]; if(vis[x][y]!=-INF) return vis[x][y]; int tmp=-INF; if(x&lt;n) tmp=maxx(tmp,dfs(x+1,y)); if(y&lt;m) tmp=maxx(tmp,dfs(x,y+1)); for(int i=2*y;i&lt;=m;i+=y) tmp=maxx(tmp,dfs(x,i)); vis[x][y] = tmp+mp[x][y]; return vis[x][y];}int main(){ int T; scanf(\"%d\",&amp;T); while(T--) { scanf(\"%d%d\",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) { for(int j=1;j&lt;=m;j++) { scanf(\"%d\",&amp;mp[i][j]); vis[i][j]=-INF; } } printf(\"%d\\n\",dfs(1,1)); printf(\"%d\\n\",vis[n][m]); printf(\"%d\\n\",vis[1][1]); printf(\"%d\\n\",vis[n][m] = vis[1][1]+2); } return 0;}","link":"/2019/11/06/DFS/"},{"title":"Linux基本命令","text":"1234567cd返回原始文件夹**ctrl+a快速回到行首 ctrl+ewin+r r==runsudu apt install net-tools上下返回上一次命令","link":"/2019/11/13/Linux基本命令/"},{"title":"kmp算法","text":"什么是kmp算法快速地从某一个主串找到一个模式串 暴力匹配算法指针回到开头，称为指针的回溯 kmp算法有几点需要你注意的 在某个字符不匹配之前，前面都是匹配的 匹配的那些字符中，有公共的前缀和后缀 移动之后，指针所在左边的字符串还是和原来一样的，因为我把前缀移到了后缀的地方 不会跳过一些匹配的位置，因为不会存在 如果跳过了一些匹配的位置，我们的公共前后缀根本不是最长的 找最长的公共前后缀，必须小于某个长度。因为如果等于这个长度的话。根本不需要移动 数组是不可以移动的 做移动的过程中，根本不需要比较主串，从1，0开始存也行 假设这个字符串会和任何一个主串发生kmp算法， 同时假设每一个位置都可能发生不匹配 比较位置发生变化，就是让某一个位置和主串发生比较 比较的位置其实就是最大公共前后缀+1 上一个就是下一步数组","link":"/2019/10/30/KMP算法/"},{"title":"","text":"Java基础JavaSE — Java platform standard edition 平台标准版 JavaEE — enterprise edition 平台企业版 JavaME — micro edition 平台微型版 Java 语言的优点跨平台性 抛弃了操作符重载，多继承，自动的强制类型转换 提供类、接口、和继承。只支持类之间的单继承，但支持接口之间的多继承并支持类与接口的实现机制 不支持指针，只能通过对象的实例来访问内存 Oracle Berkeley 数据库 工作原理JVM，执行.class文件JVM解释器：处理字段码的CPU JVM指令系统：说明一条指令的功能。由操作码和操作数组成。 寄存器：与解释器进行数据交换 JVM栈：指令执行时，数据和信息存储的场所和控制中心 存储区：存储编译过的字节码 碎片回收区：使用过的具体实例从内存中进行回收，可以避免编程控制内存的麻烦和危险 无用内存自动回收机制把不再使用的内存释放掉，但在Java的运行环境中，始终存在着一个系统级的线程，来跟踪内存的使用情况","link":"/2020/01/22/Java学习笔记/"},{"title":"","text":"输出double类型时，如果采用G++提交，scanf采用%lf,prinf采用%f，否则会报错 POJ上提交代码，Language里面有很多选项，其他选项没什么好说的，里面的G++,C++,GCC,C很容易让人迷糊 可以说明一下，G++和GCC分别是C++和C的编译器，C++和C是语言。 但POJ上的则表示你提交代码运行所需的编译器，C和C++对应的编译器是VC++ 2008里面的C和C++编译器，而GCC和G++则对应相应的编译器。 一般而言，G++和C++选项下的代码是没有差异的，但在库上面，两者有一定差距，比如G++默认可以cin一个string变量，而选择C++时则需要#include，如果用C++编写代码，提交时最好选择G++作为编译器。","link":"/2019/11/17/OJ注意事项/"},{"title":"","text":"申请条件语言成绩 绩点 项目，实习经历 政策准备东西 申请时间","link":"/2019/11/20/NUS升学准备/"},{"title":"","text":"1234567891011121314151617181920The Zen of Python, by Tim PetersBeautiful is better than ugly.Explicit is better than implicit.Simple is better than complex.Complex is better than complicated.Flat is better than nested.Sparse is better than dense.Readability counts.Special cases aren't special enough to break the rules.Although practicality beats purity.Errors should never pass silently.Unless explicitly silenced.In the face of ambiguity, refuse the temptation to guess.There should be one-- and preferably only one --obvious way to do it.Although that way may not be obvious at first unless you're Dutch.Now is better than never.Although never is often better than *right* now.If the implementation is hard to explain, it's a bad idea.If the implementation is easy to explain, it may be a good idea.Namespaces are one honking great idea -- let's do more of those! 优美胜于丑陋明了胜于晦涩简洁胜于复杂复杂胜于凌乱扁平胜于嵌套间隔胜于紧凑 字符串移除字符串多余的空白rstrip(),lstrip(),strip() strip剥去，r是右边的意思，l是左边的意思 if name == ‘main‘的作用if name == ‘main‘:的作用一个python文件通常有两种使用方法，第一是作为脚本直接执行，第二是 import 到其他的 python 脚本中被调用（模块重用）执行。因此 if name == ‘main’: 的作用就是控制这两种情况执行代码的过程，在 if name == ‘main’: 下的代码只有在第一种情况下（即文件作为脚本直接执行）才会被执行，而 import 到其他脚本中是不会被执行的。举例说明如下： 直接执行 直接执行 test.py，结果如下图，可以成功 print 两行字符串。即，if name==”main“: 语句之前和之后的代码都被执行。 import 执行 然后在同一文件夹新建名称为 import_test.py 的脚本，输入如下代码： 执行 import_test.py 脚本，输出结果如下： 只输出了第一行字符串。即，if name==”main“: 之前的语句被执行，之后的没有被执行。 if name == ‘main‘:的运行原理每个python模块（python文件，也就是此处的 test.py 和 import_test.py）都包含内置的变量 name，当该模块被直接执行的时候，name 等于文件名（包含后缀 .py ）；如果该模块 import 到其他模块中，则该模块的 name 等于模块名称（不包含后缀.py）。 而 “main” 始终指当前执行模块的名称（包含后缀.py）。进而当模块被直接执行时，name == ‘main’ 结果为真。 为了进一步说明，我们在 test.py 脚本的 if name==”main“: 之前加入 print(name)，即将 name 打印出来。文件内容和结果如下： 可以看出，此时变量name的值为”main“。 再执行 import_test.py，执行结果如下： 此时，test.py中的name变量值为 test，不满足 name==”main“ 的条件，因此，无法执行其后的代码。","link":"/2020/01/25/Python入门笔记/"},{"title":"","text":"SQL教程SQL简介SQL简述以及NoSQL你可能还听说过NoSQL数据库，也就是非SQL的数据库，包括MongoDB、Cassandra、Dynamo等等，它们都不是关系数据库。有很多人鼓吹现代Web程序已经无需关系数据库了，只需要使用NoSQL就可以。但事实上，SQL数据库从始至终从未被取代过。回顾一下NoSQL的发展历程： 1970: NoSQL = We have no SQL 1980: NoSQL = Know SQL 2000: NoSQL = No SQL! 2005: NoSQL = Not only SQL 2013: NoSQL = No, SQL! 今天，SQL数据库仍然承担了各种应用程序的核心数据存储，而NoSQL数据库作为SQL数据库的补充，两者不再是二选一的问题，而是主从关系。所以，无论使用哪种编程语言，无论是Web开发、游戏开发还是手机开发，掌握SQL，是所有软件开发人员所必须的。 数据库概述 应用程序不需要自己管理数据，而是通过数据库软件提供的接口来读写数据 至于数据本身如何存储到文件，那是数据库软件的事情 数据模型层次模型层次模型就是以“上下级”的层次关系来组织数据的一种方式，层次模型的数据结构看起来就像一颗树： 123456789101112131415 ┌─────┐ │ │ └─────┘ │ ┌───────┴───────┐ │ │ ┌─────┐ ┌─────┐ │ │ │ │ └─────┘ └─────┘ │ │ ┌───┴───┐ ┌───┴───┐ │ │ │ │┌─────┐ ┌─────┐ ┌─────┐ ┌─────┐│ │ │ │ │ │ │ │└─────┘ └─────┘ └─────┘ └─────┘ 网状模型网状模型把每个数据节点和其他很多节点都连接起来，它的数据结构看起来就像很多城市之间的路网： 123456789101112131415 ┌─────┐ ┌─────┐ ┌─│ │──────│ │──┐ │ └─────┘ └─────┘ │ │ │ │ │ │ └──────┬─────┘ │ │ │ │┌─────┐ ┌─────┐ ┌─────┐│ │─────│ │─────│ │└─────┘ └─────┘ └─────┘ │ │ │ │ ┌─────┴─────┐ │ │ │ │ │ │ ┌─────┐ ┌─────┐ │ └──│ │─────│ │──┘ └─────┘ └─────┘ 关系模型关系模型把数据看作是一个二维表格，任何数据都可以通过行号+列号来唯一确定，它的数据模型看起来就是一个Excel表： 123456789┌─────┬─────┬─────┬─────┬─────┐│ │ │ │ │ │├─────┼─────┼─────┼─────┼─────┤│ │ │ │ │ │├─────┼─────┼─────┼─────┼─────┤│ │ │ │ │ │├─────┼─────┼─────┼─────┼─────┤│ │ │ │ │ │└─────┴─────┴─────┴─────┴─────┘ 数据类型对于一个关系表，除了定义每一列的名称外，还需要定义每一列的数据类型。关系数据库支持的标准数据类型包括数值、字符串、时间等： 名称 类型 说明 INT 整型 4字节整数类型，范围约+/-21亿 BIGINT 长整型 8字节整数类型，范围约+/-922亿亿 REAL 浮点型 4字节浮点数，范围约+/-1038 DOUBLE 浮点型 8字节浮点数，范围约+/-10308 DECIMAL(M,N) 高精度小数 由用户指定精度的小数，例如，DECIMAL(20,10)表示一共20位，其中小数10位，通常用于财务计算 CHAR(N) 定长字符串 存储指定长度的字符串，例如，CHAR(100)总是存储100个字符的字符串 VARCHAR(N) 变长字符串 存储可变长度的字符串，例如，VARCHAR(100)可以存储0~100个字符的字符串 BOOLEAN 布尔类型 存储True或者False DATE 日期类型 存储日期，例如，2018-06-22 TIME 时间类型 存储时间，例如，12:20:59 DATETIME 日期和时间类型 存储日期+时间，例如，2018-06-22 12:20:59 上面的表中列举了最常用的数据类型。很多数据类型还有别名，例如，REAL又可以写成FLOAT(24)。还有一些不常用的数据类型，例如，TINYINT（范围在0~255）。各数据库厂商还会支持特定的数据类型，例如JSON。 选择数据类型的时候，要根据业务规则选择合适的类型。通常来说，BIGINT能满足整数存储的需求，VARCHAR(N)能满足字符串存储的需求，这两种类型是使用最广泛的。 什么是SQL什么是SQL？SQL是结构化查询语言的缩写，用来访问和操作数据库系统。SQL语句既可以查询数据库中的数据，也可以添加、更新和删除数据库中的数据，还可以对数据库进行管理和维护操作。不同的数据库，都支持SQL，这样，我们通过学习SQL这一种语言，就可以操作各种不同的数据库。 虽然SQL已经被ANSI组织定义为标准，不幸地是，各个不同的数据库对标准的SQL支持不太一致。并且，大部分数据库都在标准的SQL上做了扩展。也就是说，如果只使用标准SQL，理论上所有数据库都可以支持，但如果使用某个特定数据库的扩展SQL，换一个数据库就不能执行了。例如，Oracle把自己扩展的SQL称为PL/SQL，Microsoft把自己扩展的SQL称为T-SQL。 现实情况是，如果我们只使用标准SQL的核心功能，那么所有数据库通常都可以执行。不常用的SQL功能，不同的数据库支持的程度都不一样。而各个数据库支持的各自扩展的功能，通常我们把它们称之为“方言”。 语句操作总的来说，SQL语言定义了这么几种操作数据库的能力： DDL：Data Definition Language DDL允许用户定义数据，也就是创建表、删除表、修改表结构这些操作。通常，DDL由数据库管理员执行。 DML：Data Manipulation Language DML为用户提供添加、删除、更新数据的能力，这些是应用程序对数据库的日常操作。 DQL：Data Query Language DQL允许用户查询数据，这也是通常最频繁的数据库日常操作。 语法特点SQL语言关键字不区分大小写！！！但是，针对不同的数据库，对于表名和列名，有的数据库区分大小写，有的数据库不区分大小写。同一个数据库，有的在Linux上区分大小写，有的在Windows上不区分大小写。 所以，本教程约定：SQL关键字总是大写，以示突出，表名和列名均使用小写。 安装MySQL MySQL本质上只是一个SQL接口 MySQL接口和数据库引擎的关系就好比某某浏览器和浏览器引擎（IE引擎或Webkit引擎）的关系。对用户而言，切换浏览器引擎不影响浏览器界面，切换MySQL引擎不影响自己写的应用程序使用MySQL的接口。 使用MySQL时，不同的表还可以使用不同的数据库引擎。如果你不知道应该采用哪种引擎，记住总是选择InnoDB就好了 要在Windows或Mac上安装MySQL，首先从MySQL官方网站下载最新的MySQL Community Server版本： https://dev.mysql.com/downloads/mysql/ 选择对应的操作系统版本，下载安装即可。在安装过程中，MySQL会自动创建一个root用户，并提示输入root口令。 要在Linux上安装MySQL，可以使用发行版的包管理器。例如，Debian和Ubuntu用户可以简单地通过命令apt-get install mysql-server安装最新的MySQL版本。 忘了root命令 https://www.cnblogs.com/wxdblog/p/6864475.html 关系模型详解 表中的每一行叫做记录(Record)，每一列叫做字段(Column) NULL并不是0，NULL表示字段数据不存在啊，但是0他是有确切数值的 多去看别人的代码，就比如说别人的markdown markdown已经自动帮我们空了两行","link":"/2019/10/14/SQL教程/"},{"title":"","text":"C:\\Users\\legion\\AppData\\Local\\Temp\\pip-install-s5urerni\\dlib python命令 换镜像源 wheel","link":"/2019/12/01/dlib安装/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment 1.出现 error deployer not found:git 或者 error deployer not found:github 的错误解决办法：执行 npm install hexo-deployer-git --save 2.出现类似 FATAL can not read a block mapping entry; a multiline key may not be an implicit key at line 70, column 1: … 错误解决办法：_config.yml中配置项的冒号后面要用空格隔开，再跟内容 3.中文乱码问题解决办法：将文件的内容编码改为UTF8格式 4.’hexo sever’能够成功运行，但是localhost:4000无法访问解决办法：执行hexo s -p 5000，改用其他端口启动 hexo command not found 加入环境变量 node 没有的话就是没装nodejs","link":"/2019/09/22/hello-world/"},{"title":"STL用法","text":"STL 种类vector Name map&lt;ElemType,ElemType&gt; Name //映射 queue Name stack Name set Name 结构体用法结构体排序首先是结构体的定义 123456789struct Wood{ string sth1; int sth2; //struct// Wood(){} //这两个构造函数到底是什么意思 Wood(string n,int s):name(n),sth2(s){}};struct Wood wood[number]; 比较字符串的话就是strcmp(数组名1，数组名2) 反正就是把一个字符型指针变量传进去 然后是结构体的排序 123bool cmp(Wood x,Wood y) //用这个结构体去定义另一个结构体？ Wood x 为什么可以看作一个结构体 结构体构造函数1234567891011struct Wood{ string name; int score; //struct// Wood(){} //先构造一个函数，这个结构体是一个函数 Wood(string n,int s):name(n),sth2(s){} //函数一定要有 //冒号后面是初始化};struct Wood wood[number]; 初始化列表的写法是: 在构造函数的括号后面加一个冒号，然后按照成员变量（参数）的格式，依次对每一个变量初始化，彼此之间用逗号隔开 参数列表绝对不能省略，像Student():name(n),score(s)这样的写法是不允许的 大括号后面是做其他的事情 对于结构体这样一个我们自己定义的对象来说，除非实现给出明确的规定，编译器是不知道按照什么样的规则来初始化的 为了解决这个问题，c++语言的语法中为我们提供了一种特殊的机制—构造函数。 构造函数是一种定义在结构体中的特殊函数，它可以被用于描述对结构体初始化的算法 比如说，对于我们定义的student结构体，我们可以定义一个具有两个参数的构造函数。这样就可以一步到位地完成结构体成员赋值 12cin&gt;&gt;score_input&gt;&gt;name_input;Student Stu(score_input,name_input); 在c++中，结构体内不仅可以定义变量成员，也可以定义函数成员 12345678910struct Student{ int score; string name; Student(string n,int s){ name = n; score = s; } //函数名字一定要和结构体名字一样 //不能有返回值类型 //可以重载} 在定义构造函数的时候，可以有参数表，也可以让参数表空着—同样，即使是一个构造函数有参数，我们也可以给它的所有参数都设置一个默认值。这样的构造函数，称为默认构造函数 123456struct Student{ int score; string name; Student(){} //默认构造函数 Student(string n= \"\",int s=0){} // 不能有两个构造函数，两个做的事情不一样，不能同时有}; 浮点数比较相等12const double EPSILON = 1e-6;fabs(a-b) &lt; EPSILON; //认为相等 队列和Queue队列头文件:#include &lt;queue&gt; 队列的相关操作: 1234567queue &lt;type&gt; q; // 定义栈，type为数据类型，例如int，float，char等q.push(item); // 把item放进队列q.front(); // 返回队首元素，但不会删除q.pop(); // 删除队首元素q.back(); // 返回队尾元素q.size(); // 返回元素个数q.empty(); // 检查队列是否为空 优先队列和 priority_queueMaphdoj 2648 shopping自己的算法 1234567891011121314151617181920212223242526#include&lt;bits/stdc++.h&gt;using namespace std;int main(){ int n,day; map&lt;string,int&gt;shop; cin&gt;&gt;n; for (int i = 0; i &lt;n; i++) { cin&gt;&gt;string;//输不输入没有关系，因为后面也会输入商家的名字 shop[string] = 0; } cin&gt;&gt;day; for(int i=0;i&lt; day*n ;i++){ // 其实可以不用这么蠢的循环六天，直接就循环两天 cin&gt;&gt;s&gt;&gt;string; shop[string]+=s; if(i%n == 0){ for(int i=0; ){ if(shop[]&gt;shop[memory]) cnt++; } cout&lt;&lt;cnt+1; } } } 123456789101112131415161718192021222324252627282930313233#include &lt;bits/stdc++.h&gt;using namespace std;int main(){ int n, m, p; map&lt;string, int&gt; shop; while (cin &gt;&gt; n) { string s; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; s; cin &gt;&gt; m; while (m--) { for (int i = 1; i &lt;= n; i++) { cin &gt;&gt; p &gt;&gt; s; shop[s] += p; } int rank = 1; map&lt;string, int&gt;::iterator it; for (it = shop.begin(); it != shop.end(); it++) { if (it-&gt;second &gt; shop[\"memory\"]) rank++; } cout &lt;&lt; rank &lt;&lt; endl; } shop.clear(); // 有些地方要手动清栈 } return 0;} 几个注意的点： map&lt;string, int&gt;::iterator it 迭代器可以理解为指针，不断地往一个方向指 it-&gt;second指的是数字的部分 SET12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 105;const int INF = 1e6;int main(){ int n1, m1; while (~scanf(\"%d %d\", &amp;n1, &amp;m1) &amp;&amp; n1 + m1) { int num; set&lt;int&gt; n; set&lt;int&gt; m; for (int i = 0; i &lt; n1; i++) { scanf(\"%d\", &amp;num); n.insert(num); } for (int i = 0; i &lt; m1; i++) { scanf(\"%d\", &amp;num); m.insert(num); } for (set&lt;int&gt;::iterator iter = m.begin(); iter != m.end(); ++iter) { if (n.count(*iter)) n.erase(*iter); } if (!n.empty()) { for (set&lt;int&gt;::iterator iter = n.begin(); iter != n.end(); ++iter) { printf(\"%d \", *iter); } printf(\"\\n\"); } else cout &lt;&lt; \"NULL\" &lt;&lt; endl; } return 0;}","link":"/2019/10/29/STL用法/"},{"title":"","text":"文末附代码 做这个的目的主要是对科比的缅怀吧（当然主要是在家闲的蛋疼） 科比的死真的给了我很大的震撼。 他的死让我不禁思考起了如何对待死亡这个话题。其实之前也有很多名人死了之后我都有触动一下，比如说姚贝娜，李咏，金庸，李敖，师胜杰，诸时健等等。他们也是家喻户晓的人物，但是我好像没有沉浸在他们死去的悲伤之中。在科比死后，我有时候会感觉到恍惚，竟然就死了？不是昨天才得分被詹姆斯超越么？不是之前还天天播着他的广告？不是经常在湖人看比赛么？我想，所谓死亡不死亡，想念不想念，都是羁绊造成的。 在《火影》中，宇智波带土一直不被看好，是琳一直在她身边，但她死后，一系列阴差阳错的事也让带土走上了一条毁灭世界的道路。对琳的思念即支撑他活着，也让他想毁灭旧世界，创造一个属于琳的世界。这就是所谓的爱得越深，伤得越痛吧。我之所以会对科比的死那么念叨，是因为我之前一直看nba，一直嘲笑科比打铁，觉得科比的每一款球鞋都好帅，又没钱，只能拼命考好得到奖励之后去买一双科比球鞋。 这就是我和科比之间的羁绊吧！ 可现在他死了，这种羁绊也就让我不敢相信他死了，也让我觉得一切是那么的突然。我觉得我就是属于那种，有人死了，当时不会特别伤心，但是以后如果看到和他相关的事情就会控制不住自己的情绪。可是人终有一死，我们永远也不知道明天和意外哪个先来。那所谓的这种羁绊又有什么用呢。 带土在快被十尾四分五裂的时候，是和琳的羁绊，挽救了他最后的意志，让他继续生活了下去。所以在我现在看来，所谓的羁绊，不是在失去之后，打碎我们的世界。而是在我们世界将要崩塌的时候，还能守住我们最后内心的空缺。 曾经有记者问科比，你为什么能这么成功。科比反问到：“你见过凌晨四点的洛杉矶么？”。记者摇摇头说：“不知道，那你说说洛杉矶早上四点钟究竟是怎么样的？”科比挠挠头，说：“洛杉矶早上四点时满天星星，寥落的灯光，行人很少；而我已经起床行走在黑暗的洛杉矶街道 上。一天过去了，两天过去了，十多年过去了。洛杉矶黑暗没有丝毫改变，但我却已变成了肌肉强健，有体能、有力量，有着很高投篮命中率的运动员。” “你见过凌晨四点的洛杉矶么？”，科比的这个黑曼巴精神鼓舞了不知道多少平凡人，各界明星。在以后，和科比的羁绊也会一直鼓励着我们带着希望前行。 逝者如斯，而未尝往也；盈虚者如彼，而卒莫消长也。盖将自其变者而观之，则天地曾不能以一瞬；自其不变者而观之，则物与我皆无尽也，而又何羡乎! — 《前赤壁赋》 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150# Get all Kobe shot data from 1996 to 2016 and put it into an array# This player ID comes from stats.nba.com (http://stats.nba.com/player/#!/977/stats/)playerID = \"977\"seasons = []for season in range(1996,2016): # The stats.nba.com API wants season as \"1996-97\" seasonString = str(season) + '-' + str(season+1)[2:] # The stats.nba.com endpoint we are using is http://stats.nba.com/stats/shotchartdetail shot_chart_url = 'http://stats.nba.com/stats/shotchartdetail?Period=0&amp;VsConference=&amp;LeagueID=00&amp;LastNGames=0&amp;TeamID=0&amp;Position=&amp;Location=&amp;Outcome=&amp;ContextMeasure=FGA&amp;DateFrom=&amp;StartPeriod=&amp;DateTo=&amp;OpponentTeamID=0&amp;ContextFilter=&amp;RangeType=&amp;Season=' + seasonString + '&amp;AheadBehind=&amp;PlayerID='+ playerID +'&amp;EndRange=&amp;VsDivision=&amp;PointDiff=&amp;RookieYear=&amp;GameSegment=&amp;Month=0&amp;ClutchTime=&amp;StartRange=&amp;EndPeriod=&amp;SeasonType=Regular+Season&amp;SeasonSegment=&amp;GameID=' response = requests.get(shot_chart_url, headers=HEADERS) # Split response into headers and content headers = response.json()['resultSets'][0]['headers'] shots = response.json()['resultSets'][0]['rowSet'] # Create pandas dataframe to hold the data shot_df = pd.DataFrame(shots, columns=headers) # add extra column for season shot_df['SEASON'] = seasonString # add extra column for playoff flag shot_df['playoffs'] = 0 seasons.append(shot_df) # Combine NBA's very specific shot type descriptions into broader categories for filtering# combine shot typeskobe_all_shots['COMBINED_SHOT_TYPE'] = kobe_all_shots['ACTION_TYPE']kobe_all_shots.replace(to_replace={ 'COMBINED_SHOT_TYPE': { '(.+)?Jump (.+)?(S|s)hot':'Jump Shot', '(.+)?Fadeaway(.+)?':'Jump Shot', '(.+)?Dunk Shot':'Dunk', '(.+)?Layup (S|s)hot': \"Layup\", '(.+)?Hook.+':\"Hook Shot\", '(.+)?Tip.+':\"Tip Shot\", '(.+)?Bank.+':\"Bank Shot\", '(.+)?Finger Roll.+':\"Layup\" } }, regex=True, inplace=True)kobe_all_shots.COMBINED_SHOT_TYPE.value_counts()# Draw the court — this code comes from Savvas Tjortjoglou (http://savvastjortjoglou.com/nba-shot-sharts.html)def draw_court(ax=None, color='black', lw=2, outer_lines=False): # If an axes object isn't provided to plot onto, just get current one if ax is None: ax = plt.gca() # Create the various parts of an NBA basketball court # Create the basketball hoop # Diameter of a hoop is 18\" so it has a radius of 9\", which is a value # 7.5 in our coordinate system hoop = Circle((0, 0), radius=7.5, linewidth=lw, color=color, fill=False) # Create backboard backboard = Rectangle((-30, -7.5), 60, -1, linewidth=lw, color=color) # The paint # Create the outer box 0f the paint, width=16ft, height=19ft outer_box = Rectangle((-80, -47.5), 160, 190, linewidth=lw, color=color, fill=False) # Create the inner box of the paint, widt=12ft, height=19ft inner_box = Rectangle((-60, -47.5), 120, 190, linewidth=lw, color=color, fill=False) # Create free throw top arc top_free_throw = Arc((0, 142.5), 120, 120, theta1=0, theta2=180, linewidth=lw, color=color, fill=False) # Create free throw bottom arc bottom_free_throw = Arc((0, 142.5), 120, 120, theta1=180, theta2=0, linewidth=lw, color=color, linestyle='dashed') # Restricted Zone, it is an arc with 4ft radius from center of the hoop restricted = Arc((0, 0), 80, 80, theta1=0, theta2=180, linewidth=lw, color=color) # Three point line # Create the side 3pt lines, they are 14ft long before they begin to arc corner_three_a = Rectangle((-220, -47.5), 0, 140, linewidth=lw, color=color) corner_three_b = Rectangle((220, -47.5), 0, 140, linewidth=lw, color=color) # 3pt arc - center of arc will be the hoop, arc is 23'9\" away from hoop # I just played around with the theta values until they lined up with the # threes three_arc = Arc((0, 0), 475, 475, theta1=22, theta2=158, linewidth=lw, color=color) # Center Court center_outer_arc = Arc((0, 422.5), 120, 120, theta1=180, theta2=0, linewidth=lw, color=color) center_inner_arc = Arc((0, 422.5), 40, 40, theta1=180, theta2=0, linewidth=lw, color=color) # List of the court elements to be plotted onto the axes court_elements = [hoop, backboard, outer_box, inner_box, top_free_throw, bottom_free_throw, restricted, corner_three_a, corner_three_b, three_arc, center_outer_arc, center_inner_arc] if outer_lines: # Draw the half court line, baseline and side out bound lines outer_lines = Rectangle((-250, -47.5), 500, 470, linewidth=lw, color=color, fill=False) court_elements.append(outer_lines) # Add the court elements onto the axes for element in court_elements: ax.add_patch(element) return ax# Get all Kobe game logs from 1996 to 2016seasons_games = []for season in range(1996,2016): # get regular season game logs gamelog_url = 'http://stats.nba.com/stats/playergamelog?LeagueID=00&amp;PerMode=PerGame&amp;PlayerID='+ playerID +'&amp;Season='+str(season) + '-' + str(season+1)[2:]+'&amp;SeasonType=Regular+Season' response = requests.get(gamelog_url, headers=HEADERS) headers = response.json()['resultSets'][0]['headers'] gamelogs = response.json()['resultSets'][0]['rowSet'] gamelog_df = pd.DataFrame(gamelogs, columns=headers) gamelog_df['SEASON'] = str(season) + '-' + str(season+1)[2:] seasons_games.append(gamelog_df) # Grab opponent from matchuip and condense some opponent nameskobe_game_logs[\"OPPONENT\"] = kobe_game_logs[\"MATCHUP\"].str[-3:]kobe_game_logs.replace(to_replace={ 'OPPONENT': { \"CHH\":\"CHA\", \"NOK\":\"NOP\", \"PHO\":\"PHX\", \"SAN\":\"SAS\", \"UTH\":\"UTA\" } }, regex=True, inplace=True)kobe_game_logs.OPPONENT.value_counts().sort_index()# save to csv# kobe_game_logs.to_csv(\"kobe_game_logs.csv\")","link":"/2020/01/31/kebe算法分析/"},{"title":"","text":"web安全培训4**问题出在客户端 5**gateaway502 请求静态资源 动态：携带参数，数据库的 html harchml 什么叫超文本，标记语言？ 老婆之一 标记，你帮我渲染成怎么样，是什么意思 html太丑了，html就是一个骨架 typescript，js写的VS code dom树 内联或者导入 前端可能会出现哪些安全问题 返回的script不一样，弹窗，导入信息 xss，重复了css 发送到微博里面，发送一个html文件 script帮你转义了，尖括号转成圆括号 js会在console里面 js转义成中文括号， 换一个编码格式发进去 往年都是弹个窗， js伪造我的身份换头像，大家给点掌声谢谢，自己搞得很激动 .php把php解析了 CGI http-给解释器解释 cgi到解释器，伪造服务器和cgi通信 php解释器 水平越权，我可以删除其他人的照片 sql注入登陆 id改一下说不定就可以越权了 post抓包，易班水平越权 学到什么程序尽可能的往深度学 检验方法–写几个小程序，小项目 小犀牛 看官方文档和评论 心里有个规律，视察xss 网络windows有工作组 平时写的markdown文件","link":"/2019/12/06/vidarteam培训/"},{"title":"leetcode刷题","text":"175 组合两个表1234567/* Write your T-SQL query statement below */select firstname,lastname,city,statefrom person per left join address addron addr.personid = per.personid-- add这种会重复的变量最好别用-- 左连接就是不管左边符合不符合，右边都会出现值 176 第二高的薪水方法一：使用子查询和 LIMIT 子句算法 将不同的薪资按降序排序，然后使用 LIMIT 子句获得第二高的薪资。 12345678910111213141516171819MySQLSELECT DISTINCT Salary AS SecondHighestSalaryFROM EmployeeORDER BY Salary DESCLIMIT 1 OFFSET 1 //MS没有这个语句方法二：使用 IFNULL 和 LIMIT 子句解决 “NULL” 问题的另一种方法是使用 “IFNULL” 函数，如下所示。MySQLSELECT IFNULL( (SELECT DISTINCT Salary FROM Employee ORDER BY Salary DESC LIMIT 1 OFFSET 1), NULL) AS SecondHighestSalary 然而，如果没有这样的第二最高工资，这个解决方案将被判断为 “错误答案”，因为本表可能只有一项记录。为了克服这个问题，我们可以将其作为临时表。 123456789MySQLSELECT (SELECT DISTINCT Salary FROM Employee ORDER BY Salary DESC LIMIT 1 OFFSET 1) AS SecondHighestSalary; 方法二：使用 IFNULL 和 LIMIT 子句解决 “NULL” 问题的另一种方法是使用 “IFNULL” 函数，如下所示。 12345678MySQLSELECT IFNULL( (SELECT DISTINCT Salary FROM Employee ORDER BY Salary DESC LIMIT 1 OFFSET 1), NULL) AS SecondHighestSalary IFNULL函数的介绍IFNULL() 函数用于判断第一个表达式是否为 NULL，如果为 NULL 则返回第二个参数的值，如果不为 NULL 则返回第一个参数的值。 IFNULL() 函数语法格式为： 1IFNULL(expression, alt_value) 如果第一个参数的表达式 expression 为 NULL，则返回第二个参数的备用值。 参数说明: 参数 描述 expression 必须，要测试的值 alt_value 必须，expression 表达式为 NULL 时返回的值 181 超过经理收入的员工12345678select Name as Employeefrom Employee Emp_1where Salary &gt; ( select Salary from Employee Emp_2 where Emp_1.ManagerId = Emp_2.Id );-- mssql 在执行语句的时候是先执行子查询的 123456SELECT a.NAME AS EmployeeFROM Employee AS a inner JOIN Employee AS b ON a.ManagerId = b.Id AND a.Salary &gt; b.Salary-- 用inner join的话可以直接把有null值的去掉 182 查找重复的电子邮箱1234select Emailfrom Persongroup by Emailhaving count(Email) &gt; 1; 1234567select Email from( select Email, count(Email) as num from Person group by Email) as statisticwhere num &gt; 1 178 分数排名1234selects.Score , (select if(count(distinct Score)&gt;0,count(distinct Score)+1,1) from Scores where Score&gt;s.Score) as Rankfrom Scores sorder by s.Score desc 180 连续出现的数字123456789101112SELECT DISTINCT l1.Num AS ConsecutiveNumsFROM Logs l1, Logs l2, Logs l3WHERE l1.Id = l2.Id - 1 AND l2.Id = l3.Id - 1 AND l1.Num = l2.Num AND l2.Num = l3.Num; 183 从不订购的客户1234567select name as Customersfrom customers as ctwhere not exists( select * from orders where customerId = ct.id ) 牛客网1 查询最晚入职的员工1234select *from employeesorder by hire_date desclimit 1 offset 0","link":"/2019/11/25/leetcode数据库刷题/"},{"title":"网络编程之UDP","text":"UDP网络通信概述这次课的目的就是在学完了之后，能用python发信息 什么是网络我们小时候其实已经知道什么是网络了。 玩的对讲机，50块钱的红白机等等。 为什么要用对讲机说话？ 目的：不同电脑之间的通信 淘宝两块钱买网址 网络的区分同一个班级，局域网 互联网，外围网 总统手里面提着箱子，箱子里面是密码这里也是一个网络 软件核心：mac ox，windows，linux 硬件核心：cpu 网络的目的资源进行共享 IP地址在网络发送东西的时候，为什么只有这个同学接收到？ 因为有人来标记这个电脑，标记了这条信息 用来标记一台电脑的这个东西就叫IP地址 IP地址的作用用来标记一台电脑 ip地址是什么ip地址本质就是一坨数字 交换机 路由器 有关ip的操作在发送信息要写上目标ip，但是不用带上自己的ip，因为操作系统会自动帮你带上ip linux，windows查看网卡信息查询ip地址12linux -- ipconfigwindows -- ifconfig IP地址这么多个的原因有很多虚拟网卡，一个网卡对应着一个ip地址 把网卡关闭或者禁用 ip地址的分类–ipv4和ipv6ipv4123是实验的版本 所有的智能设备都有ip，所以随着智能设备的增多，ip肯定会爆 根据四组数划分为很多种类 ipv4的大小是 $2^32-1$ ipv4规律ipv4的组成里面分为网络号，主机号 其中分成四个小组，靠点分开 如果我们班是在一个局域网，在前面是一样的，即网络号是相同的 最大和最小的不能用，即只能用254种 最大的就是全部都为1的 最小就是全部都为0的，这个是你 前面三组分为ABC D类单拨，多拨，广播 一对一 一对多，变成一个小组 很多人听到，广播 E类保留 0-255 ipv6 5一般是c类地址 你怎么知道给飞秋而不是qq 端口 到了相同的ip的地方之后，进行对比，然后存下来 src源ip， 收到数据之后然后再回一个 通信的基本过程 6端口的分类 213端口——门 门牌号，端口号 我们只关心端口号的值 进程线程协程 运行了之后就叫进程 网络就是进程和进程的通信 端口号是怎么分配的 知名端口：大家都默认使用的某个端口 网络是21号端口 &lt;1024 0-1023 1024-65535 端口号 7socket介绍 用socket通信，套接字，插口 不用关心怎么做 打开读写关闭 创建套接字，其中那个s是一个类 返回值是一个对象，所以这个是一个类 不是一个函数 必须通过socket才能实现 买了一个娃娃怎么办 浏览器都给我卸载了，因为其他浏览器都很烂 socket的参数 udp还是tcp的通信 第一个是协议组，ipv4还是ipv6 tcp，udp 导入模块的问题 import socke的话，还要用socket.socket 但是from socket import * 导入socket里面的所有函数 就不用写socket.socket前面的socket 如果返回没有问题就称为套接字对象 第二天 写程序 写程序的方式再windows里面一般要打开图形化的东西 但是再linux里面的话，我们不见得一定要打开 比如说我们可以用 sublime ctrl+放大 if 什么什么name== 什么什么main是怎么用的 c sharp lua写外挂 ob 开房rys 支持拖文件夹 右击删除就可以删除文件夹了 ctrl+s 保存 运行代码 ls一下 cd desktop 开始写程序 1234567891011tab快速补全ls 查看当前文件夹的wejiancd 打开文件夹cd空就是返回桌面：q退出当前文本 加上！强制退出vim 编辑文本 另外的方式运行 python3 加一个 这里面出现了中文，用python2写的，所以要加上-#coding=utf-8#- 用vim写 再用python3写 vim命令 esc进入命令行模式 v选中当前行 shift+小于号全体左缩进 ctrl+n 有补全 deb文件安装 sudo dpkg -i deb文件名 开始发送数据 通过socket发送一个数据 QT编译 64位是什么意思 结构体构造函数 开始发送数据会出现得问题 双引号左边写上b就是字节类型 他不要字符串，只要字节类型 网络unreachable ping一下ping成功才行 解决方法，改成桥接模式 sudo dhclient 等待别人给你分配一个ip，保证桥接了，要保证在同一个局域网 ：x保存并退出 2有可能你的电脑有好几个ip 以vmware开头的，虚拟的网卡 把虚拟的网卡关了 同一个wifi在一个局域网？ tab，元组 写代码不熟练 加注释 3b意味着什么 打开python3进入交互模式 ipython3 ![1570628821725](C:\\Users\\legion\\AppData\\Roaming\\Typora\\typora-user-images\\1570628821725.png 交互模式更加高端 ipython可以自动补全 而且可以清空 复制文件到另一个py文件 1cp xxx.py ttt.py 从键盘输入数据 yyp 复制 apt命令 下载慢更换镜像下载源 命中是什么意思 b转换格式 send_data.encode(“utf-8”) 聊天室循环发送数据 prompt 内存太高会产生内存交换 CTRL+c退出 带有退出功能的循环py if不用加括号 4接受udp信息端口写多少？ 创建套接字的时候是没有端口的 要通过bind创建端口号， ip+端口 空的双引号和单引号 shift+空格 全角和半角切换 写注释 行首# 文字后面&amp;nsbp&amp;nsbp#&amp;nsbpcontent 总结 bind要绑定自己的 打印东西要注意发送方的编码格式 触发器是什么 代码环节__name规范到底怎么写 if__ 中间要用空格 print的使用要学会 5绑定端口的问题 每次重新发送一次数据，又会有一个新的端口号，而且是发送一次，端口就是一个 发送的时候没有绑定端口系统会自动帮你绑定 同一端口不许同一时间使用两次 6网络中重要概念复习 udp很简单 数据共享 有ip地址来区分 私有ip，不能上互联网. 上互联网的就是自己的公有ip 端口 知名端口公用端口 0-1023 1024-8080 飞鸽传书的端口都是2425 python不用重复造轮子 7 udp聊天器 不用管那个网线拉了没 一个套接字可不可以同时收同时发 没学多任务 12345678mv 名字 名字 A到行末进行编辑小写字母i跳到行首mv 名字 名字 A到行末进行编辑小写字母i跳到行首ctrl+n补全ctrl+T加另外的标签-i install ftp ssh xshell 网络通信也能同一台电脑通信 lo代表的是环回的地址 recvfrom在没有接受到数据的时候是什么情况？ 阻塞 把他想象为电话 套接字可以同时收发数据 单工：百分之百只能指向一个位置，只能听 半双工：对讲机，收的时候发不了，发的时候收不了 都在用同一个频道，要抢到那个频道 全双工：同一时刻既可以收也可以发，socket是全双工 8 udp聊天器案例先去模仿，72变也是学过来的。学习核心 main函数是主要的函数 写代码要慢慢推 正着推，推不动然后反着想 函数和函数空两个行 剪切是d，复制是p 百分号前面要有空格 python红灯停绿灯行 “”“函数的解释说明”“” 点一次来一次，没有调用recvfrom 他有东西存起来了我们的信息cache 接受快递的存放处 这个是漏洞 把端口扫描一遍，看看有哪个是开的 然后不停的发送数据 要while true的收，即收的时候才开端口 不要端口一直开着随时去收 一定开了2425+++ 蓝牙也算ip？","link":"/2019/10/23/udp/"},{"title":"vscode 配置 C / C++ 环境","text":"Visual Studio Code (vscode) 配置 C / C++ 环境 昨天突发奇想，想使用vscode配置C++环境，因为不想下载 Dev OR codeblock，然后借助了很多网上教程，用了昨天整整一下午的时间最后终于成功了(哈哈哈哈哈……)。今天跟大家分享一下~ 因为还只是个编程小白，参考资料有点多 ↓ ↓ ↓ 官方文档 —— 参考配置过程 CSDN原创文章 —— 参考主要配置过程 知乎达人 —— 参考环境准备 ➺➻➸ 主要流程： \\1. 下载VScode \\2. 安装cpptools工具 \\3. 下载MinGW \\4. 配置环境变量 \\5. 使用简单的.cpp文件配置C++环境 \\6. 运行 ➺➻➸ 详细解读： 1. 下载VScode 下载链接：https://code.visualstudio.com/Download 安装过程：一路下一步，安装很简单，安装路径看个人 2. 安装cpptools工具 打开vscode，按照以下步骤安装 3. 下载MinGW 下载地址：https://sourceforge.net/projects/mingw-w64/files/ 下载的文件：进入网站后不要点击 “Download Lasted Version”，往下滑，找到最新版的 “x86_64-posix-seh”。 安装MinGW：下载后是一个7z的压缩包，解压后移动到你想安装的位置即可。我的安装位置是：D:\\2Software\\mingw64 4. 配置环境变量 配置对象：WinGW，所以把你刚刚安装WinGW的路径拷贝一下 配置环境变量：在此以win10为例，到达第6步之后，前面打开的窗口都要按下确定，否则会失败。 【注】：win7需要添加路径，不要覆盖了。万一真的覆盖了，点击取消重来一遍，只要不点确定，啥都好说 ^o^ 配置好环境变量后最好重启一下 VScode ^V^ ❁❁❁ 验证一下环境变量是否配置成功 按下 win + R，输入cmd，回车键之后输入g++，再回车，如果提示以下信息[1]，则环境变量配置成功。如果提示以下信息[2]，则环境变量配置失败。 [1]：g++: fatal error: no input files [2]：’g++’ 不是内部或外部命令，也不是可运行的程序或批处理文件。 5. 使用简单的.cpp文件配置C++环境 新建空文件夹Code 打开VScode –&gt; 打开文件夹 –&gt; 选择刚刚创建的文件夹Code 新建test.cpp文件(以最简单的 HelloWorld.cpp 为例) 12345678#include &lt;stdio.h&gt;#include &lt;windows.h&gt;int main(){ printf(\"Hello World\\n\"); system(\"pause\"); return 0;} 进入调试界面添加配置环境，选择 C++(GDB/LLDB)，再选择 g++.exe，之后会自动生成 launch.json 配置文件 编辑 launch.json 配置文件 按 Ctrl+C 复制代码 按 Ctrl+C 复制代码 返回.cpp文件，按F5进行调试，会弹出找不到任务”task g++”，选择 “配置任务”，会自动生成 tasks.json 文件 编辑 tasks.json 文件 按 Ctrl+C 复制代码 按 Ctrl+C 复制代码 【注】： launch.json 文件中 “preLaunchTask” 的值 必须与 tasks.json 文件中 “label”的值一致。值的设置看个人喜好，保持默认也是OK的。 6. 运行 返回 HelloWorld.cpp 文件，按F5调试，发现完全OK了！","link":"/2019/10/23/vscode-配置-C--C++-环境/"},{"title":"网络编程之TCP","text":"TCPtcp介绍（传输控制协议）udp写信： 放进去就回发送走 收信人的地址 写信不安全 别人也会收到 飞秋可能收不到 tcp： 打电话 tcp有补救措施 保证数据一定会到 电流导致数据乱了 打电话要拨号，嘟嘟嘟的过程 必须先建立链接 tcp有应答机制 一段时间内没有应答，超时重传 迅雷下载的上传速度就是应答 错误校验 流量控制，阻塞管理 不能传太多 UDP 飞鸽传书 保证稳定 udp流程建立套接字 sento recvfrom bind端口 TCP流程严格区分客户端和服务器 选区：选择服务器，越近越不卡 提供服务的就是服务器 客户端：ipad点菜机 多了链接服务器 铁了心要用括号就要转义 大写的o前面插入，小写的o插入到下面 自己写的名字和import一样 tcp说多少句都是一个连接 客户端和服务器 udp 用户数据报协议 TCP 服务器客户端一般不绑定端口 listen被动套接字 accept等待客户端链接 流程： 买个手机–套接字 插上手机卡–套接字绑定 接听状态–listen（设置为正常接听状态）–买手机卡默认你打电话给别人 等待别人打电话–accept 括号就是反斜杠 大O前面插一行 小o前面插一行 大A行末 大I行首 bind一定是绑定元组 listen写128就可以了 拆包等号右边是一个元组，等号左边有两个变量，这个叫做拆包 accept接受新的套接字(客服)，addr是别人给你打电话的信息(打电话给你的电话号码之类的) bind 电话机申请了7890 人-&gt;联通打电话 人工—找个人给他服务，accept，打电话，客服(由电话主机给他传了客户的信息)给他服务 服务器: 先买了电话机 先变成listen–等待别人给你打电话 找了个新的套接字为他服务 – 又来了一个人 又找个客服 监听套接字只等待 下面负责通信 – 一直阻塞，直到有客户来(accept)来的时候才解阻塞 客户端先发 linux命令行创建新窗口 总结命令行‘ 客户端先运行还是服务器先运行 accept卡在这里不走了 卡着不走等客户端 accept等一个客户端调用connect 循环为多个客户端服务 先拿号 把标记的客户端关了 recvfrom有数据还有，ip之类的 面积你 recv只有数据 你怎么知道客户端只需要服务一次，就是循环为这个客户多次服务 你怎么知道别人不需要服务 recv解堵塞，有两种方式 ，一种是 客户端发送数据 客户端调用close 9.55打电话，亮名牌，挂了我就投诉你 同一时刻为多个服务 文件下载器 什么叫下载 服务器down一个东西 收到一点我就写一点 客户端比较简单 服务器比较麻烦 要下载东西，需要有什么前提 1.有网络—创建套接字 2.connect 3.下载文件名 4.读出来那个文件再发给我 最简单的下载流程 1.限速，验证，超级管理员，vip会员 with怎么用 打开成功，读写异常 try: ​ xxx except: ​ xxx with open(“xxx”) as f 里面不需要写close 保证百分之百被close关了 先发请求，给文件名 收 新建一个文件 把东西放到文件里面去 流程： 1024==1字节 1024*1024=1mb 写上个b是二进制 recv是二进制 2-to-too d剪切 p粘贴放进去 开多一个函数有独立功能 with 打得开，读数据不一定用 新建一个文件不可能失败 try的用法 如果下载的东西没有的话怎么办 vim xxx+09 上课都不认真听，下课就会认真了？ listen里面的参数（四个小时连续上）tcp稳定 udp不稳定 同一时刻有多少客户端连接你有关系（一丁点关系） 128 Ubuntu特别适合做服务器 高并发好几百万个人 tcp注意点 tcp服务器一般情况下需要绑定，否则客户端找不到这个服务器。 网络安全可能会有其他不是tcp或者udp 参数不管它，以后查一查就好了 收数据要绑定端口，发数据不绑定也行，给我打电话来电显示就行了 qq多开，udp，硬件限制所以是udp 一起为大家服务，两台电脑服务。慢慢的都给另一台电脑 在一个网络里面，知道ip和端口 在互联网里面可以不用绑定。 第一步，先登录。我知道腾讯服务器的端口。连接腾讯的服务器 第二步，qq2登陆，腾讯服务器起到了一个转发的服务 多开qq，有不同的端口 注意点 listen，可以把主动变为被动 udp不需要connect连接。tcp是面向连接的通信，电话的模型，udp是写信的模型 accept返回到是一个套接字和地址 服务器没有接到请求的时候会卡在accept那个时候 listen关闭了之后，不能接受新的客户端 关闭了accept的新套接字意味着客户端已经服务完毕 服务器会解阻塞 收到了消息 对方挂了电话，判断长度是否为0 tcp三次握手，四次挥手只是为了知识点完整 会在网络通信过程那里讲","link":"/2019/10/23/tcp/"},{"title":"二分、三分和模拟退火","text":"整数二分二分实现的基本思想就是拿需要查找的数与中间的数比较 比中间的数字小则改变右区间，比中间的数字大则改变左区间 而具体来说，就是用三个指针，指着三个位置 时间复杂度是$O(logn)$ 所以我们有两个事情需要注意: 因为要让改变区间之后，确保去掉的那半边的数字没有影响，所以整个二分搜索的范围必须是单调的 如果和中间的数字不一样，应该改变数字为中间数字的加一或者减一 实现代码如下: 非递归形式 123456789101112131415int BiSearch(int a[], int n, int x){ int left = 0， right = n - 1; while (left &lt;= right) // 注意=不能少 { int middle = (left + right) / 2; //整数除法 if (a[middle] == x) //找到的情况 return middle; if (x &gt; a[middle]) //如果比中值大 left = middle + 1; else //如果比中值小 right = middle - 1; } return -1;} 递归形式: 123456789101112131415int BiSearch(int a[], int x, int left, int right){ if (left &gt; right) //注意不能有=号 return -1; else { int mid = (left + right) / 2; if (a[mid] == x) return mid; else if (x &gt; a[mid]) return BiSearch(a, x, mid + 1, right); else if (x &lt; a[mid]) return BiSearch(a, x, left, mid - 1); }} ACwing 789数的范围123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 100010;int num[maxn];int main(){ int n, q; cin &gt;&gt; n &gt;&gt; q; for (int i = 0; i &lt; n; i++) { scanf(\"%d\", &amp;num[i]); } while (q--) { int k; scanf(\"%d\", &amp;k); int l = 0; int r = n - 1; while (l &lt; r) { int mid = l + r &gt;&gt; 1; if (num[mid] &gt;= k) r = mid; else l = mid + 1; } if (num[r] == k) printf(\"%d \", l); else printf(\"-1 \"); l = r; r = n - 1; while (l &lt; r) { int mid = (l + r + 1) &gt;&gt; 1; if (num[mid] &lt;= k) l = mid; else r = mid - 1; } if (num[r] == k) printf(\"%d\\n\", r); else printf(\"-1\\n\"); } return 0;} 实数二分因为实数的取值是连续的，所以二分在改变区间的时候，不需要加一减一，同时退出条件的是两者相等的时候 ACwing 790 三次方根12345678910111213141516171819202122#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int main(){ double n; double l = -100; double r = 100; cin &gt;&gt; n; while (r - l &gt; 1e-8) { double mid = (l + r) / 2; if (mid * mid * mid &gt;= n) r = mid; else l = mid; } printf(\"%.6f\", l);} hdoj 2199实现代码如下(自写错误代码): 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;cmath&gt;using namespace std;double res(double x){ return 8 * pow(x, 4.0) + 7 * pow(x, 3.0) + 2 * pow(x, 2.0) + 3 * x + 6; // pow里面不用.0有没有影响 // 整数的隐式转换到底怎么样}int main(void){ int T, Y; scanf(\"%d\", &amp;T); while (T--) { double left = 0.0; double right = 100.0; double mid = (left + right) / 2; scanf(\"%d\", &amp;Y); if (res(right) &lt; Y || res(left) &gt; Y) //可以换一种判断方式，先判断是否能用，能用的话就进来，不能用就出去，不过往往需要根据情况而定 { cout &lt;&lt; \"No solution\" &lt;&lt; endl; continue; } while (abs(res(mid) - Y) &gt; 1e6) // 判断能否进行二分查找的条件是左边和右边的关系，而不是与中间是否相等 { if (res(right) &gt; Y) { right = mid; // mid减一 mid = (left + right) / 2; continue; } if (res(left) &lt; Y) { left = mid; mid = (left + right) / 2; continue; } } return 0; }正确的代码(尽量不用递归的形式): 123456789101112131415161718192021222324252627282930313233#include &lt;bits/stdc++.h&gt;using namespace std;double Y, l, r, m;double f(double x){ return 8 * pow(x, 4.0) + 7 * pow(x, 3.0) + 2 * pow(x, 2.0) + 3 * x + 6;}int main(){ int t; scanf(\"%d\", &amp;t); while (t--) { scanf(\"%lf\", &amp;Y); if (f(0) &lt;= Y &amp;&amp; Y &lt;= f(100)) { l = 0; r = 100; while (r - l &gt; 1e-6) { m = (l + r) / 2; double ans = f(m); if (ans &gt; Y) r = m - 1e-7; else l = m + 1e-7; } printf(\"%.4f\\n\", (l + r) / 2); } else printf(\"No solution!\\n\"); }} hdoj 2899错误代码: 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;bits/stdc++.h&gt;using namespace std;double T, Y, l, r, m;double func(double x){ return 42 * pow(x, 6.0) + 48 * pow(x, 6.0) + 21 * pow(x, 3.0) + 10 * x;}int main(){ cin &gt;&gt; T; while (T--) { cin &gt;&gt; Y; if (func(0) &lt;= Y &amp;&amp; func(100) &gt;= Y) { l = 0; r = 100; mid = (l + r) / 2.0; while (l &lt;= r) { if (func(mid) == Y) { return mid; } else if (func(mid) &lt; Y) { left = mid + 1; // 不递归的话应该怎么写 } else { right = mid - 1; } } } else // 不需要输出无解的时候应该怎么写代码 { /* code */ } }} 二分法1234567891011121314151617181920212223242526272829303132333435#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;double y;double solve(double xx){ return 42 * pow(xx, 6) + 48 * pow(xx, 5) + 21 * pow(xx, 2) + 10 * xx;}int main(){ int t; scanf(\"%d\", &amp;t); while (t--) { scanf(\"%lf\", &amp;y); double ans = -1, op, l = 0, r = 100, m; while (r - l &gt;= 0.00000001) { m = (r + l) / 2; op = solve(m); if (op &gt;= y) { ans = m; r = m; } else l = m; } ans = (6 * pow(ans, 7) + 8 * pow(ans, 6) + 7 * pow(ans, 3) + 5 * ans * ans - y * ans); printf(\"%.4lf\\n\", ans); } return 0;} 有几点需要注意： 等于号还是要的，因为这个Y现在给的是整数，还不会出现等于的情况，但是如果给的是一个很多位小数的数值，但是你只能比较他的前六位，所以还是要不断的缩小范围 模拟退火算法模拟退火算法的话其实就是根据物理原理来的。温度越高降温的概率越大 那么我们在编程的时候，也是这样。 如果单纯的用贪心，那么在达到一次最高峰的时候，就不会往前走了。但是有些函数，他的最高峰在第一个最高峰的后面。所以我们要写一个新的算法 这个新的算法大致是这样: 有比现在更好的，接受更好的 比现在更差的，一定概率内接受它，但是概率随着时间的推移慢慢降低 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;bits/stdc++.h&gt;using namespace std;const double eps = 1e-8; // 终止温度double y;double func(double x) // 计算函数值{ return 6 * pow(x, 7.0) + 8 * pow(x, 6.0) + 7 * pow(x, 3.0) + 5 * pow(x, 2.0) - y * x;}double solve(){ double T = 100; // 初始温度，外界温度 double delta = 0.98; // 降温系数 double x = 50.0; // x的初始值，内部温度 double now = func(x); // 计算初始值函数 double ans = now; // 返回值 while (T &gt; eps) // eps是终止温度 { int f[2] = {1, -1}; double newx = x + f[rand() % 2] * T; // 按概率改变x，随温度的降温而改变概率 if (newx &gt;= 0 &amp;&amp; newx &lt;= 100) { double next = func(newx); ans = min(ans, next); if (now - next &gt; eps) { x = newx; now = next; } } T *= delta; } return ans;}int main(){ int cas; cin &gt;&gt; cas; while (cas--) { cin &gt;&gt; y; printf(\"%.4f\\n\", solve()); } return 0;} hdoj 1969 pie这一题题意： 不能直接均摊，因为小于x的不能用 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;iostream&gt;#include &lt;math.h&gt;#include &lt;cstdio&gt;using namespace std;double m = 0, y;double pi[10005], temp[10005];const double P = acos(-1.0); //求π直接用pi=3.1415926会WAconst double EPS = 1e-7;int N, F;double MAX(double a, double b){ return a &gt; b ? a : b;}int f(double x) //判断是否可以按x分{ int i, num = F + 1; for (i = 0; i &lt; N; i++) temp[i] = pi[i]; i = 0; while (num &gt; 0) { if (temp[i] &gt;= x) { //这一块还可以分 temp[i] -= x; num--; } else { i++; //这一块分不了了，下一块 } if (i &gt;= N) //x过大 return 0; } return 1;}double bs(){ double lo = 0, hi = m; double mi; int k = 100; while (hi - lo &gt; EPS) { mi = (lo + hi) / 2.0; //浮点数问题就别移位运算了 if (f(mi) == 0) //如果x过大，尝试下小的 hi = mi; else //如果可按照x分，尝试下更大的 lo = mi; //cout&lt;&lt;mi&lt;&lt;endl; } return mi;}int main(){ int repeat; cin &gt;&gt; repeat; while (repeat--) { cin &gt;&gt; N &gt;&gt; F; for (int i = 0; i &lt; N; i++) { cin &gt;&gt; pi[i]; pi[i] = pi[i] * pi[i] * P; m = MAX(pi[i], m); //cout&lt;&lt;pi[i]; } printf(\"%.4lf\\n\", bs()); m = 0; } return 0;} 题中没有说最小为多少，则从0开始，最大可以从饼中的最大或者是饼之和的平均值来选，二分法求，根据饼的切割块数判断区间的移动，bug.1:精度没有控制好，变成了死循环；bug.2:预设了一个存放最大饼的体积的变量，每次用完之后没有清零，卒。。bug….n：包括将cin改成scanf，改变区间移动的判断方式，，都没什么卵用，，最后将pi=3.1415926改成了pi=acos(-1.0)，， 两个都是0的话，while(…,x+y) hdoj 2141123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;iostream&gt;#include &lt;math.h&gt;#include &lt;cstdio&gt;using namespace std;const int Maxn = 501;int a[Maxn], b[Maxn], c[Maxn], x[Maxn];int main(){ int L, M, N; int S; while (~scanf(\"%d %d %d\", &amp;L, &amp;N, &amp;M) &amp;&amp; L + M + N) { memset(a, 0, sizeof(a)); memset(b, 0, sizeof(b)); memset(c, 0, sizeof(c)); memset(x, 0, sizeof(x)); for (int i = 0; i &lt; L; i++) { cin &gt;&gt; a[i]; } for (int i = 0; i &lt; N; i++) { cin &gt;&gt; b[i]; } for (int i = 0; i &lt; M; i++) { cin &gt;&gt; c[i]; } cin &gt;&gt; S; for (int i = 0; i &lt; S; i++) { cin &gt;&gt; x[i]; } for (int z = 0; z &lt; S; z++) { for (int i = 0; i &lt; L; i++) { for (int j = 0; j &lt; N; j++) { for (int k = 0; k &lt; M; k++) { if (a[i] + b[j] + c[k] == x[z]) { cout &lt;&lt; \"yes\"; //怎么直接跳到外面第一层循环 } } } } } } return 0;} 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;stdio.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;math.h&gt;#define xps 1e-12using namespace std;int main(){ long long l, m, n, o = 1; while (cin &gt;&gt; l &gt;&gt; m &gt;&gt; n) { long long a[510], b[510], c[510], d[250010]; for (int i = 0; i &lt; l; i++) //输入三个数组 cin &gt;&gt; a[i]; for (int i = 0; i &lt; m; i++) cin &gt;&gt; b[i]; for (int i = 0; i &lt; n; i++) cin &gt;&gt; c[i]; int k = 0; for (int i = 0; i &lt; l; i++) for (int j = 0; j &lt; m; j++) d[k++] = a[i] + b[j]; //前两个数组两两相加得到新数组 sort(d, d + k); //从小到大排序，不是k+1的原因是因为我们上面写的是k++，从0开始计数 int s; cin &gt;&gt; s; cout &lt;&lt; \"Case \" &lt;&lt; o++ &lt;&lt; \":\" &lt;&lt; endl; //输出第几个测试实例 这里不用再case后面再加一个空格 while (s--) // 这样读取比先for循环读取，然后再一个一个比较好 { long long x; cin &gt;&gt; x; bool sign = false; for (int i = 0; i &lt; n; i++) //第三个数组和新数组mid相加判断 { int l = 0, r = k - 1; // 减一是因为其实我们只能取到k-1那个位置，还是k++数组那里，k++，意味着我们去到的数字是，0-n-1 while (l &lt;= r) // l&lt;=r { int mid = (l + r) &gt;&gt; 1; //位运算直接除二，如果是浮点数不能直接位运算 if (d[mid] + c[i] == x) { sign = true; break; } else if (d[mid] + c[i] &lt; x) { l = mid + 1; } else r = mid - 1; } if (sign) break; } if (sign) cout &lt;&lt; \"YES\" &lt;&lt; endl; else cout &lt;&lt; \"NO\" &lt;&lt; endl; } } return 0;} 三分查找三分查找主要是要满足一个条件 满足凸性–抛物线 https://www.cnblogs.com/fanzhidongyzby/archive/2012/07/28/2613173.html https://blog.csdn.net/sodacoco/article/details/79608672","link":"/2019/11/11/二分搜索/"},{"title":"","text":"一段在一个集合，另一个在另一个集合 不会出现一条边出现两个男的，这不是我们研究的范围 二分图 男2号也看重了女1号，难道他就单身么? 商量一下，要不换一个？ 左往右匹配，右往左毁约 最多匹配几对 最小顶点覆盖 最少的点，覆盖所有的边 开除最少的学生，解决问题 其实就是求最大匹配数，再帅也只能找一个 儿子6年级，全班最瘦 怎么建图 DAG图，有向无环图拓扑图就是有向无环图 顶点覆盖边 路径覆盖点 用到了拆点 节点数减去最大匹配数 开除之后都没缘分的 顶点数减去最大匹配数 没有说哪些是男哪些是女，边数要乘二 linker函数 这个dfs要做很多趟搜索，要记住当前的used 有对象也可以，看看这个男生能不能找到一个没有结婚的女生 所有语句都没有return意味着不能增加，这个男生增加不了了 完全按照hall定理来写的 4次课测验一次，有弊端 下一周模拟期末考试， 不考：几何，母函数，博弈sg函数，Catalan数，特殊的数也不考","link":"/2019/12/11/二分匹配/"},{"title":"数据结构---图","text":"图的基本分类 无向图（一般指的是连通图） 无向完全图 有向图 有向完全图 连通图 定义 只有边，没有方向 同左，且任意两个点都有直接的边 有边有方向 同左，任意两个点都有边 不一定有直接的边相连，但是每个点都能去到另一个点 顶点 n n n n 最多 n(n+1)/2，最多的情况就是完全图 最少 退化成一棵树，无环，n-1 n，再加一条边到开头 连通分量max n，每一个点都是连通分量 连通分量min 1，整个图是一个连通图。 判断一个图是否有环 深度优先搜索：从节点V出发，当检验到有一条边可以去到V的话，说明有环 拓扑排序：有些顶点删不掉，因为如果有环的话，我能去到你那里，你也能来我这里。永远删不掉这两个入度不可能为0的点 拓扑排序BFS每次把入度为0的点放进来，然后把与它相邻的节点的入度减一，循环做这件事情 DFS前提：无环 如果一个图没有环的话，走到底，然后得到的是逆拓扑排序 用深度优先 是否能形成拓扑排序 无环 判断无环 可以通过邻接矩阵：只有大的到小的节点有边，小的到大的没边，这也意味着，只能单向指","link":"/2019/11/21/图论/"},{"title":"","text":"开工情况不同，滞留，返回情况 应急方案 准备物资 防控工作 排班 生产运营小组 负责人 疫情防控：梁杰胜 订单对接和排产：苗苗 生产效率保证：喜庆 有分配组员（梁杰胜已挑组员） 明确工作方向","link":"/2020/02/05/复工方案/"},{"title":"","text":"Fibonacci数列错排问题求这里有n封信，这n封信完全不和它的序号相同的种类 首先我们考虑一个事情，假设，我们要放第n封信，而且前面n-1封已经是错排好的了 此时把这第n封信与前面的n-1封信任意交换一下。就类似于把第n封信放在某个位置k,然后位置k的信又拿出来放到手上 此时手上有位置k的信，那么如果要达到错排的目的，k有两种方法 放在位置n的地方，放在这个地方之后只需要求n-2个位置的信（n-2是因为我已经放好了两封） 不放在位置n，此时要讨论n-1封信的位置（是因为我只放好了第n封） 所以总的来说就是$$f[n]=(n-1)*(f[n-1]+f[n-2])$$ 数塔问题（递归+记忆化搜索）正常dp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;using namespace std;int a[150][150] = {0};int dp[150][150] = {0};void solve(int n){ for (int j = 1; j &lt;= n; j++) { dp[n][j] = a[n][j]; } for (int i = n - 1; i &gt;= 1; i--) { for (int j = 1; j &lt;= i; j++) { dp[i][j] = a[i][j] + max(dp[i + 1][j], dp[i + 1][j + 1]); } }}int main(){ int c; cin &gt;&gt; c; while (c--) { int n; int temp; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= i; j++) { cin &gt;&gt; a[i][j]; } } solve(n); cout &lt;&lt; dp[1][1] &lt;&lt; endl; memset(dp, 0, sizeof(dp)); memset(a, 0, sizeof(a)); } return 0;} 数塔问题的关键就是，从下往上搜，就有点像锦标赛比赛一样。选出冠军 递归+记忆化搜索123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;using namespace std;int a[150][150]; int dp[150][150]; //在这里初始化没有用int n;int dfs(int i, int j){ if (i == n) return a[i][j]; if (dp[i][j] &gt;= 0) return dp[i][j]; return dp[i][j] = max(dfs(i + 1, j), dfs(i + 1, j + 1)) + a[i][j];}int main(){ int c; cin &gt;&gt; c; while (c--) { int temp; memset(dp, -1, sizeof(dp)); memset(a, -1, sizeof(a)); cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= i; j++) { cin &gt;&gt; a[i][j]; } } //dfs(1,1); //这个地方返回的是一个值，所以可以直接输出这个东西 // 有返回值的语句必须要拿东西承载着它 cout &lt;&lt; dfs(1, 1) &lt;&lt; endl; } return 0;} 我们一直往下递归，如果某个点我们已经知道它的最大值的话，我就不走了。 二维数组赋值为0的方式为 1int a[2][2] = {{0},{0}} //一定要注意这种方式 hdoj 1176 免费馅饼1234567891011121314151617181920212223242526272829303132#include &lt;stdio.h&gt;#include &lt;string.h&gt;#define max(a,b,c) a&gt;(b&gt;c?b:c)?a:(b&gt;c?b:c)int pie[100100][20];int main(){ int n; int x,t; while(scanf(\"%d\",&amp;n)&amp;&amp;n!=0) { memset(pie,0,sizeof(pie));//把每个点都设为零刚开始没有馅饼 int maxtime=0; for(int i=1;i&lt;=n;i++) { scanf(\"%d %d\",&amp;x,&amp;t); pie[t][x+1]+=1;//这个位置加一会为后来计算提供很大方便 maxtime=maxtime&gt;t?maxtime:t;//找出最大的时间为后来的行数提供数据 } for(int i=maxtime;i&gt;=1;i--) { for(int j=1;j&lt;=11;j++) { pie[i-1][j]+=max(pie[i][j-1],pie[i][j],pie[i][j+1]);//每个点设为一个状态找出他下面三个点的最大值相加最后到1s这行就得出答案了 } } int ans=max(pie[1][6],pie[1][5],pie[1][7]); printf(\"%d\\n\",ans); } return 0;} 看成数塔问题，时间表示层数，然后要注意一下从1可能会走到0。 最长递增子序列 LIS前i件物品，组成k对的最优结果 hdoj 1257 最少拦截系统123456789101112131415161718192021222324252627282930313233343536#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;using namespace std;const int MAXN = 10000;int n, high[MAXN];int LIS(){ int ans = 1; int dp[MAXN]; dp[1] = 1; for (int i = 2; i &lt;= n; i++) { int max = 0; for (int j = 1; j &lt; i; j++) if (dp[j] &gt; max &amp;&amp; high[j] &lt; high[i]) max = dp[j]; dp[i] = max + 1; if (dp[i] &gt; ans) ans = dp[i]; } return ans;}int main(){ while (cin &gt;&gt; n) { for (int i = 1; i &lt;= n; i++) cin &gt;&gt; high[i]; cout &lt;&lt; LIS() &lt;&lt; endl; } return 0;} $$dp[i] = max(0,dp[j])+1$$ 如果这个数比当前位置大，那么加一，没有则不变。 主要是循环的地方要变 dp[i] 表示以第i个数为结尾的最长递增子序列的长度 1234567891011121314151617181920212223242526272829#include&lt;iostream&gt;using namespace std;int main(){ int n; while(cin&gt;&gt;n) { int height[n]={0}; int solve[n]={0}; int num=0; for(int i=0;i&lt;n;i++) cin&gt;&gt;height[i]; for(int i=0;i&lt;n;i++) { int flag=0; for(int j=0;j&lt;num;j++) { if(solve[j]&gt;=height[i]) //遍历当前所有系统可拦截最高位置 { flag=1; solve[j]=height[i]; //如果有系统可拦截 将该系统拦截位置降到该导弹位置 break; } } if(flag==0) solve[num++]=height[i]; //无系统可拦截 则新建一个最高拦截高度为该导弹位置的系统 } cout&lt;&lt;num&lt;&lt;endl; }} 最长升序字段和hdoj 10871234567891011121314151617181920212223242526272829303132333435#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 1005;int dp[maxn];int num[maxn];int main(){ int n; while (~scanf(\"%d\", &amp;n) &amp;&amp; n) { for (int i = 0; i &lt; n; i++) { scanf(\"%d\", &amp;num[i]); dp[i] = num[i]; } for (int i = 1; i &lt; n; i++) { for (int j = 0; j &lt;= i - 1; j++) { if (num[j] &lt; num[i]) dp[i] = max(dp[i], dp[j] + num[i]); } } int res = 0; for (int i = 0; i &lt; n; i++) { res = max(res, dp[i]); } cout &lt;&lt; res &lt;&lt; endl; }} dp[i] 表示以这个点为终点的时候的最大值 hdoj 1069 Monkey and Banana12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 205;int dp[maxn];struct Item{ int x; int y; int z; bool operator&lt;(Item &amp;S) const { if (S.x == x) return S.y &lt; y; return S.x &lt; x; }} item[maxn];// bool cmp(Item A,Item B)// {// if (A.x == B.x)// return A.y &lt; B.y;// return A.x &lt; B.x;// }int main(){ int n; int count=1; while (~scanf(\"%d\", &amp;n) &amp;&amp; n) { memset(dp, 0, sizeof(dp)); int cnt = 0; for (int i = 0; i &lt; n; i++) { int a, b, c; scanf(\"%d %d %d\", &amp;a, &amp;b, &amp;c); item[cnt++] = {a, b, c}; item[cnt++] = {a, c, b}; item[cnt++] = {b, a, c}; item[cnt++] = {b, c, a}; item[cnt++] = {c, a, b}; item[cnt++] = {c, b, a}; } //sort(item,item+cnt,cmp); dp[0] = item[0].z; for (int i = 1; i &lt; cnt; i++) { int max_height = 0; for (int j = 0; j &lt; i; j++) { if (item[j].x &lt; item[i].x &amp;&amp; item[j].y &lt; item[i].y) max_height = max(max_height, dp[j]); } dp[i] = item[i].z + max_height; } int ans = 0; for (int i = 0; i &lt; cnt; i++) { ans = max(ans, dp[i]); } printf(\"Case %d: maximum height = %d\\n\",count++,ans); } return 0 ;} 重载为什么不行，然后还要再去模拟一下LIS的问题 每次求的是每一个小子段的最大值与当前最后一位组合起来。 最大子序列和hdoj 1003 max sum动态规划的方法： 我们考虑最后一个元素arr[n-1]与最大子数组的关系，有如下三种情况： arr[n-1]单独构成最大子数组 最大子数组以arr[n-1]结尾 最大子数组跟arr[n-1]没关系，最大子数组在arr[0-n-2]范围内，转为考虑元素arr[n-2] 从上面我们可以看出，问题分解成了三个子问题，最大子数组就是这三个子问题的最大值，现假设： 以arr[n-1]为结尾的最大子数组和为End[n-1]在[0-n-1]范围内的最大子数组和为All[n-1]如果最大子数组跟最后一个元素无关，即最大和为All[n-2]（存在范围为[0-n-2]），则解All[n-1]为三种情况的最大值，即All[n-1] = max{ arr[n-1]，End[n-1]，All[n-2] }。从后向前考虑，初始化的情况分别为arr[0]，以arr[0]结尾，即End[0] = arr[0]，最大和范围在[0,0]之内，即All[0]=arr[0]。根据上面分析，给出状态方程：$$All[i] = max( arr[i]，End[i-1]+arr[i]，All[i-1] )$$ 1234567891011121314151617/* DP base version*/#define max(a,b) ( a &gt; b ? a : b)int Maxsum_dp(int * arr, int size){ int End[30] = {-INF}; int All[30] = {-INF}; End[0] = All[0] = arr[0];for(int i = 1; i &lt; size; ++i){ End[i] = max(End[i-1]+arr[i],arr[i]); All[i] = max(End[i],All[i-1]);}return All[size-1];} 仔细看上面DP方案的代码，End[i] = max{arr[i]，End[i-1]+arr[i]}，如果End[i-1]&lt;0，那么End[i]=arr[i]，什么意思？End[i]表示以i元素为结尾的子数组和，如果某一位置使得它小于0了，那么就自当前的arr[i]从新开始，且End[i]最初是从arr[0]开始累加的，所以这可以启示我们：我们只需从头遍历数组元素，并累加求和，如果和小于0了就自当前元素从新开始，否则就一直累加，取其中的最大值便求得解。这个是理论基础，我们有更加直观的做法： 123456789101112131415161718192021222324/* 最大子数组 返回起始位置 */void Maxsum_location(int * arr, int size, int &amp; start, int &amp; end){ int maxSum = -INF; int sum = 0; int curstart = start = 0; /* curstart记录每次当前起始位置 */ for(int i = 0; i &lt; size; ++i) { if(sum &lt; 0) { sum = arr[i]; curstart = i; /* 记录当前的起始位置 */ }else { sum += arr[i]; } if(sum &gt; maxSum) { maxSum = sum; start = curstart; /* 记录并更新最大子数组起始位置 */ end = i; } }} 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;using namespace std;int main(){ int t; cin &gt;&gt; t; for (int i = 0; i &lt; t; i++) { int n; cin &gt;&gt; n; int sum = 0, max = -99999; int curhead = 1, rear = 1, head = 1; for (int j = 0; j &lt; n; j++) { int temp; cin &gt;&gt; temp; if (sum &lt; 0) { curhead = j + 1; sum = temp; } else { sum += temp; } if (sum &gt; max) // 大于的时候才刷新真正的头位置 { rear = j + 1; head = curhead; max = sum; } } cout &lt;&lt; \"Case \" &lt;&lt; i + 1 &lt;&lt; \":\" &lt;&lt; endl; cout &lt;&lt; max &lt;&lt; ' ' &lt;&lt; head &lt;&lt; ' ' &lt;&lt; rear &lt;&lt; endl; if (i != t - 1) cout &lt;&lt; endl; }} 如果是while的话，那就是先判断，再减减 最长公共子序列 LCShdoj 115912345678910111213141516171819202122232425262728293031#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;using namespace std;const int maxn = 1005;int dp[1005][1005];string str1, str2;int LCS(){ memset(dp, 0, sizeof(dp)); for (int i = 1; i &lt;= str1.length(); i++) for (int j = 1; j &lt;= str2.length(); j++) { if (str1[i - 1] == str2[j - 1]) dp[i][j] = dp[i - 1][j - 1] + 1; else dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]); } return dp[str1.length()][str2.length()];}int main(){ while (cin &gt;&gt; str1 &gt;&gt; str2) { cout &lt;&lt; LCS() &lt;&lt; endl; } return 0;} 硬币问题贪心法前面用贪心法解决的最少硬币问题要求的硬币面值是特殊的，对于任意币值的硬币问题，需要用动态规划解决。 hdoj 1421搬寝室//https://blog.csdn.net/Ratina/article/details/84988571 当 i == 2 * j 时，只能选择 a[i]，而当 i &gt; 2 * j 时，在选 a[i] 和不选 a[i] 中择优。 ​ $$dp[i][j]=\\dp[i−2][j−1]+(a[i]−a[i−1])^2, i=2j\\min(dp[i-2][j-1]+(a[i]-a[i-1])^2,dp[i-1][j]),i&gt;2j$$那么状态转移方程如下： 12345678910111213141516171819202122232425262728#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;int main(){ int n,k; while(scanf(\"%d%d\",&amp;n,&amp;k)!=EOF) { int i,j; int a[2010],dp[2010][1005]; for(i=1;i&lt;=n;i++) scanf(\"%d\",&amp;a[i]); sort(a+1,a+n+1); memset(dp,0,sizeof(dp)); for(i=1;i&lt;=n;i++) for(j=1;j&lt;=k&amp;&amp;j*2&lt;=i;j++) //只有 i&gt;=2*j才有答案 { int t=(a[i]-a[i-1])*(a[i]-a[i-1]); if(j*2==i) dp[i][j]=dp[i-2][j-1]+t; else dp[i][j]= min(dp[i-2][j-1]+t,dp[i-1][j]); } printf(\"%d\\n\",dp[n][k]); } return 0;} j*2&lt;=i才会有答案 j*2==i的话，所有物品都必须选择，不等于i的话可以有选或者不选","link":"/2019/10/21/动态规划(dynamic programming)/"},{"title":"多任务","text":"多任务介绍linux是多用户，多任务的系统 多用户：通过ssh可以连接你的电脑 多任务：可以开几个程序 线程就结束了 多任务的一个好处等号旁边有空格 函数和函数之间空两个行，函数和类 dd全部删了 dw 删除了当前的单词 先把歌唱完，然后再去跳舞 threading，线程多任务界面刷新 pygame植物大战僵尸，播放音乐 多任务的概念单核CPU的原理：CPU是什么，CPU是干嘛的 CPU就是一个发动机，有块电路板，在上面焊着 硬件去做这个事情 单核CPU，一个时刻是做一件事情 陌陌安卓越狱安装模拟定位，定位到某个大学里面。 为什么手机里面可以看到很多在运行，执行一个非常小的时间，一秒钟执行好几百万次：时间片轮转，调度算法 时间片轮转满足不了怎么办 优先级调度 声音要模拟信号，形成连续的情况 一起是双引号的一起：人分不清 while true一直循环，形成动画效果 雨露均沾 多核CPU：想让电脑快点就买个4核的 并行计算： 真的多任务 并发：假的多任务 魔术师在抛球，并发 两个手但是八个球 thread创建线程，完成多任务类的名字加上一个括号，就是创建一个对象 等号左边是变量所指的实例对象 程序运行其实就是箭头在走 这个箭头其实就是线程 运行到start的时候就是生成了一个小箭头，指向target的位置，传的是函数的引用 调用了这个start说明可以直接运行 小箭头称为子线程 大箭头称为主线程 看别人的代码不能从第一行开始看 一天看一千多行看不了 电压处理，改需求 八千行有三千行是重复的 没有好的老大就直接走 target里面不能加函数名，加上括号是调用函数 不加括号是等于告诉我这个函数在那里，即把地址发给我 但是为什么不在同一行输出呢 查看正在运行的线程，线程的信息打印的时候变成了一个元组 w就是跳一个单词 b就是往回跳一个单词 线程的执行没有先后顺序，可能执行完了还是没看到执行 先让前面的程序延时 主线程延迟一秒，让子线程执行五次， 线程创建相互执行不确定 通过继承thread类完成创建线程threading .thread // 准备工作 t.start() // 现在才创建线程 主线程帮你收尸 多线程共享全局变量 一定要用global么 yy p 复制粘贴 找了一个对象，虽然在同一个家里面，很多东西不一样，但是像卫生间之类的其实是共享的 args共享有什么好处？ 因为多任务往往配合使用 一个在网上抓取数据，然后数据再共享给我，然后再发邮件给我 多任务就是配合起来做任务 共享数据 共享全局变量问题共享全局变量会产生资源竞争 一个写一个读没什么问题 VMware共享剪切板 电脑在执行代码的时候其实是放进CPU里面执行 当执行某个代码的时候，CPU觉得时间到了就把这句话还回去，还没有把这个值放进去 当重新来一趟的时候再执行这句话，赋的两个值都是一样的 那为什么比较小的时候又可以呢 那是因为，只有运气不好的时候CPU才会这样 ，但是次数越多意味着可能性越大 同步概念，互斥锁解决资源竞争要么不做，要么做完，原则性 银行转钱，网络出错导致没转好钱，必须做完 要么不做，要么做绝 同步就是协调，必须一次左脚一次右脚 互斥锁 窗口买票 1234567891011import threadingimport time# 买了锁没用mutes = threading.Lock()# 锁定mutex.acquire()# 释放mutex.release()#一次锁只能上锁一次# 解锁了才能去做 死锁，银行家算法 添加超时时间 银行放贷。存钱的人亏 银行家算法 到了一定时间流程，你还给我 多任务udp聊天器收发一起进行 收发放到一个线程里面 看看套接字能否接受同时收发 十三大G gg 大g最后一行 A跳到行尾 https://blog.csdn.net/shanzhizi/article/details/8293638","link":"/2019/10/31/多任务介绍/"},{"title":"","text":"多任务线程有多个代码一起运行 threading封装已经足够好了 程序越多电脑越慢，因为只有一个CPU enumerate查询线程数量 进程程序就是exe 代码整成二进制 进程是拥有资源的地方，鼠标键盘，光标网卡 分为三种状态 就绪： 所有状态都准备好了 运行： 他在那里运行了 等待： sleep的时候 123456789101112131415161718大v选中：normal i #u撤销shift+ctrl+t ps 当前进程的状态ps -aux第一列 谁运行的PID processid PID一定不能相同TTY哪个终端在执行s正在休眠cpu占用cpu百分比mem占用内存百分比vsz虚拟化资源rss是真的资源command 运行程序名是什么ls -a 隐藏的rm 删掉 为什么已终止是在前面 没保存好的话，他会保存一个隐藏的文件夹","link":"/2019/11/25/多任务编程之进程/"},{"title":"大二上复习计划","text":"Monday Tuesday Wednesday Thursday Friday Saturday Sunday 8:05 ～ 8:30 ENGLISH 8:30 ～ 8:50 概率论 计网 计网 ACM（45+30）8.40-10.20 复变函数2张海英 ACM 计网 8:55 ～ 9:40 数据库 10:00 ～ 10:45 数据结构刷题 数据库 张红娟 数据结构模拟试卷 概率论 ACM 复变函数 10:50 ～ 11:35 11:40 ～ 12:25 lunch lunch 12:25 ～ 13:00 ENGLISH 13:30 ～ 14:15 数据结构4王立波 计网实验课刷题 ACM 计算机网络 概率论3 14:20 ～ 15:05 15:15 ～ 16:00 数据结构刷题 网络编程 ACM 16:05 ～ 16:50 17:20 ～ 18:00 dinner 18:00 ～ 19:00 洗澡 18:30 ～ 19:15 数据库刷题 计算机网络 acm实训3 计算机网络 数据结构刷题 19:20 ～ 20:05 20:05 ～ 20:30 ACM 20:30 ～ 21:00 复变函数 概率论 复变函数 数据库刷题 21:05 ～ 21:50 计网模拟试卷 复变函数 22:00 ～ 22:30 ENGLISH 22:30 ～ 23:05 万词班 23:05 ～ 00:05 计网 ACM 计网 ACM 计网 ACM 计网","link":"/2019/11/20/大二上学期复习计划/"},{"title":"大数","text":"大数相乘万进制： 这题也让我有了点想法。我们经常用的进制就是2进制、8进制、10进制和16进制。何来“万进制”？世上本无，有人喊了也就有了。呵呵 ​ 现在来谈谈自己对进制的一点不成熟的想法。计算机能“识别”0和1，人能识别0、1、2、3、4、5、6、7、8、9以及其多位组合。那么， 为啥就单单有2、8、10、16这几个进制。我想并不止这几个，10进制是我们日常生活沿用来了的，难道来个5进制就不行？当然不是，不过 一切以方便优先罢了！2进制是因为方便计算机识别才兴起的，5000年前应该不会有2进制！8进制和16进制又因何2进制有天然联系，所以 也出现了用途，2^3=8、2^4=16（例：这在《数字逻辑》中关于编码方面有相关应用）。 ​ 就题论题。再来谈谈1042的万进制。也以一个例子来说明： ​ 107924372*15=1618865580。 ​ ①上面的乘法如果运用10进制，很简单。 ​ ②万进制呢？ ​ 首先存数：a[0]=4372，a[1]=792，a[2]=1。107924372，从低位到高位每四位存到一个数组元素中。此时，总位数为3。 ​ 接着运算：a[0]15=65580，所以进位为a[0]/10000=6，a[0]=a[0]%10000=5580。a[1]15=11880，a[1]=a[1]+6=11886。 ​ 进位为1，a[1]=1886。a[2]*15=15，a[2]=a[2]+1=16，进位为0。 ​ 输出：a[2],a[1],a[0]即为1618865580。要注意的是：如果a[2]=886，那么该如何输出？直接输出：168865580。显然不对， ​ 正确的是16088655880。输出的原则是：最高位原样输出，其它位如果小于1000，则高位补0，一位一补。 总之，高精度计算阶乘一般用万进制。 hdoj 1042 大数 Java12345678910111213141516171819202122232425262728293031用java：import java.math.BigInteger;import java.util.Scanner;public class Main { public static void main(String[] args) { Scanner in = new Scanner (System.in); int n; while(in.hasNextInt()) { n=in.nextInt(); BigInteger a=BigInteger.ONE; for(int i=1;i&lt;=n;i++) a=a.multiply(BigInteger.valueOf(i)); System.out.println(a); } }} 万进制实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;iostream&gt;#include &lt;iomanip&gt;using namespace std;void fac(int n){ int a[10001]; int carry = 0, place = 0, i, j; a[0] = 1; for (i = 1; i &lt;= n; i++) { carry = 0; for (j = 0; j &lt;= place; j++) { a[j] = a[j] * i + carry; carry = a[j] / 10000; a[j] %= 10000; } if (carry &gt; 0) { place++; a[place] = carry; } } cout &lt;&lt; a[place]; for (i = place - 1; i &gt;= 0; i--) cout &lt;&lt; setw(4) &lt;&lt; setfill('0') &lt;&lt; a[i];}int main(){ int n; while (cin &gt;&gt; n) { fac(n); cout &lt;&lt; endl; } return 0;} 大数相加 hdoj1002c++实现，模拟加法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;#define max(a, b) (a &gt; b ? a : b) //类似于定义一个函数求二者中的较大者int main(){ //freopen(\"in.txt\",\"r\",stdin);//调试用 int T; cin &gt;&gt; T; //T组数据 for (int t = 1; t &lt;= T; t++) { string x, y; cin &gt;&gt; x &gt;&gt; y; //输入两个数 //结果输出时的格式控制 cout &lt;&lt; \"Case \" &lt;&lt; t &lt;&lt; \":\" &lt;&lt; endl; cout &lt;&lt; x &lt;&lt; \" + \" &lt;&lt; y &lt;&lt; \" = \"; int xL = x.length(); //x的长度 int yL = y.length(); //y的长度 if (xL &lt; yL) //如果x的位数小，则交换，因为最后统一将结果存储在x中 { x.swap(y); //交换内容 int len = xL; //因为后面要用到yL，所以长度也要交换 xL = yL; yL = len; } //到这里x一定是长度较长的那个 int L = max(xL, yL) + 1; //结果的长度为x和y的最大长度+1(此处L的值其实就是xL+1) x = '0' + x; //x的前面添加一个0 int i, j; //循环变量 for (i = yL + 1; i &lt;= L; i++) //使x和y的长度一样 y = '0' + y; //添加0 //下面开始加法运算了 int c = 0; //记录进位：c=1或者c=0 for (i = L - 1; i &gt;= 0; i--) //从右边加到左边 { int z = x[i] - '0'; //获取x[i]对应的字符对应的数字，例如x[i] = '6',则x[i]-'0'就是int型的6. int w = y[i] - '0'; int h = z + w + c; //下面三行代码是[核心代码]，描述加法的过程 c = h / 10; x[i] = h % 10 + '0'; } //输出预处理：找到从什么开始没有0(去除前导0) for (i = 0; i &lt; L; i++) if (x[i] != '0') break; for (j = i; j &lt; L; j++) //输出 cout &lt;&lt; x[j]; cout &lt;&lt; endl; if (t != T) //空行 cout &lt;&lt; endl; } return 0;} java实现12345678910111213141516171819202122232425262728import java.math.BigInteger;import java.util.Scanner;public class Main { /** * 用来处理大数 * @param args */ public static void main(String[] args) { Scanner cin=new Scanner(System.in); int n= cin.nextInt(); int index=1; while(n--&gt;0){ String s1=cin.next(); String s2=cin.next(); BigInteger a=new BigInteger(s1); BigInteger b= new BigInteger(s2); BigInteger c= a.add(b); System.out.println(\"Case \" + (index++) + \":\"); System.out.println(a.toString()+\" + \"+b.toString()+\" = \"+c.toString()); if(n&gt;0) System.out.println(\"\"); } cin.close(); }} 大数模板，重载运算符123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;iomanip&gt;#include &lt;algorithm&gt;using namespace std;#define MAXN 9999#define MAXSIZE 10#define DLEN 4class BigNum{private: int a[500]; //可以控制大数的位数 int len; //大数长度public: BigNum() { len = 1; memset(a, 0, sizeof(a)); } //构造函数 BigNum(const int); //将一个int类型的变量转化为大数 BigNum(const char *); //将一个字符串类型的变量转化为大数 BigNum(const BigNum &amp;); //拷贝构造函数 BigNum &amp;operator=(const BigNum &amp;); //重载赋值运算符，大数之间进行赋值运算 friend istream &amp;operator&gt;&gt;(istream &amp;, BigNum &amp;); //重载输入运算符 friend ostream &amp;operator&lt;&lt;(ostream &amp;, BigNum &amp;); //重载输出运算符 BigNum operator+(const BigNum &amp;) const; //重载加法运算符，两个大数之间的相加运算 BigNum operator-(const BigNum &amp;) const; //重载减法运算符，两个大数之间的相减运算 BigNum operator*(const BigNum &amp;)const; //重载乘法运算符，两个大数之间的相乘运算 BigNum operator/(const int &amp;) const; //重载除法运算符，大数对一个整数进行相除运算 BigNum operator^(const int &amp;) const; //大数的n次方运算 int operator%(const int &amp;) const; //大数对一个int类型的变量进行取模运算 bool operator&gt;(const BigNum &amp;T) const; //大数和另一个大数的大小比较 bool operator&gt;(const int &amp;t) const; //大数和一个int类型的变量的大小比较 void print(); //输出大数};BigNum::BigNum(const int b) //将一个int类型的变量转化为大数{ int c, d = b; len = 0; memset(a, 0, sizeof(a)); while (d &gt; MAXN) { c = d - (d / (MAXN + 1)) * (MAXN + 1); d = d / (MAXN + 1); a[len++] = c; } a[len++] = d; BigNum::BigNum(const char *s) //将一个字符串类型的变量转化为大数 { int t, k, index, l, i; memset(a, 0, sizeof(a)); l = strlen(s); len = l / DLEN; if (l % DLEN) len++; index = 0; for (i = l - 1; i &gt;= 0; i -= DLEN) { t = 0; k = i - DLEN + 1; if (k &lt; 0) k = 0; for (int j = k; j &lt;= i; j++) t = t * 10 + s[j] - '0'; a[index++] = t; } } BigNum::BigNum(const BigNum &amp;T) : len(T.len) //拷贝构造函数 { int i; memset(a, 0, sizeof(a)); for (i = 0; i &lt; len; i++) a[i] = T.a[i]; } BigNum &amp;BigNum::operator=(const BigNum &amp;n) //重载赋值运算符，大数之间进行赋值运算 { int i; len = n.len; memset(a, 0, sizeof(a)); for (i = 0; i &lt; len; i++) a[i] = n.a[i]; return *this; } istream &amp;operator&gt;&gt;(istream &amp;in, BigNum &amp;b) //重载输入运算符 { char ch[MAXSIZE * 4]; int i = -1; in &gt;&gt; ch; int l = strlen(ch); int count = 0, sum = 0; for (i = l - 1; i &gt;= 0;) { sum = 0; int t = 1; for (int j = 0; j &lt; 4 &amp;&amp; i &gt;= 0; j++, i--, t *= 10) { sum += (ch[i] - '0') * t; } b.a[count] = sum; count++; } b.len = count++; return in; } ostream &amp;operator&lt;&lt;(ostream &amp;out, BigNum &amp;b) //重载输出运算符 { int i; cout &lt;&lt; b.a[b.len - 1]; for (i = b.len - 2; i &gt;= 0; i--) { cout.width(DLEN); cout.fill('0'); cout &lt;&lt; b.a[i]; } return out; } BigNum BigNum::operator+(const BigNum &amp;T) const //两个大数之间的相加运算 { BigNum t(*this); int i, big; //位数 big = T.len &gt; len ? T.len : len; for (i = 0; i &lt; big; i++) { t.a[i] += T.a[i]; if (t.a[i] &gt; MAXN) { t.a[i + 1]++; t.a[i] -= MAXN + 1; } } if (t.a[big] != 0) t.len = big + 1; else t.len = big; return t; } BigNum BigNum::operator-(const BigNum &amp;T) const //两个大数之间的相减运算 { int i, j, big; bool flag; BigNum t1, t2; if (*this &gt; T) { t1 = *this; t2 = T; flag = 0; } else { t1 = T; t2 = *this; flag = 1; } big = t1.len; for (i = 0; i &lt; big; i++) { if (t1.a[i] &lt; t2.a[i]) { j = i + 1; while (t1.a[j] == 0) j++; t1.a[j--]--; while (j &gt; i) t1.a[j--] += MAXN; t1.a[i] += MAXN + 1 - t2.a[i]; } else t1.a[i] -= t2.a[i]; } t1.len = big; while (t1.a[len - 1] == 0 &amp;&amp; t1.len &gt; 1) { t1.len--; big--; } if (flag) t1.a[big - 1] = 0 - t1.a[big - 1]; return t1; } BigNum BigNum::operator*(const BigNum &amp;T) const //两个大数之间的相乘运算 { BigNum ret; int i, j, up; int temp, temp1; for (i = 0; i &lt; len; i++) { up = 0; for (j = 0; j &lt; T.len; j++) { temp = a[i] * T.a[j] + ret.a[i + j] + up; if (temp &gt; MAXN) { temp1 = temp - temp / (MAXN + 1) * (MAXN + 1); up = temp / (MAXN + 1); ret.a[i + j] = temp1; } } { up = 0; ret.a[i + j] = temp; } } if (up != 0) ret.a[i + j] = up; } ret.len = i + j; while (ret.a[ret.len - 1] == 0 &amp;&amp; ret.len &gt; 1) ret.len--; return ret;}BigNum BigNum::operator/(const int &amp;b) const //大数对一个整数进行相除运算{ BigNum ret; int i, down = 0; for (i = len - 1; i &gt;= 0; i--) { ret.a[i] = (a[i] + down * (MAXN + 1)) / b; down = a[i] + down * (MAXN + 1) - ret.a[i] * b; } ret.len = len; while (ret.a[ret.len - 1] == 0 &amp;&amp; ret.len &gt; 1) ret.len--; return ret;}int BigNum::operator%(const int &amp;b) const //大数对一个int类型的变量进行取模运算{ int i, d = 0; for (i = len - 1; i &gt;= 0; i--) { d = ((d * (MAXN + 1)) % b + a[i]) % b; } return d;}BigNum BigNum::operator^(const int &amp;n) const //大数的n次方运算{ BigNum t, ret(1); int i; if (n &lt; 0) exit(-1); if (n == 0) return 1; if (n == 1) return *this; int m = n; while (m &gt; 1) { t = *this; else { t = t * t; } m -= i; ret = ret * t; if (m == 1) ret = ret * (*this); } return ret;}bool BigNum::operator&gt;(const BigNum &amp;T) const //大数和另一个大数的大小比较{ int ln; if (len &gt; T.len) return true; else if (len == T.len) { ln = len - 1; while (a[ln] == T.a[ln] &amp;&amp; ln &gt;= 0) ln--; if (ln &gt;= 0 &amp;&amp; a[ln] &gt; T.a[ln]) return true; else return false; } else return false;}bool BigNum::operator&gt;(const int &amp;t) const //大数和一个int类型的变量的大小比较{ BigNum b(t); return *this &gt; b;}void BigNum::print() //输出大数{ int i; cout &lt;&lt; a[len - 1]; for (i = len - 2; i &gt;= 0; i--) { cout.width(DLEN); cout.fill('0'); cout &lt;&lt; a[i]; } cout &lt;&lt; endl;}int main(){ int i, n; BigNum x[101]; //定义大数的对象数组 for (i = 1; i &lt;&lt; 1 &lt;= m; i &lt;&lt;= 1) for (i = 1; i &lt; 101; i++) x[i] = x[i - 1] * (4 * i - 2) / (i + 1); while (scanf(\"%d\", &amp;n) == 1 &amp;&amp; n != -1) { x[n].print(); } return 0;}","link":"/2019/10/21/大数/"},{"title":"字符串","text":"字符串字符串数组一定要提前定义长度 str函数strlenstrlen(数组名) strcmpstrcmp比较两个字符串的字母顺序，按照递减来 strcmp(数组名1，数组名2) 字符串输入输出单字节输入ch = getchar(); 防止输入空格，所以在前面加上getchar() puts()和gets()输入输出gets(str---数组名) 读入一整行，但是如果输入的数据比读入的字符数组大，则会警告 puts(str) 直接把某一行输出，但是它会在最后面加上回车 12345678910111213141516171819202122232425262728293031323334#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 1005; // 这个要加分号int main(){ int n; char ch; scanf(\"%d\", &amp;n); getchar(); while (n--) { stack&lt;char&gt; s; while (true) { ch = getchar(); if (ch == '\\n' || ch == EOF) { while (!s.empty()) { printf(\"%c\", s.top()); s.pop(); } if (ch == '\\n' || ch == EOF) break; printf(\" \"); } else s.push(ch); } printf(\"\\n\"); } return 0;} 字符串按照ancii码排序12345678910111213141516171819202122232425262728#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main(){ char a[100]; int n, l, j, k, i, tmp; while (scanf(\"%s\", a) != EOF) { n = strlen(a); for (j = 0; j &lt; n - 1; j++) { //冒泡 for (k = n - 1; k &gt; j; k--) { if (a[k] &lt; a[k - 1]) { tmp = a[k]; a[k] = a[k - 1]; a[k - 1] = tmp; } } } for (i = 0; i &lt; n; i++) { printf(\"%c\", a[i]); } } return 0;} 1234567891011121314151617#include&lt;bits/stdc++.h&gt;using namespace std;int main(){ char a[100]; int n, l, j, k, i, tmp; while (scanf(\"%s\", a) != EOF) { n=strlen(a); sort(a,a+n+1); for (int i = 1; i &lt;= n; i++) { printf(\"%c\", a[i]); } } return 0;} 12345678910111213141516171819202122#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;stdio.h&gt;using namespace std;int main(){ int a[12] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}; int year, month, day; while (~scanf(\"%d/%d/%d\", &amp;year, &amp;month, &amp;day)) { int sum = 0; for (int i = 0; i &lt; month - 1; i++) { sum += a[i]; } sum = sum + day; if (month &gt; 2 &amp;&amp; ((year % 4 == 0 &amp;&amp; year % 100 != 0) || year % 400 == 0)) //判断是几月份和是否是闰年 sum = sum + 1; cout &lt;&lt; sum &lt;&lt; endl; } return 0;} 123456789101112131415161718192021222324252627282930313233343536#include &lt;bits/stdc++.h&gt;using namespace std;int max(int a, int b){ return a &gt; b ? a : b;}int main(){ int negative = 0; int positive = 0; int zero = 0; string s; while (cin &gt;&gt; s) { for (int i = 0; i &lt; s.size(); i++) { if (s[i] != ' ') { if (s[i] - '0' &gt; 0) { positive++; } if (s[i] - '0' == 0) { zero++; } if (s[i] - '0' &lt; 0) { negative++; } } } printf(\"%d %d %d\\n\", negative, zero, positive); } return 0;} hdoj 2072 单词总数AC代码 12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;#include &lt;sstream&gt;#include &lt;string&gt;using namespace std;const int maxn = 10000;string dic[maxn];int main(){ for (string input; getline(cin, input);) { int cnt = 0; if (input == \"#\") break; else { stringstream ss(input); string word; while (ss &gt;&gt; word) { int isIn = 0; for (int i = 0; i &lt; cnt; i++) { if (word == dic[i]) { isIn = 1; break; } } if (!isIn) dic[cnt++] = word; } } cout &lt;&lt; cnt &lt;&lt; endl; }} getline的判断 因为回车输入的是一个换行符，相当于另起一行，所以getline()会把这个空行读到s里面去，你最后输出的当然就是一个空行。但是，要理解这个过程究竟是怎么发生的，题主应该要明白几个概念：（1）eof标志（2）cin的状态while(geline(cin,s))这个语句的执行过程是这样的：先调用getline()函数，getline()将istream cin中的内容读取一行（你输入的是hello world)，保存进string s中，而getline()的返回值就是cin。也就是说，这个循环的判定条件是while(cin)，cin是怎么转化为bool类型进行条件判断的呢？这个判定实际上隐式调用了 !cin.fail()，而fail()这个成员函数被定义在ios_base类里面（这是istream的基类basic_ios的基类）。那么调用fail()返回的是什么？是cin的状态。cin的状态是由4个标志位指示的（关于stream的标志的内容实际上就可以在C++ Primer中找到），分别是badbit（表示流已经崩溃），failbit（表示IO操作失败），eofbit，goodbit。当badbit或者failbit被置位时，fail()会返回true，!fail()结果为false。当遇到文件末端时，eofbit和failbit都会被置位，因此只有碰到Ctrl+Z（Windows下输入即等同文件末端eof），while()条件不再满足，退出。再来看你的操作过程，hello world，回车，Ctrl+Z。所以程序最后这么运行的：hello world被读入s，换行后的空行被读入s，末端标志eof使cin为无效状态，while()判断为假，循环退出。输出s。 123456789101112131415161718192021222324252627282930313233#include &lt;bits/stdc++.h&gt;using namespace std;string dic[1005];int main(){ string input; while (getline(cin, input)) //while getline不可以 { if (input == \"#\") break; //双引号 string word; stringstream ss(input); //ss=input; int cnt = 0; while (ss &gt;&gt; word) { int isIn = 0; for (int i = 0; i &lt; cnt; i++) { if (word == dic[i]) { isIn = 1; break; } } if (!isIn) dic[cnt++] = word; } cout &lt;&lt; cnt &lt;&lt; endl; } return 0;} hdoj 2081 手机短号12345678910111213141516171819202122232425#include &lt;bits/stdc++.h&gt;using namespace std;char number[15];int main(){ int n; cin &gt;&gt; n; char ch; ch = getchar(); while (n--) { gets(number); cout &lt;&lt; \"6\"; for (int i = 0; number[i] != '\\0'; i++) { if (i &gt; 5) { cout &lt;&lt; number[i]; } } cout &lt;&lt; \"\\n\"; }} hdoj 2098 考试排名12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;stdio.h&gt;#include &lt;math.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;string&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;ctype.h&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;vector&gt;using namespace std;struct Stu{ int acnum, time; char name[10];};int n, m, i, num, wa, ac, x, y;Stu data[100000];char s[20];bool pd;bool cmp(Stu x, Stu y){ if (x.acnum &gt; y.acnum) return true; if (x.acnum == y.acnum &amp;&amp; x.time &lt; y.time) return true; if (x.acnum == y.acnum &amp;&amp; x.time == y.time &amp;&amp; strcmp(x.name, y.name) &lt;= 0) return true; return false;}int main(){ cin &gt;&gt; n &gt;&gt; m; //考试题目数和罚时分 num = 1; while (scanf(\"%s\", data[num].name) != EOF) { data[num].acnum = 0; data[num].time = 0; wa = 0; ac = 0; //初始化 for (i = 1; i &lt;= n; i++) { memset(s, '\\0', sizeof(s)); pd = false; scanf(\"%s\", s); if (s[0] == '-' || s[0] == '0') { //没有AC pd = true; } if (s[1] == '(' || strlen(s) &gt;= 5) { //AC了，但是有错误提交 pd = true; ++ac; sscanf(s, \"%d(%d)\", &amp;x, &amp;y); //从字符串中读取出x,y.sscanf的一个重要用法 data[num].time += x; wa += y; } if (pd == false) { //AC且没有错误提交 ++ac; sscanf(s, \"%d\", &amp;x); data[num].time += x; } } data[num].time += wa * m; //加上罚时 if (data[num].time &lt; 0) { data[num].time = 0; } data[num].acnum = ac; ++num; //记录下一个选手 } sort(data + 1, data + num, cmp); //自定义sort的排序规则 for (i = 1; i &lt;= num - 1; i++) { printf(\"%-10s %2d %4d\\n\", data[i].name, data[i].acnum, data[i].time); //输出名字（10个字符宽），做出的题数（2个字符宽，右对齐）和时间分（4个字符宽，右对齐）。名字、题数和时间分相互之间有一个空格。 } return 0;} 这是一道字符串处理的题目。题目本身没有太高深的算法，只是以表格的形式处理很麻烦。比如出现的116（5），括号的读入和处理。看着解题报告完成的，收获了很多。 STL中的sort排序，自己定义了排序规则cmp函数，可以按照题目的要求进行排序。 这里用到了sscanf的读取的一个技巧。认真分析这里的sscanf的使用。sscanf的用法： 本题：sscanf(s,”%d(%d)”,&amp;x,&amp;y);//从字符串中读取出x,y.b. 将字符读入到字符串中 123sscanf(“12345”,”%s”,str);printf(“用法三\\nstr = %s\\n”,str);则 str=12345 用结构体解决类似问题，很明显的面向对象的思想。 不要害怕一道题，这题目上次遇见时看都不想看，实际上静下心来看不是很困难。 对了还有一个地方要说明一下，就是解决带有括号的那个地方。下面有一行代码是： 1if(s[1]=='('||strlen(s)&gt;=5) 刚开始没看懂原作者的意图，后来觉得大概是他假设如果此题在AC但是有错误提交的情况下，如果提交的时间在1-9之间，那么s[1]就存储的应该是‘（’，如果提交的时间10-1000的话，那么比如20（3），字符串的长度至少大于等于5.所以strlen(s)&gt;=5 sscanf的用法​ 在做一道九度上机题时，突然发现sscanf()函数非常有用，就顺便从网上搜集资料整理一下。 sscanf() 的作用：从一个字符串中读进与指定格式相符的数据.原型: int sscanf (const char *str,const char * format,……..); 说明： sscanf()会将参数str的字符串根据参数format字符串来转换并格式化数据。转换后的结果存于对应的参数内。 成功则返回参数数目，失败则返回0。注意：sscanf与scanf类似，都是用于输入的，只是后者以键盘(stdin)为输入源，前者以固定字符串为输入源。 大家都知道sscanf是一个很好用的函数，利用它可以从字符串中取出整数、浮点数和字符串等等。它的使用方法简单，特别对于整数和浮点数来说。 这里就举几个经常用到的例子来说明他的用法，便于大家深刻理解他的用法. 例子： 1234567891011121314151617181920212223242526272829303132#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;int main(){ char str[100]; //用法一：取指定长度的字符串 sscanf(\"12345\", \"%4s\", str); printf(\"用法一\\nstr = %s\\n\", str); //用法二：格式化时间 int year, month, day, hour, minute, second; sscanf(\"2013/02/13 14:55:34\", \"%d/%d/%d %d:%d:%d\", &amp;year, &amp;month, &amp;day, &amp;hour, &amp;minute, &amp;second); printf(\"用法二\\ntime = %d-%d-%d %d:%d:%d\\n\", year, month, day, hour, minute, second); //用法三：读入字符串 sscanf(\"12345\", \"%s\", str); printf(\"用法三\\nstr = %s\\n\", str); //用法四：%*d 和 %*s 加了星号 (*) 表示跳过此数据不读入. (也就是不把此数据读入参数中) sscanf(\"12345acc\", \"%*d%s\", str); printf(\"用法四\\nstr = %s\\n\", str); //用法五：取到指定字符为止的字符串。如在下例中，取遇到'+'为止字符串。 sscanf(\"12345+acc\", \"%[^+]\", str); printf(\"用法五\\nstr = %s\\n\", str); //用法六：取到指定字符集为止的字符串。如在下例中，取遇到小写字母为止的字符串。 sscanf(\"12345+acc121\", \"%[^a-z]\", str); printf(\"用法六\\nstr = %s\\n\", str); return 0;} 123456789101112用法一str = 1234用法二time = 2013-2-13 14:55:34用法三str = 12345用法四str = acc用法五str = 12345用法六str = 12345+ 1062 text reverse123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;stack&gt;using namespace std;char s[1006];int main(){ int t; cin &gt;&gt; t; getchar(); while (t--) { stack&lt;char&gt; st; gets(s); int len = strlen(s); for (int i = 0; i &lt;= len; i++) { // 当遇到空格或者碰到回车的时候就输出 if (s[i] == ' ' || i == len) { while (!st.empty()) { // top是栈顶元素 char ch = st.top(); st.pop(); printf(\"%c\", ch); } if (i != len) printf(\" \"); continue; } else { st.push(s[i]); } } puts(\"\"); } return 0;}","link":"/2019/10/17/字符串/"},{"title":"数据机构---排序","text":"排序的基本概念按照给定的权重来进行排序 插入类排序直接插入排序对于当前序列，把下一个要排序的数字，与它前面的所有数字进行对比。 把每个节点的排序想成每次都有一个新的节点进来，然后进入队列，但是要找到自己在队列中的顺序 算法性能分析 时间复杂度 最坏的情况：每次对比移动所有的数字，时间复杂度: $O(n^2)$ 最好的情况：每次对比都是有序的，我只要遍历我前面的每一个数字就好了$O(n)$ 综上所述：平均时间复杂度为：$O(n^2)$ 空间复杂度分析 辅助存储空间不随待排序列的变化而变化(只是单纯的移动位置而已)，是一个常量，因此空间复杂度为$O(1)$ 折半插入排序（二分搜索）希尔排序希尔排序又叫缩小增量排序，他的排序好坏取决于增量的选择,增量是什么意思呢？以5来举例，我们每次以5来作为分割点，把0，5，15…这些位置的数字来进行插入排序。 然后第二趟是以2为增量进行排序 最后以1为增量进行排序 所以，对于希尔排序，他的每趟排序都会让整个序列变得更加有序 性能分析 时间复杂度 时间复杂度的大小和增量的选取有关。其中常用的有两种选取 希尔（shell）自己提出的 每次将增量除以2，并向下取整 时间复杂度为$O(n^2)$ 帕佩尔诺夫和斯塔舍维奇(Papernov &amp; Stasevich)提出的：$$2^k+1,…65,33,17,9,5,3,1$$时间复杂度为$O(n^1.5)$ 空间复杂度和直接插入排序一样，为$O(1)$ 注意点 最后一定要以1作为分量 希尔排序是不稳定的，即关键字有可能会发生改变 增量序列中的值应尽量没有除1以外的公因子 交换类排序冒泡排序每一个数字都和每一轮的邻居来交换 快速排序每一趟划分，将原来的序列划分成了，以枢纽轴为界限，左边全部比我小，右边全部比我大。然后进行多几次这样的划分，最终会得到一个有序的序列 性能分析时间复杂度： 最好的情况 $O(nlogn)$ 最坏的情况 $O(n^2)$ 越接近有序，这个算法的效率就越低 空间复杂度： 因为是递归执行的，所以空间复杂度是$O(logn)$ 选择排序简单选择排序分成两个部分，一个部分是已经排序好的，一个部分是将要排序的某个数字 堆排序大顶堆：父亲大，孩子小 小顶堆：父亲小，孩子大 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include &lt;stdio.h&gt;const int maxn = 1e6 + 5;int n, m, arr[maxn];#define ElemType intvoid swap(ElemType &amp;a, ElemType &amp;b){ ElemType tmp = a; a = b; b = tmp;}//堆是否为空bool isEmpty(ElemType heap[], int &amp;tot){ return tot &lt;= 0 ? true : false;}//上浮,先记忆我们要上浮的值，找到空位后再把这个值填上去void shift_Up(ElemType heap[], int &amp;tot, int index){ int fa, tmp = heap[index]; while (index) { //如果index本身是根就没有上浮的必要 fa = index - 1 &gt;&gt; 1; //找index的父亲结点 if (tmp &lt; heap[fa]) heap[index] = heap[fa]; else break; index = fa; } heap[index] = tmp;}//下沉，先记忆我们要下沉的值，找到空位后再把这个值填上去void shift_Down(ElemType heap[], int &amp;tot, int index){ int son, tmp = heap[index]; while ((index &lt;&lt; 1 | 1) &lt; tot) { //如果index没有左孩子就没有下沉的必要 son = index &lt;&lt; 1 | 1; //左孩子 if (son + 1 &lt; tot &amp;&amp; heap[son + 1] &lt; heap[son]) son++; //如果右孩子存在并且比左孩子小就取它 if (heap[son] &gt;= tmp) break; //此时该位置就是我们要填的 else heap[index] = heap[son]; index = son; //下沉 } heap[index] = tmp; //找到那个位置填下去}//插入bool push(ElemType heap[], int &amp;tot, int val){ if (tot &gt;= maxn) return false; heap[tot++] = val; shift_Up(heap, tot, tot - 1); //把新插入的结点上浮 return true;}//删除bool pop(ElemType heap[], int &amp;tot){ if (isEmpty(heap, tot)) return false; swap(heap[0], heap[--tot]); shift_Down(heap, tot, 0); //把新的根下沉 return true;}//查询bool top(ElemType heap[], int &amp;tot, ElemType &amp;val){ if (isEmpty(heap, tot)) return false; //查询失败 val = heap[0]; return true; ;}//构建void heapify(ElemType heap[], int &amp;tot){ for (int i = (tot - 1) / 2; i &gt;= 0; i--) shift_Down(heap, tot, i);}//堆排序void heap_sort(ElemType heap[], int &amp;tot){ for (int i = tot - 1; i &gt; 0; i--) { swap(heap[0], heap[i]); shift_Down(heap, i, 0); }}int main(){ while (scanf(\"%d%d\", &amp;n, &amp;m) != EOF) { for (int i = 0; i &lt; n; ++i) scanf(\"%d\", arr + i); heapify(arr, n); heap_sort(arr, n); for (int i = 0; i &lt; m; ++i) printf(\"%d%c\", arr[i], \" \\n\"[i == m - 1]); } return 0;}","link":"/2019/11/18/排序/"},{"title":"图的最短路径","text":"图的最短路hdoj 2544怎么表示这条边 DFS版本12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;int n,m,a,b,c,t;int map[108][108],v[108];void dfs(int x,int p)//x是开始的地方，p是当前的花费{ if (p&gt;t) return ; //剪枝，搜到一半已经比上一次长了，就没必要再搜了 if (x==n) { t=p; return ; } int i; for (i=2;i&lt;=n;i++) { if (!v[i]&amp;&amp;map[x][i]) { v[i]=1; dfs(i,p+map[x][i]); v[i]=0;//回溯 } }}int main(){ int i,j; while (~scanf(\"%d%d\",&amp;n,&amp;m)) { if (n==0&amp;&amp;m==0) return 0; memset(map,0,sizeof(map)); memset(v,0,sizeof(v)); while (m--) { scanf(\"%d%d%d\",&amp;a,&amp;b,&amp;c); map[a][b]=map[b][a]=c;//用这个来表示边的长度 } t=1000000; dfs(1,0); printf(\"%d\\n\",t); }} Floyd-Warshall算法 运用了动态规划思想 动态规划的过程可以描述为 先以某个地方为节点，然后去寻找其他的位置 以这个地方为节点的时候，如果去某个地方，要经过某个节点，判断去掉这个节点是否会更快 12345678910111213141516171819202122232425262728293031323334#include&lt;bits/stdc++.h&gt;using namespace std;const int INF=1e6; //路口之间的初始距离，看成无穷大，相当于断开const int NUM = 105;int graph[NUM ][NUM ]; //邻接矩阵存图int n, m;void floyd() { int s=1; //定义起点 for(int k=1; k&lt;=n; k++) //floyd的3重循环 for(int i=1; i&lt;=n; i++) if(graph[i][k] != INF) //一个小优化，在hdu 1704中很必要 for(int j=1; j&lt;=n; j++) //请思考：把k循环放到i、j之后行不行？ if(graph[i][j] &gt; graph[i][k] + graph[k][j]) graph[i][j] = graph[i][k] + graph[k][j];// graph[i][j] = min(graph[i][j], graph[i][k] + graph[k][j]); //上面2句这样写也行，但是min()比较慢，如果图大，可能会超时。读者可以试试poj 3259 printf(\"%d\\n\", graph[s][n]); //输出结果}int main() { while(~scanf(\"%d%d\", &amp;n, &amp;m)) { //如果图的数据很大，不能用cin这种慢的输入 if(n==0 &amp;&amp; m==0) return 0; for(int i=1; i&lt;=n; i++) //邻接矩阵初始化 for(int j=1; j&lt;=n; j++) graph[i][j] = INF; //任意两点间初始距离为无穷大 while(m--) { int a, b, c; scanf(\"%d%d%d\", &amp;a, &amp;b, &amp;c); graph[a][b] = graph[b][a] = c; //邻接矩阵存图 } floyd(); } return 0;} 这个算法虽然低效，但是还是有优点： 程序简单 可以一次性求出所有结点之间的最短路径（当然，这也是浪费时间的地方） 能处理有负权边的图 首先我们要理解什么是负权边 负权边就是我们如果有一条边是负的，那么他的最短路径是自己到自己，因为自己到自己可以越来越小，但是如果这样子做，我们永远找不到最短的路径 但是我们还是有处理的方法，怎么处理呢？ 先不设定自己到自己的初始值，即初始值不为零，而为无穷大。然后经过三次遍历之后，得到了自己到自己的初始值，如果为负，则赋值为0 最后一个内容就是邻接矩阵 顾名思义，邻接矩阵的表达方式就是通过一个二维矩阵，来存放顶点之间的关系（比如两个顶点之间的长度是多少） 邻接矩阵是对称的，即 12int map[30];map[a][b]=map[b][a]=c; Bellman-Ford算法这个算法可以怎么样理解呢？ 问路 比如说，你去问警察，从这里到s怎么走最近，但是这个警察不会，然后这个警察就去问隔壁的警察，这样一直问啊问，直到s的邻居问到了s，然后再一个一个返回 同时还有一个比较有趣的点： 警察并不知道去s这个地方的具体路径，他只需要知道从自己的路口出发往哪个方向走能到达s，并且路最近 123456789101112void bellman(){ int s = 1; int d[NUM]; for(int t = 1; i &lt;= n; i++) d[i] = INF ; d[s] = 0; for(int k = 1; k &lt;= n; k++) for(int i = 1 ; i &lt;= n ; i++) //处理图中存在的边 for(int j = 1 ; j &lt;= n ; j++) if...} 上面这个代码并没有实用价值，为什么这么说呢，因为它使用了邻接矩阵这种不合适的数据结构。因为他会检查每一条边，而我只需要检查存在的m条边 12源码后面接上用数组存边，但存的是双向边 当然，Bellman-ford算法也有判断负圈的功能 超过了n次，它还可以更新，说明有负圈 SPFA 算法 用队列处理bellman-Ford 由于在Bellman-ford算法中，由于是并行计算，所以有些结点在计算时，其实哪些不相邻的节点，他也在那里判断，但其实这样是十分低效的 所以我们就要判断一下，把状态有更新的邻居才把他入队，把计算一个节点到起点s的最短路径的简称为更新状态 ，而最后的状态就是我们要求的最短路径 首先，我们来了解一下什么叫做邻接表 邻接表（Adjacency List）无向图 graph 表示 就类似于单链表，但是它既可以用结构体指针来搞，又可以用静态数组来整 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768//ECUST luoyongjun#include&lt;bits/stdc++.h&gt;using namespace std;const int INF = 1e6;const int NUM = 105;struct edge{int from, to, w;//边：起点from，终点to，权值w。from并没有用到，e[i]的i就是from edge(int a, int b,int c){from=a; to=b; w=c;} //这里存的就是一个静态的};vector&lt;edge&gt; e[NUM]; //e[i]：存第i个结点连接的所有的边int n, m;int pre[NUM]; //记录前驱结点。pre[x]=y，在最短路径上，结点x的前一个结点是yvoid print_path(int s,int t) { //打印从s到t的最短路径 ; //内容与Bellman-Ford程序中的print_path()完全一样}int spfa(int s){ int dis[NUM]; //记录所有结点到起点的距离 bool inq[NUM]; //inq[i] = true 表示结点i在队列中 int Neg[NUM]; //判断负圈,Negative loop memset(Neg, 0, sizeof(Neg)); Neg[s] = 1; for(int i=1;i&lt;=n;i++) { dis[i]=INF; inq[i]=false; } //初始化 dis[s] = 0; //起点到自己的距离是0 queue&lt;int&gt; Q; Q.push(s); inq[s] = true; //起点进队列 while(!Q.empty()) { int u = Q.front(); Q.pop(); //队头出队 inq[u] = false; for(int i=0; i &lt; e[u].size(); i++) { //检查结点u的所有邻居 int v = e[u][i].to, w = e[u][i].w; if (dis[u]+w &lt; dis[v]) {//u的第i个邻居v，它借道u，到s更近 dis[v] = dis[u]+w; //更新第i个邻居到s的距离 pre[v] = u; //如果有需要，记录路径 if(!inq[v]) {//第i个邻居更新状态了，但是它不在队列中，把它放进队列 inq[v] = true; Q.push(v); Neg[v]++; if(Neg[v] &gt; n) return 1; //出现负圈 } } } } printf(\"%d\\n\",dis[n]); //print_path(s,n); //如果有需要，打印路径return 0;}int main(){ while(~scanf(\"%d%d\",&amp;n,&amp;m)) { if(n==0 &amp;&amp; m==0) return 0; for(int i=1; i&lt;=n; i++) e[i].clear(); while(m--) { int a,b,c; scanf(\"%d%d%d\", &amp;a, &amp;b, &amp;c); e[a].push_back(edge(a,b,c));//结点a的邻居，都放在node[a]里 e[b].push_back(edge(b,a,c)); } spfa(1); //起点是1 } return 0;} 判断负圈如果一个点进入队列超过n次，那就说明图中存在负圈 虽然这个基于邻接表的代码已经非常好了，但是在极端的情况下，图会非常的大，用邻接表也会超出空间限制，这个时候就需要用到链式前向星 前向星首先，我们理解一下什么叫做前向星 前向星 前向星解释 前向星和链式前向星不同 我们首先来看一下什么是前向星. 前向星是一种特殊的边集数组,我们把边集数组中的每一条边按照起点从小到大排序,如果起点相同就按照终点从小到大排序, 并记录下以某个点为起点的所有边在数组中的起始位置和存储长度,那么前向星就构造好了. 用len[i]来记录所有以i为起点的边在数组中的存储长度. 用head[i]记录以i为边集在数组中的第一个存储位置. 那么对于下图: 我们输入边的顺序为: 1 2 2 3 3 4 1 3 4 1 1 5 4 5 那么排完序后就得到: 编号: 1 2 3 4 5 6 7 起点u: 1 1 1 2 3 4 4 终点v: 2 3 5 3 4 1 5 得到: head[1] = 1 len[1] = 3 head[2] = 4 len[2] = 1 head[3] = 5 len[3] = 1 head[4] = 6 len[4] = 2 但是利用前向星会有排序操作,如果用快排时间至少为O(nlog(n)) 链式前向星如果用链式前向星,就可以避免排序. 我们建立边结构体为: 123456struct Edge{ int next; int to; int w; }; 其中edge[i].to表示第i条边的终点,edge[i].next表示与第i条边同起点的下一条边的存储位置,edge[i].w为边权值. 另外还有一个数组head[],它是用来表示以i为起点的第一条边存储的位置,实际上你会发现这里的第一条边存储的位置其实 在以i为起点的所有边的最后输入的那个编号. head[]数组一般初始化为-1,对于加边的add函数是这样的: 1234567void add(int u,int v,int w){ edge[cnt].w = w; edge[cnt].to = v; edge[cnt].next = head[u]; head[u] = cnt++;} 初始化cnt = 0,这样,现在我们还是按照上面的图和输入来模拟一下: edge[0].to = 2; edge[0].next = -1; head[1] = 0; edge[1].to = 3; edge[1].next = -1; head[2] = 1; edge[2].to = 4; edge[2],next = -1; head[3] = 2; edge[3].to = 3; edge[3].next = 0; head[1] = 3; edge[4].to = 1; edge[4].next = -1; head[4] = 4; edge[5].to = 5; edge[5].next = 3; head[1] = 5; edge[6].to = 5; edge[6].next = 4; head[4] = 6; 很明显,head[i]保存的是以i为起点的所有边中编号最大的那个,而把这个当作顶点i的第一条起始边的位置. 这样在遍历时是倒着遍历的,也就是说与输入顺序是相反的,不过这样不影响结果的正确性. 比如以上图为例,以节点1为起点的边有3条,它们的编号分别是0,3,5 而head[1] = 5 我们在遍历以u节点为起始位置的所有边的时候是这样的: for(int i=head[u];~i;i=edge[i].next) 那么就是说先遍历编号为5的边,也就是head[1],然后就是edge[5].next,也就是编号3的边,然后继续edge[3].next,也 就是编号0的边,可以看出是逆序的. 整体代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576//ECUST luoyongjun#include&lt;bits/stdc++.h&gt;using namespace std;const int INF = INT_MAX / 10;const int NUM = 1000005; //一百万个点,一百万个边struct Edge{ //边：edge[i]的i就是起点，终点to，权值w。下一个边nextint to, next, w;}edge[NUM];int n, m, cnt;int head[NUM];int dis[NUM]; //记录所有结点到起点的距离bool inq[NUM]; //inq[i] = true 表示结点i在队列中int Neg[NUM]; //判断负圈(Negative loop)int pre[NUM]; //记录前驱结点。void print_path(int s,int t) { //打印从s到t的最短路径 ; //内容与Bellman-Ford程序中的print_path()完全一样}void init(){ for(int i = 0; i &lt; NUM; ++i){ edge[i].next = -1; head[i] = -1; } cnt = 0;}void addedge(int u, int v, int w){ //前向星存图 edge[cnt].to = v; edge[cnt].w = w; edge[cnt].next = head[u]; head[u] = cnt++;}int spfa(int s) { memset(Neg, 0, sizeof(Neg)); Neg[s] = 1; for(int i=1; i&lt;=n; i++) { dis[i]=INF; inq[i]=false; } //初始化 dis[s] = 0; //起点到自己的距离是0 queue&lt;int&gt; Q; Q.push(s); inq[s] = true; //起点进队列 while(!Q.empty()) { int u = Q.front(); Q.pop(); //队头出队 inq[u] = false; for(int i=head[u]; ~i; i = edge[i].next) {//~i也可以写成 i!=-1 int v = edge[i].to, w = edge[i].w; if (dis[u]+w &lt; dis[v]) {//u的第i个邻居v，它借道u，到s更近 dis[v] = dis[u]+w; //更新第i个邻居到s的距离 pre[v] = u; //如果有需要，记录路径 if(!inq[v]) { //邻居v更新状态了，但是它不在队列中，把它放进队列 inq[v] = true; Q.push(v); Neg[v]++; if(Neg[v] &gt; n) return 1; //出现负圈 } } } } printf(\"%d\\n\",dis[n]); //从s的n的最短距离 // print_path(s,n); //如果有需要，打印路径 return 0;}int main() { while(~scanf(\"%d%d\",&amp;n,&amp;m)) {init(); if(n==0 &amp;&amp; m==0) return 0; while(m--) { int u,v,w; scanf(\"%d%d%d\", &amp;u, &amp;v, &amp;w); addedge(u,v,w); addedge(v,u,w); } spfa(1); } return 0;} SPFA整体思路每个警察只需要在某个邻居警察通知有路径变化之后才进行计算，并把变化传递给别的邻居；如果没有收到邻居发来的变化信息，金叉不需要做任何动作 Dijkstra算法先找起点s的邻居，看看哪个邻居是最短的 找到了最短的之后，再把多米诺骨牌分成两部分 一部分还是从起点出发（不能直接从最近的邻居出发，因为邻居可能没有邻居，或者他的邻居其实是很远的），另一部分则是从刚刚最近的邻居出发 然后一直循环这个过程 如何删除某些点呢，我们要看，从两个路径去到同一个点，如果某个路径比较大，就可以直接把它删除了 每次找最近的结点 使用优先队列，prioity队列在STL中有 但是STL没法做到丢弃这个操作，只能把某个节点删除时，就做个标记，做完标记之后，表示结点2已经处理好 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667//ECUST luoyongjun#include&lt;bits/stdc++.h&gt;using namespace std;const int INF = 1e6;const int NUM = 105;struct edge{ int from, to, w;//边：起点，终点，权值。起点from并没有用到，e[i]的i就是from edge(int a, int b,int c){from=a; to=b; w=c;}};vector&lt;edge&gt;e[NUM]; //用于存储图struct s_node{ int id, n_dis; //id：结点；n_dis：这个结点到起点的距离 s_node(int b,int c){id=b; n_dis=c;} bool operator &lt; (const s_node &amp; a) const { return n_dis &gt; a.n_dis;}};int n,m;int pre[NUM]; //记录前驱结点void print_path(int s,int t) { //打印从s到t的最短路径 ; //内容与Bellman-Ford程序中的print_path()完全一样}void dijkstra(){int s = 1; //起点s是1 int dis[NUM]; //记录所有结点到起点的距离 bool done[NUM]; //done[i]=true表示到结点i的最短路径已经找到 for (int i=1;i&lt;=n;i++) {dis[i]=INF; done[i]=false; } //初始化 dis[s]=0; //起点到自己的距离是0 priority_queue &lt;s_node&gt; Q; //优先队列，存结点信息 Q.push(s_node(s, dis[s])); //起点进队列 while (!Q.empty()) { s_node u = Q.top(); //pop出距起点s距离最小的结点u Q.pop(); if(done[u.id])//丢弃已经找到最短路径的结点。即集合A中的结点 continue; done[u.id]= true; for (int i=0; i&lt;e[u.id].size(); i++) { //检查结点u的所有邻居 edge y = e[u.id][i]; //u.id的第i个邻居是y.to if(done[y.to]) //丢弃已经找到最短路径的邻居结点 continue; if (dis[y.to] &gt; y.w + u.n_dis) { dis[y.to] = y.w + u.n_dis; Q.push(s_node(y.to, dis[y.to])); //扩展新的邻居，放到优先队列中 pre[y.to]=u.id; //如果有需要，记录路径 } } } printf(\"%d\\n\", dis[n]); // print_path(s,n); //如果有需要，打印路径}int main(){ while(~scanf(\"%d%d\",&amp;n,&amp;m)) { if(n==0 &amp;&amp; m==0) return 0; for (int i=1;i&lt;=n;i++) e[i].clear(); while (m--) { int a,b,c; scanf(\"%d%d%d\",&amp;a,&amp;b,&amp;c); e[a].push_back(edge(a,b,c));//结点a的邻居，都放在node[a]里 e[b].push_back(edge(b,a,c)); } dijkstra(); }} 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;bits/stdc++.h&gt;using namespace std;#define INF 0x3f3f3f3fconst int MaxnE = 10005;const int MaxnV = 105;struct Node{ int from, to, weight; bool operator&lt;(const &amp;Node A) { return A.weight &lt; weight; } //构造函数} node[MaxnE];int dis[MaxnV];bool vi[MaxnV];vector&lt;Node&gt; v[MaxnV];priority_queue&lt;vector&lt;Node&gt;&gt;; //void init(){ for (int i = 1; i &lt;= MaxnV; i++) { dis[i] = INF; }}void dijstral(){ // 把队列里面最短的边拿出来 // 这条边对应的点用起来 // 遍历这个结点的边 // while队列不为空 // 一直遍历他}int main(){ int n, m; while (~scanf(\"%d %d\", &amp;n, &amp;m) &amp;&amp; n + m) { init(); for (int i = 1; i &lt;= m; i++) { scanf(\"%d %d %d\", &amp;node[i].from, &amp;node[i].to, &amp;node[i].weight); v[node[i].from].push_back(Node()) // 放到结构体函数里面去 } dijstral(); cout &lt;&lt; dis[n] &lt;&lt; endl; }} 图的表示 邻接矩阵 dijkstra 单起点的最短路径 v0到各个城市的最短路径 按照最短路的路径长度递增的次序，依次求得原点 最短的最短路径，再找第二短的最短路径 最短的最短路径，首先它一定是和杭州直接相连的，并且是最短的那个 第二短的最短路径，只有经过最短的过去或者是直达的，（不可能经过其他城市，因为如果经过其他城市的话，其他城市就是第一次的最短路径了） 修改起点到各个点的距离，松弛操作。600变500，绳子变松了 定义一个数组，dis数据，表示起点到各个点的距离 松弛操作 一遍松弛结束，就找一个最短的值，为什么这样算找到第二个（如果我有一个结点，虽然第一次会远一点，但是第二条会很近） 比较两个值，一个是原来的，一个是转换结点的 多米诺骨牌，先碰到的先放进队列里面，先碰到的话就是最短的路径，其实就是最快的地方 为什么求最短距离要遍历全部的？因为有可能你想求的是最远的那一个 这个人叫丁爸编程 08年11年前，那是一个春天 0xfff int的最大值 28个1，31个1 2的31-1 dis起点到各个城市的最短距离 没有边就不需要再做了 剩余的所有城市都是不连通的 start改成now更好 处理过就标记为0，就不用再处理了 几十个最短路径，三十个题，学习就是这样的，以前五笔很快的，现在全拼很智能。一辈人有一辈人的方法 加一个点，虚拟的点，就是单源单终点的问题 原来假设有100个点 不仅输出最短路径还要你输出怎么走的","link":"/2019/10/21/图的最短路径/"},{"title":"","text":"拓扑排序我们说，做很多事情之前都会有先后次序，而通过这个先后得到的序列，就是拓扑排序 有拓扑排序的充要条件是这个图是有向无环图(DAG) 如何得到一个拓扑排序序列BFS怎么样BFS呢？我们假想，要做的第一件事情有什么特征？ 即前面没有一件事情在他前面，做的最后一件事情就是，没有一件事情在我后面 所以我们每次都选取入度为0的点，选取了之后，把相邻点的入度全部减一 用一个队列，把入度为0的点放进来，放进来之后把相邻点的入度全部减一，然后再把入度为0的点放进来，这样循环进行。 怎么样判断无解(注意的点)如果队列已经空了，但是还有点没进入队列，说明这个不是DAG图 复杂度分析因为要经过所有的点，同时每次要把入度为0的点加入队列 当然，准确来说是需要检查它直接连接的所有邻居(即遍历所有的边) 所以复杂度是 $O(V+E)$ 得到字典序最小的拓扑排序因为拓扑排序可以有很多，所以题目一般会要求我们给出一个字典序最小的那个拓扑排序 所以我们可以把普通队列改成优先队列，每次把字典序最小的节点先输出 思考: DFS获得拓扑排序能否得到字典序最小的呢 答案是不行的，因为DFS处理的是上下层之间的关系，不能处理这种同层次的关系 hdoj 1285 确定比赛名次12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;bits/stdc++.h&gt;using namespace std;vector&lt;int&gt; v[1005]; //v[a][b] 以a为头的第b条边对应的节点// 1005是存储结点的信息，vector才是我们存储的邻接表结点int a[1005];int n, m;void Topological_Order(){ priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; q; for (int i = 1; i &lt;= n; i++) { if (a[i] == 0) { q.push(i); } } while (!q.empty()) { int t = q.top(); q.pop(); for (int i = 0; i &lt; v[t].size(); i++) { a[v[t][i]]--; if (a[v[t][i]] == 0) { q.push(v[t][i]); } } printf(\"%d\", t); if (q.size() &gt; 0) { printf(\" \"); } else { printf(\"\\n\"); } }}int main(){ while (~scanf(\"%d %d\", &amp;n, &amp;m)) { int l, r; for (int i = 0; i &lt; m; i++) { scanf(\"%d %d\", &amp;l, &amp;r); v[l].push_back(r); a[r]++; } Topological_Order(); memset(a, 0, sizeof(a)); for (int i = 0; i &lt; 1005; i++) { v[i].clear(); // 每次的vector要手动清空 } }} 直接从编号小的开始找 再看一个例子，就没例子了 数据库编程，天天打球 DFS获得拓扑次序","link":"/2019/11/13/拓扑排序/"},{"title":"快速幂","text":"人见人爱a^b1234567891011121314typedef long long ll;ll mod;ll qpow(ll a, ll n)//计算a^n % mod{ ll re = 1; while(n) { if(n &amp; 1)//判断n的最后一位是否为1 re = (re * a) % mod; n &gt;&gt;= 1;//舍去n的最后一位 a = (a * a) % mod;//将a平方 } return re % mod;} 123456789101112131415ll qpow(ll a,ll b){ ll temp=a; ll mutiple=1; while (b != 0) { if (b&amp;1) { mutiple = (mutiple *temp)%1000; //乘等于可能会错 } b&gt;&gt;=1; temp=(temp * temp)%1000; //这里也要取余 } return mutiple%1000; }","link":"/2019/11/12/快速幂/"},{"title":"","text":"8：00 - 8：30 早餐 8：40 - 9：00 英语阅读背单词 9：00 - 10：30 python基础学习 10：45 - 12：15 ACwing刷题 12：15 - 13：00 吃饭 13：00 - 13：20 休息 13：20 - 13：40 睡觉 13：50 - 15：20 ACwing刷题 15：20 - 15：30 休息 15：30 - 16：30 雅思做题 16：30 - 17：10 健身（减肥） 17：20 - 18：00 ACwing刷题 18：00 - 19：30 吃饭休息 19：40 - 21：00 雅思做题 21：10 - 21：30 洗澡 21：40 - 22：40 ACwing刷题 22：40 - 24：00 python基础学习","link":"/2020/02/11/寒假时间安排/"},{"title":"","text":"RSA算法","link":"/2019/11/28/数据库大作业/"},{"title":"最小生成树","text":"596382 最小生成树(Minimal Spanning Tree) MST 算法背景:已知有n座村庄需要修通道路，问怎么修路，使得所有的村庄都联通，不一定要直接相连，只需要有路到达即可 算法原理​ 现在有两种方法可以构造最小生成树T。这两种算法都基于贪心法。因为MST问题满足贪心法的”最优性原理”，即全局最优包括局部最优 Prim算法(最近的邻居一定在MST上)​ 对点进行贪心操作。从任意一个点u开始，把距离它最近的点v加入到T中；下一步，再把距离 {u，v} (此时生成的子树) 最近的点w加入到T中；继续这个过程，直到所有点都在T中 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#define mem(a, b) memset(a, (b), sizeof(a))#define Wi(a) while (a--)#define Si(a) scanf(\"%d\", &amp;a)#define Pi(a) printf(\"%d\\n\", (a))#define Pf(a) printf(\"%.1lf\\n\", (a))#define INF 0x3f3f3fdouble map[150][150];int x[150], y[150];int n;double d[150], vis[150];void prim(){ mem(vis, 0); int i, j, k; double ans = 0, minn; for (i = 1; i &lt;= n; i++) d[i] = map[1][i]; vis[1] = 1; for (i = 1; i &lt; n; i++) { k = 1; minn = INF; for (j = 1; j &lt;= n; j++) { if (!vis[j] &amp;&amp; d[j] &lt; minn) { minn = d[j]; k = j; } } if (minn == INF) { puts(\"oh!\"); return; } vis[k] = 1; ans += minn; for (j = 1; j &lt;= n; j++) { if (!vis[j] &amp;&amp; d[j] &gt; map[j][k]) d[j] = map[j][k]; } } Pf(ans * 100);}int main(){ int t; Si(t); Wi(t) { Si(n); int i, j, k; for (i = 1; i &lt;= n; i++) { scanf(\"%d%d\", &amp;x[i], &amp;y[i]); } for (i = 1; i &lt;= n; i++) { for (j = 1; j &lt;= n; j++) { double d = sqrt((x[i] - x[j]) * (x[i] - x[j]) + (y[i] - y[j]) * (y[i] - y[j])); if (d &gt;= 10.0 &amp;&amp; d &lt;= 1000.0) map[i][j] = map[j][i] = d; else map[i][j] = map[j][i] = INF; } map[i][i] = 0; } prim(); } return 0;} Kruskal算法(最短的边一定在MST上)​ 对边进行贪心操作。从最短的边开始，把它加入到T中；在剩下的边中找最短的边，加入到T中；继续这个过程，知道所有边都在T中 算法实现Kruskal算法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;bits/stdc++.h&gt;using namespace std;const int NUM = 103;int S[NUM]; // 并查集struct Edge{ int u, v, w;} edge[NUM * NUM]; //定义边bool cmp(Edge a, Edge b){ return a.w &lt; b.w;}int find(int u){ return S[u] == u ? u : find(S[u]); //查询并查集，返回u的根节点}int n, m; //顶点数目，边的数目int kruskal(){ int ans = 0; for (int i = 1; i &lt;= n; i++) { S[i] = i; //初始化，开始时每个村庄都是单独的集 } sort(edge + 1, edge + 1 + m, cmp); for (int i = 1; i &lt;= m; i++) //空格不能多 { int b = find(edge[i].u); //边的前端点u属于哪个集 int c = find(edge[i].v); //边的后端点v属于哪个集 if (b == c) continue; //产生了圈，即环，舍弃这条边 S[c] = b; //合并 ans += edge[i].w; //计算花费 } return ans;}int main(){ while (scanf(\"%d\", &amp;n), n) { m = n * (n - 1) / 2; for (int i = 1; i &lt;= m; i++) //顶点编号从1开始 { scanf(\"%d %d %d\", &amp;edge[i].u, &amp;edge[i].v, &amp;edge[i].w); } printf(\"%d\\n\", kruskal()); } return 0;}","link":"/2019/10/28/最小生成树/"},{"title":"并查集","text":"并查集概述我们来思考一个问题，如果你想知道某个人的boss是谁你会怎么做？ 有些人会说，直接问那个人啊。那如果这个人不知道自己的boss呢？ 聪明的你可能已经想到了，我们可以先询问他在哪个班，然后通过他在的班知道在哪个学院，通过在哪个学院知道它直属的领导是谁。 例如：2018级杭电计算机学院1班 这样分开来找就可以比较快速的找到他们所属的领导 基本用法我们用它的上一层来标记所属的集合，就像形成了一个部门一样。 通过他们的班长，组长，老大，来判断是否在同一个区域 其中，set[i]就是领导，每个成员记住领导就好了 123456789// 合并两堆人，把大的领导变为全部人的领导，小的变为间接领导Merge1(a,b){ i = min(a,b); j = max(a,b); for (k=1; k&lt;=N; k++) { // 整个数组 if (set[k] == j) set[k] = i; }} 改进Q1: background:为什么中央不敢乱动香港，因为台湾没回归啊。如果动了香港的话，就会说明一国两制一点都不好，干脆割裂得了。如果台湾早就回归了的话，一国两制不好那就一国一制 说完屁话之后我们来想一个问题：如果要实现两个国家的合并要怎么办？ 假设我们只要做一件事情，那就是把领导人换了就ok了吧？ 但是问题又来了，我怎么知道这个人的领导是不是习近平啊？简单啊，严刑拷打，把他们的领导是谁全部问一遍 Q2： 只想修改台湾人，但是拷打了整个世界的人 V1： 原来是14亿人直接受习近平管理，那么我在合并树的时候，直接给这个人分配一个老大，那么我不用把每个人都问一遍，我只要问那些老大他们的最终老大是谁，我就知道国家领导人是谁了。 Q3： 老大的数量就是集合的数量，但是如果形成了长链，就是一个老大只管一个人，这样的话，算法退化到$O(n)$ 查找变坏了，因为要查找一条超长的树。 但是合并变好了，比较简单方便 lcy说我可以治好的手，但是腿坏了 v2： 把深度小的合并到深度大的树（确保为树状结构） 随机操作基本也是log级的，数据结构变了导致复杂度变了 Q4 如果我有些信息，其实深度很大，但是我经常要查，而且是经常查那些比较深的，那怎么办 v3： 查找完一个数之后，修改他的老大，这样下次查找可以提高效率，越查找越小 基本操作代码1234567891011121314151617181920212223242526272829303132333435363738#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1050;int s[maxn];int height[maxn];void init_set(){ for(int i = 1; i &lt;= maxn; i++){ s[i] = i; //height[i]=0; 树的高度 }}int find_set(int x){ return x==s[x]?x:find_set(s[x]);}void union_set(int x, int y){ //优化合并操作 x = find_set(x); y = find_set(y); if (x!=y) s[x]=s[y];int main (){ int t, n, m, x, y; cin &gt;&gt; t; while(t--){ cin &gt;&gt; n &gt;&gt; m; init_set(); for(int i = 1; i &lt;= m; i++){ cin &gt;&gt; x &gt;&gt; y; union_set(x, y); } int ans = 0; for(int i = 1; i &lt;= n; i++) //统计有多少个集 if(s[i] == i) ans++; cout &lt;&lt; ans &lt;&lt;endl; } return 0;} 在上面这些操作中 查找，合并的复杂度都是O(n) 性能比较差，因为左边形成了一个很长的链表，出现了树的退化现象 合并的优化在上面的算法中，永远都是一直叠加这样会导致有些链非常长，而有些链会非常短，所以我们就要设置一个高度属性，把比较矮的树，加到比较高的树上面，这样就能减少树的高度 123456789101112131415161718void init_set(){ for(int i = 1; i &lt;= maxn; i++){ s[i] = i; height[i]=0; //树的高度 }}void union_set(int x, int y){ //优化合并操作 x = find_set(x); y = find_set(y); if (height[x] == height[y]) { height[x] = height[x] + 1; //合并，树的高度加一 s[y] = x; } else{ //把矮树并到高树上，高的树的高度不变 if (height[x] &lt; height[y]) s[x] = y; else s[y] = x; }} 路径压缩在查询元素所属的集的时候，每次都要递归寻找最终根节点，但返回的只是上一层根节点，所以搜索路径会很长，如果在某次返回的时候，顺便把i所属的集合改成根节点，下次再搜就可以在O(1)的时间内搜到 递归版1234int find_set(int x){ if(x != s[x]) s[x] = find_set(s[x]); //路径压缩 return s[x];} 非递归版12345678910int find_set(int x){ int r=x; while(s[r]!=r) r=s[r]; int i=x,j; while(i!=r){ j=s[i]; s[i]=r; i=j; }} hdoj 1232畅通工程1234567891011121314151617181920212223242526272829303132333435#include \"stdio.h\"int bin[1002];int findx(int x){ int r = x; while (bin[r] != r) r = bin[r]; return r;}void merge(int x, int y){ int fx, fy; fx = findx(x); fy = findx(y); if (fx != fy) // 没有考虑路径优化的 bin[fx] = fy;}int main(){ int n, m, i, x, y, count; while (scanf(\"%d\", &amp;n), n) { for (i = 1; i &lt;= n; i++) bin[i] = i; for (scanf(\"%d\", &amp;m); m &gt; 0; m--) { scanf(\"%d %d\", &amp;x, &amp;y); merge(x, y); } for (count = -1, i = 1; i &lt;= n; i++) // 在一个分号里面可以初始化多个变量 if (bin[i] == i) count++; printf(\"%d\\n\", count); }} 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1005;int s[maxn];int find(int x){ while (s[x] != x) { x = s[x]; } return x;}void merge(int a, int b){ if (find(a) != find(b)) { s[find(a)] = find(b); // 要更改老大的老大 }}int main(){ int n, m; // for (int i = 0; i &lt; maxn; i++) // { // s[i] = i; // } while (~scanf(\"%d\", &amp;n) &amp;&amp; n) //如果只是输入n为0就结束的话要分开读入 { scanf(\"%d\", &amp;m); for (int i = 0; i &lt; n; i++) { s[i] = i; } // 每次都要重新弄并查集 int a, b; while (m--) { cin &gt;&gt; a &gt;&gt; b; // 开头还想着再循环找一边有几个集合，其实并不用，直接判断老大是否为自己 merge(a - 1, b - 1); } int cnt = -1; for (int i = 0; i &lt; n; i++) { if (s[i] == i) { cnt++; } } cout &lt;&lt; cnt &lt;&lt; endl; }} hdoj 1272 小希的迷宫 不能在全局的地方定义变量的值 然后判断没有路是有两个条件，一个条件是有两个集合，还有一个条件是要连一条边但是这两个结点已经属于同一个集合了 输入 while 1 return 0 while(x||y) if(m== 0 &amp;&amp; n==0) 要更改的是老大的老大 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;stdio.h&gt;#include&lt;algorithm&gt;using namespace std;int A[100001]={0};int find(int x){ int r = x; while(A[r] != r) r = A[r]; return r; } void merge(int a,int b){ int fa = find(a); int fb = find(b); A[fb] = fa; }int main(){ int a,b,flag,i,sum; while(1) { flag = 0; while(~scanf(\"%d%d\",&amp;a,&amp;b) &amp;&amp; a!=0 &amp;&amp; b!=0) { if(a==-1 &amp;&amp; b==-1)return 0; if(A[a]==0)A[a]=a; if(A[b]==0)A[b]=b; if(find(a)==find(b))flag = 1; else if(flag!=1) merge(a,b); } for(sum = 0,i=1;i&lt;=100000;i++) { if(A[i]==i)sum++; A[i] = 0; } if(sum&gt;1 || flag == 1) printf(\"No\\n\"); else printf(\"Yes\\n\"); }} hdoj 1325 IS a tree?1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192/*三个条件：1.不能成环2.不能成树林3.入度小于等于1特判：空树也是树*/#include &lt;iostream&gt;#include &lt;stdio.h&gt;using namespace std;#define MAXN 10005int disjoint[MAXN]; //并查集int indegree[MAXN]; //记录出度int show[MAXN]; //标记出现的点int find(int x) //找根节点{ int t = x; while (disjoint[t] != t) t = disjoint[t]; return t;}int merge(int x, int y) //合并查集(如果在一个集合形成环，则返回0){ int fx = find(x); int fy = find(y); if (fx == fy) return 0; else while (disjoint[fy] != fx) disjoint[fy] = fx; return fx; //如果没有成环，则合并，否则返回0}int main(){ int x, y, count = 1; while (cin &gt;&gt; x &gt;&gt; y &amp;&amp; x &gt;= 0 &amp;&amp; y &gt;= 0) { for (int i = 1; i &lt;= MAXN; i++) //初始化并查集和入度和标记 { indegree[i] = 0; disjoint[i] = i; show[i] = 0; } if (x == 0 &amp;&amp; y == 0) //特判空树 { printf(\"Case %d is a tree.\\n\", count++); continue; } show[x]++; show[y]++; indegree[y]++; merge(x, y); //要注意x，y顺序，因为该树是有方向的 int flag1 = 0, flag2 = 0, flag3 = 0; //分别表示是否成环，是否成树林，是否入度小于等于1 int a, b; while (cin &gt;&gt; a &gt;&gt; b &amp;&amp; a &amp;&amp; b) { if (merge(a, b) == 0) flag1 = 1; //成环 show[a]++; show[b]++; indegree[b]++; } int root = 0; if (flag1 == 1) printf(\"Case %d is not a tree.\\n\", count++); else { for (int j = 1; j &lt; MAXN; j++) { if (show[j] &amp;&amp; disjoint[j] == j) //计算有几个根节点 { root++; if (root &gt; 1) { flag2 = 1; break; } } if (indegree[j] &gt; 1) flag3 = 1; } if (flag2 || flag3) printf(\"Case %d is not a tree.\\n\", count++); else printf(\"Case %d is a tree.\\n\", count++); } } return 0;} 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 5005;int s[maxn];int indegree[maxn];int find(int x){ while (s[x] != x) x = s[x]; return x;}int main(){ int a, b; memset(indegree, 0, sizeof(indegree)); memset(s, 0, sizeof(s)); int flag1 = 0; int flag2 = 0; int flag3 = 0; // 1表示不连通，2表示入度超过1，3表示有环 int num = 1; int cnt = 0; while (~scanf(\"%d %d\", &amp;a, &amp;b)) { if (a &lt; 0 &amp;&amp; b &lt; 0) break; if (a == 0 &amp;&amp; b == 0) { cnt++; for (int i = 1; i &lt;= num; i++) { if (s[i] == i) flag1++; if (indegree[i] &gt; 1) flag2++; } // printf(\"%d %d %d\\n\",flag1,flag2,flag3); if (flag1 &gt; 1 || flag2 &gt; 0 || flag3 &gt; 0) printf(\"Case %d is not a tree.\\n\", cnt); else printf(\"Case %d is a tree.\\n\", cnt); flag1 = 0; flag2 = 0; flag3 = 0; memset(indegree, 0, sizeof(indegree)); memset(s, 0, sizeof(s)); num = 0; continue; } num = max(num, a); num = max(num, b); indegree[b]++; if (s[a] == 0) s[a] = a; if (s[b] == 0) s[b] = b; int fa = find(a); int fb = find(b); //cout&lt;&lt;fa&lt;&lt;endl; //cout&lt;&lt;fb&lt;&lt;endl; if (fa != fb) s[fb] = fa; else flag3++; }} 判断是否为树有几个条件 入度只能为0或者为1 不能形成森林，即不能有超过两个老大 不能形成回路，即要相连的两条边的老大不能是同一个人 hdoj1856 more is better1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 10000005;struct People{ int boss; int height;} people[maxn];int find_set(int x){ if (x != people[x].boss) { people[x].boss = find_set(people[x].boss); } return people[x].boss;}int main(){ int n; while (~scanf(\"%d\", &amp;n)) { if (n == 0) { printf(\"1\\n\"); continue; } int a, b; for (int i = 0; i &lt;= maxn; i++) { people[i].boss = i; people[i].height = 1; } int Max_height = 1; while (n--) { scanf(\"%d %d\", &amp;a, &amp;b); int fa = find_set(a); int fb = find_set(b); if (fa != fb) { people[fa].boss = fb; people[fb].height += people[fa].height; Max_height = max(Max_height, people[fb].height); } //cout&lt;&lt;Max_height&lt;&lt;endl; } printf(\"%d\\n\", Max_height); //cout &lt;&lt; Max_height &lt;&lt; endl; } return 0;} 取函数名字尽量不要是系统的 路径压缩，非递归用while 递归用if 不然会死循环 最小生成树hdoj 1233 还是畅通工程kruscal123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 5005; //数组开小了会超时struct Road{ int a; int b; int d;} road[maxn];int s[maxn];bool cmp(Road a, Road b){ return a.d &lt; b.d;}int find(int x){ while (s[x] != x) { x = s[x]; } return x;}// void merge(int a, int b)// {// s[a] = b;// }int main(){ int n; //struct Road road[maxn]; while (~scanf(\"%d\", &amp;n) &amp;&amp; n) { int num = n * (n - 1) / 2; for (int i = 1; i &lt;= n; i++) { s[i] = i; } for (int i = 1; i &lt;= num; i++) { scanf(\"%d %d %d\", &amp;road[i].a, &amp;road[i].b, &amp;road[i].d); } sort(road + 1, road + 1 + num, cmp); int sum = 0; //int cnt = 0; for (int i = 1; i &lt;= num; i++) { int a = road[i].a; int b = road[i].b; if (find(a) != find(b)) { s[find(a)] = find(b); //merge(find(a), find(b)); sum += road[i].d; //cnt++; } // if (cnt == n) // break; } cout &lt;&lt; sum &lt;&lt; endl; } return 0;} prim算法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;queue&gt;using namespace std;#define INFINITE 900000000struct XEdge{ int v; //边端点 int w; //边权值 XEdge(int v_ = 0, int w_ = INFINITE) : v(v_), w(w_) {}};//vector&lt;int&gt; pt;vector&lt;vector&lt;XEdge&gt;&gt; G(500); //图的邻接表bool operator&lt;(const XEdge &amp;e1, const XEdge &amp;e2){ return e1.w &gt; e2.w;}int HeapPrim(const vector&lt;vector&lt;XEdge&gt;&gt; &amp;G, int n)//G是邻接表,n是顶点数目，返回值是最小生成树权值和{ int i, j, k; XEdge xDist(1, 0); priority_queue&lt;XEdge&gt; pq; vector&lt;int&gt; vDist(n + 1); //各顶点到已经建好的那部分树的距离 vector&lt;int&gt; vUsed(n);//标记顶点是否已经被加入最小生成树 vector&lt;int&gt; vUsed(n + 1); //标记顶点是否已经被加入最小生成树 int nDoneNum = 0; //已经被加入最小生成树的顶点数目 for (i = 0; i &lt;= n; i++) { vUsed[i] = 0; vDist[i] = INFINITE; } nDoneNum = 0; int nTotalW = 0; pq.push(XEdge(1, 0)); while (nDoneNum &lt; n &amp;&amp; !pq.empty()) { do { xDist = pq.top(); pq.pop(); } while (vUsed[xDist.v] == 1 &amp;&amp; !pq.empty()); if (vUsed[xDist.v] == 0) { nTotalW += xDist.w; vUsed[xDist.v] = 1; nDoneNum++; for (i = 0; i &lt; G[xDist.v].size(); i++) { int k = G[xDist.v][i].v; if (vUsed[k] == 0) { int w = G[xDist.v][i].w; if (vDist[k] &gt; w) { vDist[k] = w; pq.push(XEdge(k, w)); } } } } } if (nDoneNum &lt; n) return -1; //图不连通 return nTotalW;}int main(){ int N; int temp; int i, j; int a, b, l; int sum; while (scanf(\"%d\", &amp;N) != EOF) { if (N == 0) break; temp = N * (N - 1) / 2; // 联通图边最多的情况 for (i = 0; i &lt; temp; i++) { scanf(\"%d %d %d\", &amp;a, &amp;b, &amp;l); G[a].push_back(XEdge(b, l)); G[b].push_back(XEdge(a, l)); } sum = HeapPrim(G, N); printf(\"%d\\n\", sum); /*for (i=0;i&lt;500;i++) { G[i].clear(); }*/ G.clear(); G.resize(500); } return 0;} hdoj1875 畅通工程再续12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 105;//已知结点，知道最多的边数为n*n-1/2，但是已知边数的话这个公式没有用int s[1005];struct Edge{ int x; int y;} edge[maxn];struct Island{ int a; int b; double w; bool operator&lt;(Island b) const { return w &lt; b.w; }} island[5005];int find(int x){ while (s[x] != x) x = s[x]; return x;}int main(){ int t; cin &gt;&gt; t; while (t--) { //cout&lt;&lt;t&lt;&lt;endl; // for (int i = 1; i &lt;= 1005; i++) // { // s[i] = i; // } memset(s,0,sizeof(s)); int c; cin &gt;&gt; c; for (int i = 1; i &lt;= c; i++) { scanf(\"%d %d\", &amp;edge[i].x, &amp;edge[i].y); } int cnt = 0; int num = c * (c - 1) / 2; for (int i = 1; i &lt;= c; i++) { for (int j = i + 1; j &lt;= c; j++) { cnt++; island[cnt].a = i; island[cnt].b = j; island[cnt].w = sqrt(pow(edge[i].x - edge[j].x, 2.0) + pow(edge[i].y - edge[j].y, 2.0)); } } sort(island + 1, island + cnt + 1); double sum = 0.0; int flag = 0; for (int i = 1; i &lt;= num; i++) { if(s[island[i].a] == 0) s[island[i].a] = island[i].a; if(s[island[i].b] == 0) s[island[i].b] = island[i].b; int fa = find(island[i].a); int fb = find(island[i].b); if (fa != fb &amp;&amp; island[i].w &gt;= 10 &amp;&amp; island[i].w &lt;= 1000) { s[fa] = fb; sum += island[i].w; } } //cout&lt;&lt;num&lt;&lt;endl; for (int i = 1; i &lt;= c; i++) { //cout&lt;&lt;s[i]&lt;&lt;endl; if(s[i] == i) flag++; } if(flag == 1) printf(\"%.1f\\n\", sum * 100); if(flag != 1 &amp;&amp; t&gt;=1) printf(\"oh!\\n\"); if(flag != 1 &amp;&amp; t==0) printf(\"oh!\"); }} 重载运算符的运用 再查找是否有多个集合的时候，遍历的是边而不是集合 在查找最短边的时候遍历的又是边 如果一开头没有定义每个点的编号的话或者我们要判断是否有多个集合，那么我们要先对set赋值为0，然后再对他循环判断 hdoj 1102 Constructing Road1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 10005;int s[105];struct Road{ int a; int b; int distance; //bool operator&lt;(Road b) const{ return b.distance &lt; distance;}} road[maxn];bool cmp(Road A, Road B){ return A.distance &lt; B.distance;}int find_set(int x){ while (x != s[x]) { x = s[x]; } return x;}int main(){ int n; int Q; while (~scanf(\"%d\", &amp;n) &amp;&amp; n) { for (int i = 1; i &lt;= n; i++) s[i] = i; int cnt = 0; for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= n; j++) { cnt++; road[cnt].a = i; road[cnt].b = j; scanf(\"%d\", &amp;road[cnt].distance); } } cin &gt;&gt; Q; for (int i = 0; i &lt; Q; i++) { int x, y; scanf(\"%d %d\", &amp;x, &amp;y); int fx = find_set(x); int fy = find_set(y); s[fx] = fy; } sort(road + 1, road + 1 + cnt, cmp); int sum = 0; for (int i = 1; i &lt;= cnt; i++) { int fa = find_set(road[i].a); int fb = find_set(road[i].b); if (fa != fb) { s[fa] = fb; sum += road[i].distance; } //怎么融合老大 } cout &lt;&lt; sum &lt;&lt; endl; } return 0; //怎么判断是否联通，} 一个图到每一个点都有边是（n-1）^2, 无向联通图为n*(n-1) 没有理解那个900那些数字是什么意思，其实他想说的是从一点到另一点的距离 两个城市已经修好了路表示这两个点有路径，不用再联通了，或者是联通为0，但是这样会导致用的空间变大 Prim解法招聘都要上亿 自己是一个集合 树联通没有环 n-1条边 最小生成树 顶点都在图里面 现实意义 六个亿是很少的 千岛湖有六个岛屿，六个岛连成一块，理论上可以修十个桥 mst—贪心 kruskal minimum spending 至少存在一颗最小生成树包含最短的边（不断地递归） 没有一颗最小生成树都不包含这个边 只要不在一个集合内就选最短的边 有路没路分两边 修的钱为0 保存图，顶点个数为10000，邻接矩阵比较方便，但是太多了 10000个点两万条边，稀疏 key关键字 迭代器，像下标一样的 重载运算符 string，string字典","link":"/2019/10/21/并查集/"},{"title":"","text":"好孤单，好寂寞（膜） 和鲸提供算力支持 提问笔记闲聊 评论排序方式 jupyter notebook 司玉鑫 – datawhale负责人 人员的地图展示，词云 李沐老师 计算机视觉 https://www.bilibili.com/video/av52684568?from=search&amp;seid=7902974512868946939https://www.bilibili.com/video/av52684568?from=search&amp;seid=7902974512868946939 动手学。。。西瓜书差不多，深度学习，机器学习 入门没那么容易aws的云计算平台 和鲸平台 范晶晶先生为什么做这个 公益还是情怀 打乱了 所有的节奏开始无所事事 aws徐晓公有云服务 动手深入学习李沐 高弹性可扩展 什么东西都是提升自己 未知，未确定的 自己的积累，强大的知识。放平心态提升自己 奖励一块CPU 学习笔记点赞数 企业直推内推 李牧，fellow，机器学习 统计学习方法，西瓜书 先统计学习然后再机器学习 动手学深度学习，focus在代码 楠哥的课 评优不会以队友来的 深度学习就是神经网络变深了，层数变多了会有更多的问题 看达叔的深度学习可以 cs231n 南瓜书是西瓜书的讲解 组织一场ai求职就业的 技术负责人 邱霖 32哥知识点，晚上每天发布三个视频 2.15发布大作业 2道刷分的榜 看最后的性能和report 深度学习把AI变成GDP的技术","link":"/2020/02/11/机器学习开营模式/"},{"title":"","text":"10011234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;bits/stdc++.h&gt;using namespace std;#define rep(i, a, b) for (int i = (a); i &lt;= (b); ++i)#define dep(i, a, b) for (int i = (a); i &gt;= (b); --i)#define pb push_backtypedef long long ll;const int maxn = (int)2e5 + 100;const int mod = (int)1e9 + 7;char str[maxn];int Isspace(int x){ return (x &lt; 'a' || x &gt; 'z') &amp;&amp; (x &lt; 'A' || x &gt; 'Z');}int len;int check(int st){ if (str[st] == 'b') { if (str[st + 1] == 'e') { if (str[st + 2] == 'l') { if (str[st + 3] == 't') { if (st + 4 == len || Isspace(str[st + 4])) return 1; } } } } return 0;}void Solve(){ gets(str); len = strlen(str); rep(i, 0, len - 1) str[i] = tolower(str[i]); rep(i, 0, len - 1) { if (i + 3 &lt; len &amp;&amp; (i == 0 || Isspace(str[i - 1])) &amp;&amp; check(i)) { return (void)puts(\"Yes\"); } } puts(\"No\");}int main(){ int cas; scanf(\"%d\\n\", &amp;cas); while (cas--) Solve();} gets的使用 strlen的使用 str[i] !=’\\0’ tolower 1002123456789101112131415161718192021222324252627282930313233343536373839#include &lt;bits/stdc++.h&gt;using namespace std;#define rep(i, a, b) for (int i = (a); i &lt;= (b); ++i)#define dep(i, a, b) for (int i = (a); i &gt;= (b); --i)#define pb push_backtypedef long long ll;const int maxn = (int)2e5 + 100;const int mod = (int)1e9 + 7;int n;struct node{ int s, t; bool operator&lt;(node b) const { return s &gt; b.s; }} q[maxn];int vis[maxn];void solve(){ int mx = 0; rep(i, 1, n) { scanf(\"%d%d\", &amp;q[i].t, &amp;q[i].s); mx = max(mx, q[i].t); } rep(i, 1, mx) vis[i] = 0; sort(q + 1, q + 1 + n); ll res = 0; rep(i, 1, n) dep(j, q[i].t, 1) if (!vis[j]) { vis[j] = 1; res += q[i].s; break; } printf(\"%lld\\n\", res);}int main(){ while (~scanf(\"%d\", &amp;n)) solve();} 10071234567891011121314151617181920212223242526272829#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,a,b) for(int i=(a);i&lt;=(b);++i)#define dep(i,a,b) for(int i=(a);i&gt;=(b);--i)#define pb push_backtypedef long long ll;const int maxn=(int)2e5+100;const int mod=(int)1e9+7;char s[2200];int len;void solve(){ int ans=0; scanf(\"%s\",s+1); len=strlen(s+1); rep(i,1,len){ int tmp=0; rep(j,i,len){ tmp=(tmp*10+(s[j]-'0'))%8; if(tmp%8==0) ans++; } } printf(\"%d\\n\",ans);}int main(){ int T;cin&gt;&gt;T; while(T--) solve(); } 1234/8 和 434/8 所得的余数是一样的 1010123456789101112131415161718192021222324#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,a,b) for(int i=(a);i&lt;=(b);++i)#define dep(i,a,b) for(int i=(a);i&gt;=(b);--i)#define pb push_backtypedef long long ll;const int maxn=(int)2e5+100;const int mod=(int)1e9+7;void solve(){ int n,m;scanf(\"%d%d\",&amp;n,&amp;m); int tmp=0,ans=0; rep(i,1,n){ tmp=tmp*10%9+m; if(tmp%9==0) ans=max(ans,i); } if(ans==0) puts(\"-1\"); else{ rep(i,1,ans) printf(\"%d\",m); puts(\"\"); }}int main(){ int T;cin&gt;&gt;T; while(T--) solve(); }","link":"/2019/11/24/杭电校赛自写题解/"},{"title":"","text":"1001 qw的字符串1234567891011121314151617181920212223242526272829303132Time Limit: 3000/1000 MS (Java/Others) Memory Limit: 65535/32768 K (Java/Others)Total Submission(s): 0 Accepted Submission(s): 0Problem Descriptionqw是杭电ACM集训队实力非常强的一位选手，他喜欢思考各种各样的算法题。qw很喜欢\"belt\"这个单词，希望你能在下面这个问题帮帮他。给定一个字符串（只包含大小写字母和空格），如果包含独立的单词 \"belt\"（不区分大小写，不能作为某个单词的子串），则输出 \"Yes\"，否则输出 \"No\"。 Input第一行一个正整数T，代表有T组数据。(1≤T≤100)接下来T行，每行一个字符串，只包含大小写字母和空格，其中字符串长度不大于1000。提示：单词间可能有多个空格，也可能存在首尾空格 Output输出T行，代表T组数据的结果。如果字符串包含独立的单词 \"belt\"，输出 \"Yes\"。否则输出 \"No\" Sample Input3There iS A beLT A belt is over thereI will run mybelt Sample OutputYesYesNo 1002 s10的面试12345678910111213141516171819202122232425262728293031323334353637383940Time Limit: 3000/1000 MS (Java/Others) Memory Limit: 65535/32768 K (Java/Others)Total Submission(s): 0 Accepted Submission(s): 0Problem Descriptions10曾经是一位ACM集训队的同学，实力强劲，秒天秒地。面临毕业的他正在找工作，最近有n个公司向s10发出了面试邀请！但s10每天只想参加一场面试。对于第i个公司的面试，会有一个最晚面试时间ti，s10心中对于这个公司也会有一个自己的打分si。因为简历投的多，s10拥有大量的面试机会，现在s10希望通过合理安排面试，使得参与面试的公司总分最大，你能帮帮他吗？提示：1. 可以面试的最早时间为第1天，最晚时间为第n天。2. 对于第i个公司，如果错过了最晚面试时间ti，即第ti+1天及以后，则不能再参加该公司的面试。3. 每天最多只能选择参加一场面试，每场面试均能当天结束，不会影响后面天数的选择。 Input多组数据每组数据第一行一个正整数n (n≤1000)接下来n行，每行2个正整数ti, si (1≤ti,si≤1000) Output每组数据输出占一行，输出s10的最大总分 Sample Input74 202 604 703 401 304 506 10 Sample Output230 1003 s10的游戏王卡牌1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071Time Limit: 3000/1000 MS (Java/Others) Memory Limit: 65535/32768 K (Java/Others)Total Submission(s): 0 Accepted Submission(s): 0Problem Description最近s10迷上了一款叫《游戏王》的卡牌游戏，简单的介绍一下这一款游戏的规则：1. 卡牌分成魔法卡和怪兽卡两种2. 魔法卡能直接摧毁对方场上的一只怪兽3. 怪兽卡拥有攻击力A和星级S4. 每回合玩家可以将手牌中的一只怪兽召唤到场上，召唤方式有三种：4.1. 直接召唤一只4星级及以下的怪兽4.2. 牺牲一只己方场上的怪兽，召唤一只5-6星级的怪兽4.3. 牺牲两只己方场上的怪兽，召唤一只7-8星级的怪兽5. 已经被召唤的怪兽将从手牌中扣除，被破坏/牺牲的场上怪兽将会被移出游戏s10向卡牌大师qw发起了挑战，s10手中有n张怪兽卡，第i只怪兽的攻击力为Ai，星级为Si，而qw手中有m张魔法卡。qw对s10这个新手很不屑，并表示在前k回合里他都不会使用魔法卡。而在k回合后，qw会一口气用掉所有魔法卡，破坏掉s10场上攻击力最高的m个怪兽。而s10的任务就是在前k回合合理召唤怪兽，使得qw用掉魔法卡后，己方场上剩余的怪兽中攻击力最高的那只的攻击力尽量大请问如果s10足够聪明，那么那只剩余下来后攻击力最高的怪兽的攻击力是多少？(如果s10所有怪兽都会被破坏/牺牲，那么输出0) Input多组输入每组数据第一行给定正整数n,m,k接下来n行，每行两个整数Ai和Si数据范围:0≤Ai≤500001≤Si≤81≤n,m≤100k≤120 Output对于每个测试实例，请输出s10最后攻击力最高的怪兽的攻击力，每个实例的输出占一行。 Sample Input6 2 10500 1500 11500 4900 22000 53000 73 2 5500 1700 21900 53 2 2500 1700 2700 33 1 2500 1700 2700 3 Sample Output150000700 1004 s10的加号求和1234567891011121314151617181920212223242526272829303132333435363738394041Time Limit: 3000/1000 MS (Java/Others) Memory Limit: 65535/32768 K (Java/Others)Total Submission(s): 0 Accepted Submission(s): 0Problem Description给定一个长度为n的数字字符串，现在有m个加号需要被插入到这个字符串里，使其成为一个合法的表达式。请求出所有的合法表达式的运算结果之和！因为数据量太大，最后结果只需要对1000000007取模输出就行。合法表达式的规则如下：1. 加号不能被放在开头或结尾。2. 两个加号之间至少要有一个数字。举例：给定字符串\"50050\"，加号数量为2，那么，\"5+00+50\", \"50+0+50\"等均合法的，但 \"500++50\", \"+500+50\", \"500+50+\"这些是非法的。 Input多组数据。每组数据有两行，第一行有两个整数n和m (0≤m&lt;n≤105)，第二行为长度为n的数字字符串。 Output每组数据输出一行，输出所有的合法表达式的运算结果的总和。因为结果太大，只需要输出答案对1000000007取模输出即可。 Sample Input3 11083 21085 3 100083 0100 Sample Output27945100 1005 77姐的保研之路1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859Time Limit: 3000/1000 MS (Java/Others) Memory Limit: 65535/32768 K (Java/Others)Total Submission(s): 0 Accepted Submission(s): 0Problem Description77姐已经大三了，表示不能向菜鸡czy学习，要向杭电优秀学子dxh学习，保研清华。竞争保研资格需要计算每位同学的保研分数，择高录取，其计算方法为：保研分数 = 平均学分绩点 * 100 + 专业课平均分 * 0.7 + 竞赛加分 * 0.2 + 综合素质分。现在给定77姐每门课的情况（课程分数，课程学分，是否为专业课）、竞赛加分、综合素质分和今年的保研录取分数线，计算77的保研分数能否成功保研（保研分数大于等于录取线分数）？如果能，输出\"Yes\"，否则输出\"No\"。说明：1. 专业课平均分为所有专业课的总分数除以专业课数量。2. 平均学分绩点的计算方式为：将所有课程分数（百分制）转换为绩点（满绩点5.0），对所有课的绩点乘以其学分权重的乘积求和，再除以总学分。举例：比如你一共修了两门课，一门是程序设计基础，绩点是4.5，学分是4。一门是体育课，绩点是3，学分是1。那么你的平均学分绩点是：（4.5*4+3*1）/（4+1）=4.2其中课程分数与绩点的转换关系如下：95-100分：5.060分及以上且94分及以下则计算方式为：假设分数为X，则绩点为(X - 45) / 10。例如：分数为94分，则绩点为（94-45）/10=4.9 Input第一行给出一个正整数T，表示数据组数。每组数据，第一行给出两个正整数n和K，分别表示77姐的课程的数量和保研录取分数线。接下来n行，每行给出三个正整数x,y,z，分别表示课程分数，课程学分和是否是专业课（z=1表示当前课程是专业课程，z=0表示为普通课程）。随后一行两个非负整数u，v，分别代表77姐的竞赛加分和综合素质分数。专业核心课的数量保证至少为1，保证77姐无不及格的课程。数据范围：n≤100;K≤600;60≤x≤100;y≤5;u≤100,v≤10z= 0或1 Output对于每组数据，如果77姐能保研输出 \"Yes\"，否则输出 \"No\"。 Sample Input32 50090 4 175 1 050 102 51090 4 175 1 050 102 51090 4 180 1 050 10 Sample OutputYesNoYes 1006 s10的红黑树12345678910111213141516171819202122232425262728293031323334353637383940414243Time Limit: 3000/1000 MS (Java/Others) Memory Limit: 65535/32768 K (Java/Others)Total Submission(s): 0 Accepted Submission(s): 0Problem Description众所周知，红黑树是一种优秀的数据结构，是每个节点都带有颜色属性（红色或者黑色）的二叉查找树。这道题也是关于树上的问题，但是与之不同的是，是每条边有颜色属性，其值为红色或者黑色。现在有一棵树（无环的无向图），树上有n个节点，n−1条无向边，每条边是红色或者黑色。同时给定一个正整数k，我们定义序列 a1,a2,…,ak为 \"s10序列\"当且仅当其满足以下条件：我们从节点a1开始选择最短的路径到节点a2，再从节点a2开始选择最短的路径到节点a3，依次类推，直到我们从节点ak−1走到节点ak。如果我们走过的所有路径中经过的边，有至少一条黑色边的话， 那么就称其为”s10序列”。（注意其中对于序列中的不同ai的取值可以重复）显然对于n个节点的树，给定正整数k，我们可以有nk个序列。我们现在需要统计其中有多少序列是“S10序列”。答案可能会很大，请输出答案对1000000007取模的结果。 Input第一行给出一个正整数T，表示数据组数。接下来对于每组数据，第一行给出两个正整数n和k，分别表示这棵树的节点个数和“S10序列”的长度。接下来n−1行，每行给出三个正整数x,y,v，分别表示树中一条边的两个节点和边的颜色（0表示红色，1表示黑色）。数据范围：k≤n≤2000001≤x,y≤n (x 不等于 y)v= 0或1 Output对于每组数据，输出“s10序列”的数量对1000000007取模的结果。 Sample Input34 41 2 12 3 13 4 12 21 2 13 21 2 13 2 0 Sample Output25224 1007 77姐的子串12345678910111213141516171819202122232425262728293031323334353637383940Time Limit: 3000/1000 MS (Java/Others) Memory Limit: 65535/32768 K (Java/Others)Total Submission(s): 0 Accepted Submission(s): 0Problem Description77姐特别喜欢字符串！而且特别喜欢数字\"8\"!作为新生班助，她要交给新生们一个任务，让他们在给定的数字串中，数一数有多少这个数字串的子串，满足条件：该子串所表示的数，是8的倍数。（小提示：8的倍数满足除以8的余数为0）其中保证数字串不含数字 \"0\"，只含数字 \"1\"~\"9\"。注：子串指字符串中连续若干个字符组成的字符串。如 \"abc\"的所有子串为\"a\",\"b\",\"c\",\"ab\",\"bc\",\"abc\"。而数字串的每一位都是一个数字。 Input第一行给定一个整数T，表示有T组数据。对于每组数据，给出一个数字字符串s。（仅包含数字1-9）数据范围：T≤10|s|≤2000|s|指字符串s的长度 Output对于每组数据，输出一个整数，表示满足题目条件的该数字串的子串的数量。 Sample Input412341888888 Sample Output0713 1008 qw的粉丝1234567891011121314151617181920212223242526272829Time Limit: 3000/1000 MS (Java/Others) Memory Limit: 65535/32768 K (Java/Others)Total Submission(s): 0 Accepted Submission(s): 0Problem Descriptionqw是全民K歌的知名歌手，在杭电有着众多的粉丝。某一天，qw想要正式成立自己的粉丝后援会，需要招收管理人员，于是他在杭电表白墙上发布了信息。一共有n个人报名面试。面试必须按照报名的顺序依次进行。qw可以选择在面试完若干个粉丝以后，在所有已经面试过的粉丝中任意挑选，组建粉丝后援会管理团队。但qw对于管理团队有着一个奇怪的要求，他希望组建的团队至少有m名粉丝，且这些粉丝的最高身高和最低身高之差不超过k个长度单位。现在已知粉丝的身高信息，qw至少要面试多少个粉丝才能在已经面试过的粉丝中选出不少于m个人组建管理团队。 Input第一行一个整数T，表示有T组输入数据。 (T≤10)每组数据第一行3个整数n,m,k，意义见题面描述，其中 1≤m≤n≤1e5;0≤k≤1e5第二行n个整数，第i个整数hi表示第i个报名面试的粉丝身高。1≤hi≤1e5 Output如果可以选出管理团队，输出最少需要面试的人数。否则输出 \"impossible\" Sample Input16 3 5170 169 175 171 180 175 Sample Output4 1009 qw的异或游戏12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849Time Limit: 3000/1000 MS (Java/Others) Memory Limit: 65535/32768 K (Java/Others)Total Submission(s): 7 Accepted Submission(s): 7Problem Descriptionqw发明了一个有趣的异或游戏：游戏会给定n个非负整数，第i个数的值为ai，另外给定一个非负整数m，如果能找到任意一个非负整数k，满足：(a1 xor k)+(a2 xor k)+...+(an xor k)≤m则称该异或游戏是完美的。现在qw的问题是，对于一个异或游戏，如果它是完美的游戏，那么k最大可以为多少？如果不存在合法的k，则输出-1。提示：异或是一种位运算，两个数异或，应先将两个数转成二进制，从低到高，按位运算，如果当前位两个数不同，则值为1，否则为0。 Input第一行给定一个整数T，表示有T组数据。每组数据有两行，第一行有两个整数n,m，意义见题目描述，第二行有n个整数，第i个整数的值为ai。数据范围：1≤T≤101≤N≤10000≤M≤1e60≤Ai≤1000 Output对于每组数据，输出k的最大值，如果不存在合法的k，则输出-1 Sample Input43 278 2 44 4530 0 4 111 01006 25 5 1 5 1 0 Sample Output1214100-1 1010 s10的卡片123456789101112131415161718192021222324252627282930313233343536373839Time Limit: 3000/1000 MS (Java/Others) Memory Limit: 65535/32768 K (Java/Others)Total Submission(s): 0 Accepted Submission(s): 0Problem Descriptions10现在有n张相同的卡片，卡片的值均为m (1≤m≤9) 。现在s10想用这些卡片拼成一个新的数（可以只取一部分），并希望这个数能被9整除。如果能，请输出最大可以拼成的数，否则输出\"-1\"。举例：如果有8张值为6的卡片，可以：1. 取3张拼成666，可以被9整除2. 取6张拼成666666，可以被9整除因为取6张的值大于取3张的值，故输出666666 Input第一行，给出一个正整数T,表示数据组数。接下来对于每组数据，给出两个正整数n 和 m ，分别表示卡片的张数和卡片上的数字。取值范围：1≤n≤10001≤m≤9 Output对于每组数据，输出一个整数，表示用这些卡片最大可以拼成的被9整除的数。如果不能，则输出 “-1”。 Sample Input49 51 210 24 3 Sample Output555555555-1222222222333 596382","link":"/2019/11/23/杭电校赛题面/"},{"title":"","text":"1001123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;bits/stdc++.h&gt;#define vi vector&lt;int&gt;#define pii pair&lt;int, int &gt;#define mp make_pair#define fi first#define se second#define pb push_back#define LL long longusing namespace std;const int INF=0x3f3f3f3f,N=2e6+5,MOD=1e9+7;char str[N];int lower(int x){ if(x&gt;='A'&amp;&amp;x&lt;='Z')x=x-'A'+'a'; return x;}int Isspace(int x){ return (x&lt;'a'||x&gt;'z')&amp;&amp;(x&lt;'A'||x&gt;'Z');}int len;int check(int st){ if(lower(str[st])=='b'){ if(lower(str[st+1])=='e'){ if(lower(str[st+2])=='l'){ if(lower(str[st+3])=='t'){ if(st+4==len || Isspace(str[st+4])) return 1; } } } } return 0;}int Solve(){ gets(str); len=strlen(str); for(int i=0;i&lt;len;i++){// cout&lt;&lt;i&lt;&lt;\" #\"&lt;&lt;str[i]&lt;&lt;\"#\"&lt;&lt;endl; if(i+3&lt;len&amp;&amp;(i==0||Isspace(str[i-1]))&amp;&amp;check(i)){ puts(\"Yes\"); return 0; } } puts(\"No\");// exit(0); return 0;}void Pre(){}int main() {#ifndef ONLINE_JUDGE freopen(\"in.txt\",\"r\",stdin);// freopen(\"o1.txt\",\"w\",stdout);#endif// ios::sync_with_stdio(false);cin.tie(0),cout.tie(0); Pre(); int cas; scanf(\"%d\\n\",&amp;cas); while(cas--)Solve(); return 0;} 1002123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;bits/stdc++.h&gt;#define vi vector&lt;int&gt;#define pii pair&lt;int, int &gt;#define mp make_pair#define fi first#define se second#define pb push_back#define LL long longusing namespace std;const int INF=0x3f3f3f3f,N=2e6+5,MOD=1e9+7;struct node{ int s,t; friend bool operator&lt;(node a,node b){ return a.s&gt;b.s; }}q[N];int vis[N];int Solve(){ int n; if(!(cin&gt;&gt;n))return 0; int maxn=0; for(int i=1;i&lt;=n;i++){ cin&gt;&gt;q[i].t&gt;&gt;q[i].s; maxn=max(maxn,q[i].t); } for(int i=1;i&lt;=maxn;i++)vis[i]=0; sort(q+1,q+1+n); LL res=0; for(int i=1;i&lt;=n;i++){ for(int j=q[i].t;j&gt;=1;j--){ if(!vis[j]){ vis[j]=1; res+=q[i].s; break; } } } cout&lt;&lt;res&lt;&lt;endl; return 1;}void Pre(){}int main() {#ifndef ONLINE_JUDGE freopen(\"in.txt\",\"r\",stdin);// freopen(\"o1.txt\",\"w\",stdout);#endif ios::sync_with_stdio(false);cin.tie(0),cout.tie(0); Pre(); while(Solve()); return 0;} 1003123456789101112131415161718192021222324252627282930313233343536#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;vector&lt;int&gt; a,b,c;int n,m,k;int main(){ while(scanf(\"%d %d %d\",&amp;n,&amp;m,&amp;k)!=EOF){ a.clear(); b.clear(); c.clear(); for(int i=1,j,p;i&lt;=n;++i){ scanf(\"%d %d\",&amp;j,&amp;p); if(p&lt;=4) a.push_back(j); else if(p&lt;=6) b.push_back(j); else if(p&lt;=8) c.push_back(j); } int ans=0; sort(a.begin(),a.end()); sort(b.begin(),b.end()); sort(c.begin(),c.end()); for(int i=0;i&lt;=a.size();++i){ for(int j=0;j&lt;=b.size();++j){ int p=m+1-i-j; if(p*2+j*1+i&gt;a.size()) continue; if(p*3+j*2+i&gt;k) continue; if(p&lt;0||p&gt;c.size()) continue; int q=1000000; //printf(\"%d %d %d\\n\",i,j,p); if(i) q=min(q,a[a.size()-i]); if(j) q=min(q,b[b.size()-j]); if(p) q=min(q,c[c.size()-p]); ans=max(ans,q); } } printf(\"%d\\n\",ans); }} 1004123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;typedef long long ll;const int N = 1e5+100;const ll MOD = 1e9+7;ll f[N],g[N],bs[N],k[N];char s[N]; int a[N],n,m;ll fpow(ll x,ll p){ ll res=1; while(p){ if(p%2==1) res=res*x%MOD; x=x*x%MOD; p&gt;&gt;=1; } return res;}ll C(int n,int m){ return f[n]*g[n-m]%MOD*g[m]%MOD;}int main(){ f[0]=1; bs[0]=1; for(int i=1;i&lt;N;++i) f[i]=f[i-1]*i%MOD; g[N-1]=fpow(f[N-1],MOD-2); for(int i=N-2;i&gt;=0;--i) g[i]=g[i+1]*(i+1)%MOD; for(int i=1;i&lt;N;++i) bs[i]=bs[i-1]*10%MOD; while(scanf(\"%d%d\",&amp;n,&amp;m)!=EOF){ scanf(\"%s\",s+1); ll ans=0; k[0]=0; for(int i=1;i&lt;=n-m+1;++i){ k[i]=bs[i-1]*C(n-1-i,m-1)%MOD; //printf(\"%d\\n\",k[i]); k[i]+=k[i-1]; k[i]%=MOD; //printf(\"%d %lld\\n\",i,k[i]); } for(int i=1;i&lt;=n;++i) a[i]=s[i]-'0'; for(int i=n;i&gt;m;--i) ans+=a[i]*bs[n-i]*C(i-1,m)%MOD; for(int i=1;i&lt;=n;++i){ ans+=a[i]*k[min(n-m+1,n-i)]; //printf(\"%d %d %lld\\n\",a[i],min(n-m+1,n-i),k[min(n-m+1,n-i)]); ans%=MOD; } printf(\"%lld\\n\",ans); }} 100512345678910111213141516171819202122232425262728293031#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,a,b) for(int i=(a);i&lt;=(b);++i)#define dep(i,a,b) for(int i=(a);i&gt;=(b);--i)#define pb push_backtypedef long long ll;const int maxn=(int)2e5+100;const int mod=(int)1e9+7;double fun(int x){ if(x&gt;=95) return 5.0; return (x-45)*1.0/10;}void solve(){ int n,k;scanf(\"%d%d\",&amp;n,&amp;k); int sum=0,num=0; double sum1=0,num1=0; rep(i,1,n){ int x,y,z;scanf(\"%d%d%d\",&amp;x,&amp;y,&amp;z); if(z==1){ sum+=x;num++; } sum1+=fun(x)*y;num1+=y; } int u,v;scanf(\"%d%d\",&amp;u,&amp;v); double ans=sum*1.0/num*0.7+sum1/num1*100+u*0.2+v; puts(ans&gt;=k?\"Yes\":\"No\");}int main(){ int T;cin&gt;&gt;T; while(T--) solve(); } 10061234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;bits/stdc++.h&gt;#define vi vector&lt;int&gt;#define pii pair&lt;int, int &gt;#define mp make_pair#define fi first#define se second#define pb push_back#define LL long longusing namespace std;const int INF=0x3f3f3f3f,N=2e5+5,MOD=1e9+7;vi G[N];void addedge(int u,int v){ G[u].pb(v),G[v].pb(u);}int vis[N];void dfs(int x,int _fa,int &amp;siz){ vis[x]=1,siz++; for(auto v:G[x])if(v!=_fa){ dfs(v,x,siz); }}LL qpow(LL a,LL b){ LL ret=1; for(;b;b&gt;&gt;=1,a=a*a%MOD) if(b&amp;1)ret=ret*a%MOD; return ret;}int Solve(){ int n,k; cin&gt;&gt;n&gt;&gt;k; for(int i=1;i&lt;n;i++){ int u,v,w; cin&gt;&gt;u&gt;&gt;v&gt;&gt;w; if(!w)addedge(u,v); } LL res=qpow(n,k); for(int i=1;i&lt;=n;i++){ if(!vis[i]){ int siz=0; dfs(i,0,siz); res=(res-qpow(siz,k)+MOD)%MOD; } } cout&lt;&lt;res&lt;&lt;endl; for(int i=1;i&lt;=n;i++)vis[i]=0,G[i].clear(); return 0;}void Pre(){}int main() {#ifndef ONLINE_JUDGE freopen(\"in.txt\",\"r\",stdin);// freopen(\"o1.txt\",\"w\",stdout);#endif ios::sync_with_stdio(false);cin.tie(0),cout.tie(0); Pre(); int cas; cin&gt;&gt;cas; while(cas--)Solve(); return 0;} 1007123456789101112131415161718192021222324252627#include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,a,b) for(int i=(a);i&lt;=(b);++i)#define dep(i,a,b) for(int i=(a);i&gt;=(b);--i)#define pb push_backtypedef long long ll;const int maxn=(int)2e5+100;const int mod=(int)1e9+7;char s[2200];int len;void solve(){ int ans=0; scanf(\"%s\",s+1); len=strlen(s+1); rep(i,1,len){ int tmp=0; rep(j,i,len){ tmp=(tmp*10+(s[j]-'0'))%8; if(tmp%8==0) ans++; } } printf(\"%d\\n\",ans);}int main(){ int T;cin&gt;&gt;T; while(T--) solve(); } 1008123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;bits/stdc++.h&gt;#define vi vector&lt;int&gt;#define pii pair&lt;int, int &gt;#define mp make_pair#define fi first#define se second#define pb push_back#define LL long longusing namespace std;const int INF=0x3f3f3f3f,N=2e6+5,MOD=1e9+7;int n,m,k;int max_height=0,sum[N],h[N];int check(int mid){ for(int i=1;i&lt;=max_height;i++)sum[i]=0; for(int i=1;i&lt;=mid;i++) sum[h[i]]++; for(int i=1;i&lt;=max_height;i++)sum[i]+=sum[i-1]; for(int i=1;i&lt;=max_height;i++){ int up=min(i+k,max_height); if(sum[up]-sum[i-1]&gt;=m)return 1; } return 0;}int Solve(){ cin&gt;&gt;n&gt;&gt;m&gt;&gt;k; max_height=0; for(int i=1;i&lt;=n;i++){ cin&gt;&gt;h[i]; max_height=max(max_height,h[i]); } int l=1,r=n,mid,ans=-1; while(l&lt;=r){ mid=(l+r)&gt;&gt;1; if(check(mid))ans=mid,r=mid-1; else l=mid+1; } if(~ans)cout&lt;&lt;ans&lt;&lt;endl;else cout&lt;&lt;\"impossible\"&lt;&lt;endl; return 0;}void Pre(){}int main() {#ifndef ONLINE_JUDGE// freopen(\"in.txt\",\"r\",stdin);// freopen(\"o1.txt\",\"w\",stdout);#endif ios::sync_with_stdio(false);cin.tie(0),cout.tie(0); Pre(); int cas; cin&gt;&gt;cas; while(cas--)Solve(); return 0;} 10091234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int a[21];ll ans=-1;int b[21];int n,m;void dfs(int i,ll tmp,ll sum){ if(sum&gt;m)return; if(i&gt;=0){ dfs(i-1,tmp+b[i],sum+b[i]*(n-a[i])); dfs(i-1,tmp,sum+b[i]*a[i]); } if(i==-1){ ans=max(ans,tmp); }}int main(){ b[0]=1; for(int i=1;i&lt;=21;i++){ b[i]=b[i-1]*2; } int T; scanf(\"%d\",&amp;T); while(T--){ scanf(\"%d%d\",&amp;n,&amp;m); ans=-1; memset(a,0,sizeof(a)); for(int i=1;i&lt;=n;i++){ int b; scanf(\"%d\",&amp;b); int cnt=0; while(b){ if(b&amp;1)a[cnt]++; b/=2; cnt++; } } dfs(10,0,0); printf(\"%lld\\n\",ans); }} 101012345678910111213141516171819202122232425262728293031323334353637383940#include &lt;bits/stdc++.h&gt;#define vi vector&lt;int&gt;#define pii pair&lt;int, int &gt;#define mp make_pair#define fi first#define se second#define pb push_back#define LL long longusing namespace std;const int INF=0x3f3f3f3f,N=2e6+5,MOD=1e9+7;int Solve(){ int n,m; cin&gt;&gt;n&gt;&gt;m; int now=0,ans=0; for(int i=1;i&lt;=n;i++){ now=now*10+m;now%=9; if(now==0)ans=i; } if(!ans)cout&lt;&lt;-1&lt;&lt;endl; else { for(int i=1;i&lt;=ans;i++)cout&lt;&lt;m; cout&lt;&lt;endl; } return 0;}void Pre(){}int main() {#ifndef ONLINE_JUDGE// freopen(\"in.txt\",\"r\",stdin);// freopen(\"o1.txt\",\"w\",stdout);#endif ios::sync_with_stdio(false);cin.tie(0),cout.tie(0); Pre(); int cas; cin&gt;&gt;cas; while(cas--)Solve(); return 0;}","link":"/2019/11/23/杭电校赛题解/"},{"title":"","text":"不加惩罚和补贴","link":"/2020/01/20/第八次会议/"},{"title":"","text":"解决搜索用不了的问题 1Get-AppXPackage -Name Microsoft.Windows.Cortana | Foreach {Add-AppxPackage -DisableDevelopmentMode -Register \"$($_.InstallLocation)\\AppXManifest.xml\"}","link":"/2020/02/06/电脑平时技巧/"},{"title":"算法竞赛入门与进阶","text":"算法竞赛入门与进阶输入与输出12while(~scanf(\"%d %d\",&amp;a,&amp;b) &amp;&amp; n) //在以特定元素作为结束符号的时候 cin and cout is slowly especially when you want to read many data struct the test data in a team ,we usually arrange a team member to test tthe data here is a example to set the test data 12345#define mytest#ifdef mytest freopen(\"text.in\",\"r\",stdin); freopen(\"text.out\",\"w\",stdout);#end if still confused read the data at first, then read the article get familier to the ide such as “vim” or the code blocks The types of the probelm Ad hoc Complete search(iterative/recursive) Divide and conquer Greedy Dynamic programming Graph Mathematics String processing Computational geometry Some harder Style of codinguse the K&amp;R you had better not to use “define” or to use const int manx=100005;","link":"/2019/10/06/算法竞赛入门与进阶/"},{"title":"数据结构---线性表","text":"线性表的分类线性表的定义： 线性表是具有n个数据元素（可以是字符，整型等等）的有限序列（不一定有序） 顺序存储 链式存储 特点 必须占用一片连续的空间，也就是连续的地址 优点 存储密度大 插入，删除运算方便 链表链表的分类静态链表 动态链表 单链表 双链表 单循环链表：最后一个结点又会指回来 双循环链表 是否含有头节点的链表 是否含有尾指针的链表：有一个指针，指着最后面","link":"/2019/11/21/线性表/"},{"title":"","text":"差分数组与前缀和 前缀和前缀和顾名思义就是前面i个数的总和。假设有一个序列A，前缀和为S。根据概念很容易知到公式S[i]=∑j=1iA[j]S[i]=∑j=1iA[j] 如何求区间[l,r][l,r]的和呢？sum[l,r]=s[r]−s[l−1]sum[l,r]=s[r]−s[l−1] 那如果要对多个不同区间 [l,r][l,r]进行加减操作呢？然后输出某个区间[l,r][l,r]的区间和,接下来就要用到差分数组了 差分数组 设原数组为A[i]A[i],差分数组为B[i]B[i],则： B[i]={A[i]A[i]−A[i−1]i=1i≥2B[i]={A[i]i=1A[i]−A[i−1]i≥2 差分数组的性质： 如果对区间[l,r][l,r]进行修改，只需修改B[l],B[r+1]B[l],B[r+1](B[l]B[l]加上修改值，B[r+1]B[r+1]减去修改值） A[i]=∑j=1iB[j]A[i]=∑j=1iB[j]（通过B[i]=A[i]−A[i−1]B[i]=A[i]−A[i−1]证明） S[x]=∑i=1xA[i]=∑i=1x∑j=1iB[j]=∑i=1x(x−i+1)∗B[i]S[x]=∑i=1xA[i]=∑i=1x∑j=1iB[j]=∑i=1x(x−i+1)∗B[i] 有n个数。m个操作,每一次操作，将x~y区间的所有数增加z； 最后有q个询问，每一次询问求出x~y的区间和。 设原数组为A[i] 步骤： 先求出差分数组B[i]=A[i]−A[i−1]B[i]=A[i]−A[i−1] 在根据mm个造作修改B[i]B[i] 求修改后的A[i]=A[i−1]+B[i]A[i]=A[i−1]+B[i] 求前缀和S[i]=S[i−1]+A[i]S[i]=S[i−1]+A[i] 最后输出区间和sum[x,y]=S[y]−S[x−1] bzoj 激光炸弹一开始我还想用dp，但是dp循环的话明显会超时 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;/** 一维前缀和：sum[i] = sum[i - 1] + arr[i] 那么我们讨论下二维的前缀和 sum[i][j] = sum[i - 1][j] + sum[i][j - 1] - sum[i - 1][j - 1] + arr[i][j] 含义是少一行的前缀和 + 少一列的前缀和 因为这两个相加会有重复的区间 即sum[i - 1][j - 1] 那么减去一个sum[i - 1][j - 1],只有arr[i][j]没有加入，那么加入arr[i][j]即更新完二维 的前缀和 接下来是空间为r的正方形的枚举，那么sum[i][j] - sum[i - r][j] - sum[i][j - r] + sum[i - r][j - r] 这样就成功枚举了长度为r的正方形 **/const int MAXN = 5000 + 5;int sum[MAXN][MAXN];void Init(){ memset(sum, 0, sizeof(sum));}int n, r, x_max, y_max;int main(){ scanf(\"%d%d\", &amp;n, &amp;r); x_max = y_max = r; Init(); for(int i = 0; i &lt; n; i ++) { int x, y, w; scanf(\"%d%d%d\", &amp;x, &amp;y, &amp;w); x ++; y ++; sum[x][y] += w; x_max = max(x_max, x); y_max = max(y_max, y); } for(int i = 1; i &lt;= x_max; i ++) { for(int j = 1; j &lt;= y_max; j ++) { sum[i][j] = sum[i - 1][j] + sum[i][j - 1] - sum[i - 1][j - 1] + sum[i][j]; } } int re = 0; for(int i = r; i &lt;= x_max; i ++) { for(int j = r; j &lt;= y_max; j ++) { re = max(re, sum[i][j] - sum[i][j - r] - sum[i - r][j] + sum[i - r][j - r]); } } printf(\"%d\", re); return 0;} 1234567891011121314151617181920#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 10001;int dp[maxn];int mp[maxn][maxn];int x[maxn],y[maxn],v[maxn];int main(){ int N, R; cin &gt;&gt; N &gt;&gt; R; for (int i = 0; i &lt; maxn; i++) for (int j = 0 j &lt; maxn; j++) mp[i][j] = 0; while (N--) { int x, y, v; cin &gt;&gt; x &gt;&gt; y &gt;&gt; v; mp[x][v] = v; }} 1234567891011121314151617181920212223242526272829303132333435#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 5005;int dp[maxn][maxn];int main(){ int n, R; int xi, yi, vi; int max_x = 0; int max_y = 0; memset(dp, 0, sizeof(dp)); cin &gt;&gt; n &gt;&gt; R; for (int i = 0; i &lt; n; i++) { cin &gt;&gt; xi &gt;&gt; yi &gt;&gt; vi; dp[xi + 1][yi + 1] = vi; max_x = max(max_x, xi + 1); max_y = max(max_y, yi + 1); } int mmax = -1; for (int i = 1; i &lt;= max_x; i++) { for (int j = 1; j &lt;= max_y; j++) { dp[i][j] = dp[i][j] + dp[i - 1][j] + dp[i][j - 1] - dp[i - 1][j - 1]; if (i &gt;= R &amp;&amp; j &gt;= R) { mmax = max(mmax, dp[i][j] - dp[i - R][j] - dp[i][j - R] + dp[i - R][j - R]); } } } cout&lt;&lt;mmax; return 0;} hdoj 1559 最小子矩阵1234567891011121314151617181920212223242526272829#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1005;int main(){ int m, n, x, y; int T; int dp[maxn][maxn]; cin &gt;&gt; T; while (T--) { memset(dp, 0, sizeof(dp)); cin &gt;&gt; m &gt;&gt; n &gt;&gt; x &gt;&gt; y; int mmax = 0; for (int i = 1; i &lt;= m; i++) for (int j = 1; j &lt;= n; j++) { cin &gt;&gt; dp[i][j]; dp[i][j] += dp[i - 1][j] + dp[i][j - 1] - dp[i - 1][j - 1]; if (i &gt;= x &amp;&amp; j &gt;= y) { mmax = max(mmax, dp[i][j] - dp[i - x][j] - dp[i][j - y] + dp[i - x][j - y]); } } cout &lt;&lt; mmax &lt;&lt; endl; } return 0;} 1234567891011121314151617181920212223242526272829#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 1010;int sum[maxn][maxn];int a[maxn][maxn];int main(){ int n,m,q; cin&gt;&gt;n&gt;&gt;m&gt;&gt;q; for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= m; j++) { scanf(\"%d\",&amp;a[i][j]); sum[i][j] = sum[i-1][j]+sum[i][j-1]-sum[i-1][j-1]+a[i][j]; } } while (q--) { int x1,x2,y1,y2; scanf(\"%d %d %d %d\",&amp;x1,&amp;x2,&amp;y1,&amp;y2); printf(\"%d\",sum[y1][y2]-sum[y1-x1][y2]-sum[y1][y2-x2]+sum[x1][x2]); } return 0;} 线段树poj 2182 lost cows12345678910111213141516171819#include&lt;stdio.h&gt;const int Max = 8005;int main(){ int n,i,j,k; int pre[Max],ans[Max],num[Max]; scanf(\"%d\",&amp;n); num[0]=1; for (int i = 0; i &lt; n-1; i++) { scanf(\"%d\",&amp;pre[i]); num[i+1] = i+1; } for (int i = n-2; i &gt;= 0; i--) { } } 1234567891011121314151617181920212223242526272829303132333435#include &lt;stdio.h&gt;const int Max = 8005;int main(){ int n, i, j, k; int pre[Max], ans[Max], num[Max]; scanf(\"%d\", &amp;n); pre[1] = 0; for (i = 1; i &lt;= n; i++) { num[i] = i; } for (i = 2; i &lt;= n; i++) scanf(\"%d\", &amp;pre[i]); for (i = n; i &gt;= 1; i--) { k = 0; for (j = 1; j &lt;= n; j++) { if (num[j] != -1) { k++; if (k == pre[i] + 1) { ans[i] = num[j]; num[j] = -1; break; } } } } for (i = 1; i &lt;= n; i++) printf(\"%d\\n\", ans[i]); return 0;} 结构体实现线段树123456789101112131415161718192021222324252627282930313233343536373839404142434445//ECUST luoyongjun#include &lt;stdio.h&gt;using namespace std;const int Max = 10000;struct{ int l, r, len; // 用len存储这个区间的数字个数，即这个结点下牛的数量。} tree[4 * Max]; //这里开4倍大，因为线段树的空间需要。int pre[Max], ans[Max];void BuildTree(int left, int right, int u){ // 建树。 tree[u].l = left; tree[u].r = right; tree[u].len = right - left + 1; //更新结点u的值 if (left == right) return; BuildTree(left, (left + right) &gt;&gt; 1, u &lt;&lt; 1); //递归左子树。 BuildTree(((left + right) &gt;&gt; 1) + 1, right, (u &lt;&lt; 1) + 1); //递归右子树。}int query(int u, int num){ //查询+维护。所求值为当前区间的左起第num个元素。 tree[u].len--; //对访问到的区间维护len。即把这个结点上牛的数量减去一。 if (tree[u].l == tree[u].r) return tree[u].l; //情况1：左子区间内牛的个数不够，则查询右子区间的左起第num - tree[u&lt;&lt;1].len个元素。 if (tree[u &lt;&lt; 1].len &lt; num) return query((u &lt;&lt; 1) + 1, num - tree[u &lt;&lt; 1].len); //情况2：左子区间内牛的个数足够，则依旧查询左子区间的左起第num个元素。 if (tree[u &lt;&lt; 1].len &gt;= num) return query(u &lt;&lt; 1, num);}int main(){ int n, i; scanf(\"%d\", &amp;n); pre[1] = 0; for (i = 2; i &lt;= n; i++) scanf(\"%d\", &amp;pre[i]); BuildTree(1, n, 1); for (i = n; i &gt;= 1; i--) // 从后往前推断出每次最后一个数字。 ans[i] = query(1, pre[i] + 1); for (i = 1; i &lt;= n; i++) printf(\"%d\\n\", ans[i]); return 0;} 树状数组poj 218212345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//ECUST luoyongjun#include&lt;stdio.h&gt;#include&lt;string.h&gt;const int Max = 10000;int tree[Max], pre[Max], ans[Max];int n;#define lowbit(x) ((x) &amp; - (x))void add(int x, int d){ while(x &lt;= n) { tree[x] += d;x += lowbit(x); }}int sum(int x){ int sum = 0; while(x &gt; 0) { sum += tree[x];x -= lowbit(x); } return sum;}int findpos(int x){ //寻找sum(x) = pre[i]+1所对应的x，就是第x头牛 int l = 1, r = n; while(l &lt; r) { int mid = (l+r) &gt;&gt; 1; if(sum(mid) &lt; x) l = mid + 1; else r = mid; } return l;}int main(){ scanf(\"%d\",&amp;n); pre[1] = 0; for(int i=2; i &lt;= n; i++) scanf(\"%d\",&amp;pre[i]); for(int i=1; i &lt;= n; i++) //初始化tree数组。注意这个题目比较特殊， //不需要用add()初始化，因为lowbit(i)就是tree[i] tree[i] = lowbit(i); for(int i = n; i &gt; 0; i--) { int x = findpos(pre[i] + 1); add(x, -1); //更新tree数组。 ans[i] = x; } for(int i=1; i &lt;= n; i++) printf(\"%d\\n\", ans[i]); return 0;} https://www.cnblogs.com/FJ-LinHua/p/9170621.html https://blog.csdn.net/Nothing_but_Fight/article/details/90340695 https://blog.csdn.net/weixin_42488861/article/details/99168461","link":"/2019/11/18/线段树、树状数组、前缀和/"},{"title":"素数","text":"用试除法判断素数素数定义：一个数n，如果不能被[2,n-1]内的所有数整除，n就是素数。 当然，我们可以把范围从[2,n-1]缩小到[2,根号n] 证明如下： 假设n=a*b,有min(a,b) &lt;= 根号n ,令a &lt;= b.只要检查[2,根号n]内的数。如果n不是素数，就可以找到一个a。如果不存在这个a，那么[根号n,n-1]内也不存在b 算法如下: 123456789bool is_prime(int n){ if (n &lt;= 1) return false; // 1不是素数 for (int i = 2; i * i &lt;= n; i++) // 比for (int i = 2; i &lt;= sqrt(n); i++) 更好 if (n % i == 0) // 能整除，不是素数 return false; return true;} poj 3641Pseudoprime numbers123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;bool is_prime(ll n){ if (n &lt;= 1) return false; for (ll i = 2; i * i &lt;= n; i++) if (n % i == 0) return false; return true;}ll qpow(ll a, ll n, ll mod) //计算a^n % mod{ ll re = 1; while (n) { if (n &amp; 1) //判断n的最后一位是否为1 re = (re * a) % mod; n &gt;&gt;= 1; //舍去n的最后一位 a = (a * a) % mod; //将a平方 } return re;}int main(){ long long p, a; while (~scanf(\"%lld %lld\", &amp;p, &amp;a)) { if (p == 0 &amp;&amp; a == 0) break; // if (is_prime(p) &amp;&amp; qpow(a,p,p) == a) // { // cout&lt;&lt;\"yes\"&lt;&lt;endl; // } // else // { // cout&lt;&lt;\"no\"&lt;&lt;endl; // } if (is_prime(p)) { cout &lt;&lt; \"no\" &lt;&lt; endl; continue; } if (qpow(a, p, p) == a) cout &lt;&lt; \"yes\" &lt;&lt; endl; else cout &lt;&lt; \"no\" &lt;&lt; endl; } return 0;} 别人的代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;algorithm&gt;#include&lt;time.h&gt;#include&lt;math.h&gt;using namespace std;long long n;long long multi(long long a,long long b,long long m)//a*b%m{ long long res=0; while(b&gt;0) { if(b&amp;1) res=(res+a)%m; b&gt;&gt;=1; a=(a&lt;&lt;1)%m; } return res;}long long quickmod(long long a,long long b,long long m) //a^b%m{ long long res=1; while(b) { if(b&amp;1) res=multi(res,a,m); b&gt;&gt;=1; a=multi(a,a,m); } return res;}bool isprime(long long n){ for(int i=2;i*i&lt;=n;i++) { if(!(n%i)) return 0; } return 1;}int main(){ long long p,a; while(scanf(\"%I64d%I64d\",&amp;p,&amp;a),p+a) { if(isprime(p)) { puts(\"no\"); continue; } if(quickmod(a,p,p)==a) puts(\"yes\"); else puts(\"no\"); } return 0;} 快速幂模板123456789101112long long quickmod(long long a,long long b,long long m) //a^b%m{ long long res=1; while(b) { if(b&amp;1) res=multi(res,a,m); b&gt;&gt;=1; a=multi(a,a,m); } return res;} 试除法判断素数模板123456789bool isprime(long long n){ for(int i=2;i*i&lt;=n;i++) { if(!(n%i)) return 0; } return 1;} 乘法优化模板123456789101112long long n;long long multi(long long a,long long b,long long m)//a*b%m{ long long res=0; while(b&gt;0) { if(b&amp;1) res=(res+a)%m; b&gt;&gt;=1; a=(a&lt;&lt;1)%m; } return res;} 记忆化筛选法复杂度: $O(Nloglog2n)$ 12345678910111213141516171819const int MAXN = 1e7; //定义空间大小，1e7大约是MBint prime[MAXN + 1]; // 存放素数，它记录visit[i]=false的项bool visit[MAXN + 1]; // true表示被筛选掉，不是素数int E_sieve(int n) //埃式筛选法，筛选2-n{ int k = 0; //统计素数的个数 for (int i = 0; i &lt;= n; i++) visit[i] = false; //初始化 for (int i = 2; i &lt;= n; i++) { if (!visit[i]) //如果是素数 { prime[k++] = i; for (int j = 2 * i; j &lt;= n; j += i) visit[j] = true; // 把i的倍数都减去，变成不是素数 } } return k;} 但是这个地方还是有很多要改进的地方: 5的三倍就是3的五倍，比他小的倍数其实根本不用算 ，所以我们从i的i倍开始 3乘上一个偶数，其实这个偶数在i=2的时候全部处理过了 被筛选的数最多用到根号N 改进之后的算法 123456789101112131415161718192021const int MAXN = 1e7;int prime[MAXN + 1];bool visit[MAXN + 1];int E_sieve(int n){ for (int i = 0; i &lt;= n; i++) visit[i] = false; for (int i = 2; i &lt;= n; i++) if (!visit[i]) for (int j = i * i; j &lt;= n; j += i) visit[j] = true; int k = 0; // 记录素数 for (int i = 2; i &lt;= n; i++) { if (!visit[i]) { prime[k++] = i; } } return k;} 预处理，打表（快餐就是预处理）。不用每次都筛选，一趟筛选， 统计还是要十万 前缀和，树状数组，统计功能，前缀的功能 求第十个数到第二十个数字 判断一个数是否为XXX数这类题目有个特点，他会给你几个因子，让你判断是否为这些数的倍数 1234567891011121314151617181920212223242526#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;int main(){ int n; while (~scanf(\"%d\",&amp;n) &amp;&amp; n) { while (n!=1) { if(n%2 == 0) // 这个其实已经有点像走了循环了 n/=2; else if(n%3 == 0) n/=3; else if(n%5==0) n/=5; else if(n%7==0) n/=7; else break; } if(n == 1) cout&lt;&lt;\"YES\"&lt;&lt;endl; else cout&lt;&lt;\"NO\"&lt;&lt;endl; } } 技巧筛法+dp hdoj1058 humble number12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;cstring&gt;#define ll long long int#define maxn 5890using namespace std;int main(){ ll a[maxn]; int i, n; int f2 = 1, f3 = 1, f5 = 1, f7 = 1; a[1] = 1; for (i = 2; i &lt;= maxn; i++) { a[i] = min(a[f2] * 2, min(a[f3] * 3, min(a[f5] * 5, a[f7] * 7))); if (a[i] == a[f2] * 2) f2++; if (a[i] == a[f3] * 3) f3++; if (a[i] == a[f5] * 5) f5++; if (a[i] == a[f7] * 7) f7++; } while (scanf(\"%d\", &amp;n), n) { if (n == 0) break; printf(\"The %d\", n); if (n % 10 == 1 &amp;&amp; n % 100 != 11) printf(\"st\"); else if (n % 10 == 2 &amp;&amp; n % 100 != 12) printf(\"nd\"); else if (n % 10 == 3 &amp;&amp; n % 100 != 13) printf(\"rd\"); else printf(\"th\"); printf(\" humble number is %lld.\\n\", a[n]); } return 0;}","link":"/2019/11/12/素数/"},{"title":"","text":"状态状态的概念 游戏要取1-m张，取0张的话结束不了 必败点和必胜点，至少有一种方法可以赢 终结点–有很多终结的方式，只要结束就行了 只要有一种方法赢就可以了 四张牌，你怎么样都赢不了， 先手的赢或者输 1-15 1.3.4 N P N N N N P P P N P P 终结这个位置一定是0 减去一张是必胜点就是必败点 能赢 肯定不会输 2 4 5 4 6 7 5 7 8 行列都是奇数的时候才是必败 用excel表格来演示 两堆一样多一定必败，还有谁 1 2 3 相同的 7 1 1 必败状态，不管怎么走都是必胜状态，表妹压岁钱很多，组合游戏 结果最高位的三位1 为什么第二位要取1呢? 游戏的操作状态图 SG函数是非负的整数值 没有后继的SG值就是0，不等于后继值 0必败点，非0必胜点 能走到0肯定不是0 都能描绘成状态转移值 正常SG会超时，SG打表，打表只能五万，打表找规律，深搜暴力打表 由小游戏组成的话 5.7.9三个游戏组成的打游戏 5张牌的SG值 1 因为4是 5 是1 9是1 579任意都可以走到0，奇数个1走到了偶数个1 mex 最小不包含 很早就完成， 哈希拷贝十份数据 上百万输入输出，排序 1425 map也是排序，堆排 桶排序 非典型哈希，但是有最基本的特征，存储位置和值相联系了 简单实用的就是除余法： 2018633007 / 217 求余数 直接坐下去，但是不文明 — 冲突 线性探测再散列，惹不起往后找 二次探测再散列，加平方 赵乐一 位置没人 肯定没来 有人了怎么办，没人了怎么办 k元素的五到十倍，2太小了 k空间，100人给你一个天安门广场来坐 搜索问题，八数码 1425sort 1496 二分也可以方程 平方，区间也是对称的。 可以是正，也可以是负的 16倍，每一个都有两种可能 x4可以算但是还是要去解，分开两半 有些双向搜索的意思 两百万全局变量没问题 大二下学期有比赛worldfinal07年400都是集训队的，不是时间不够 理学院考到浙大计算机400多分 辩论队，杭电毕业，余思成浙大研究生，国际大专，最佳辩手 武林外传的吕秀才","link":"/2019/12/04/组合游戏/"},{"title":"","text":"12345678910111213141516171819202122232425262728293031323334#include &lt;bits/stdc++.h&gt;using namespace std;int max(int a, int b){ return a &gt; b ? a : b; // 三目运算符}int main(){ int m, n; while (~scanf(\"%d %d\", &amp;m, &amp;n) &amp;&amp; m + n) { int sum1 = 0; int sum2 = 0; if (m &gt; n) { int t = n; n = m; m = t; //不知道谁大谁小 } for (int i = m; i &lt;= n; i++) { if (i % 2 == 0) { sum1 += i * i; } else { sum2 += i * i * i; } } printf(\"%d %d\\n\", sum1, sum2); } return 0;} 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;stdio.h&gt;#include&lt;math.h&gt;int main(){ int m,n,t,i,a,b,c;int d[200]={0}; while(scanf(\"%d%d\",&amp;m,&amp;n)!=EOF) { int e=0;int count=0; if(m&gt;n) { t=m; m=n; n=t; } for(i=m;i&lt;=n;++i) { a=i/100; b=(i/10)%10; c=i%10; printf(\"%d %d %d\\n\",a,b,c); if(i==a*a*a+b*b*b+c*c*c) { d[e++]=i; count++; printf(\"%d\\n\",i); }} if(e!=0) { for(e=0;e&lt;count-1;++e){ printf(\"%d \",d[e]); } printf(\"%d\\n\",d[count-1]); } else if(e==0) printf(\"no\\n\"); } return 0; } 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 100;int f_number[maxn] = {0};int main(){ int m, n; while (~scanf(\"%d %d\", &amp;m, &amp;n) &amp;&amp; m + n) { memset(f_number, 0, sizeof(f_number)); int cnt = 0; for (int i = m; i &lt;= n; i++) { int a = (i % 10);// * (i % 10) * (i % 10); int b = (i / 10)%10;// % 10) + ((i / 10) % 10) * ((i / 10) % 10); int c = i / 100;// + (i / 100) + (i / 100); 运算级问题 //printf(\"%d %d %d\\n\",a,b,c); int split = a*a*a+b*b*b+c*c*c; //cout &lt;&lt; split &lt;&lt; endl; if (i == split) { f_number[cnt++] = i; cnt++; } } cout&lt;&lt;cnt&lt;&lt;endl; if (cnt) { for (int i = 0; i &lt; cnt; i++) { cout &lt;&lt; f_number[i] &lt;&lt; \" \"; } printf(\"\\n\"); } else { cout &lt;&lt; \"no\" &lt;&lt; endl; } } return 0;} 2012123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 91;int vis[maxn];bool Isprime(int n){ if (n &lt;= 1) return false; for (int i = 2; i * i &lt;= n; i++) if (n % i == 0) return false; return true;}void Eishi(){ memset(vis,0,sizeof(vis)); int l = -39; int r = 50; int number; for (int i = l; i &lt;= r; i++) { number = i * i + i + 41; if (Isprime(number) == 1) vis[i+39] = 1; }}int main(){ int x, y; Eishi(); while (~scanf(\"%d %d\", &amp;x, &amp;y) &amp;&amp; x + y) { int flag = 0; for (int i = x; i &lt;= y; i++) { if (vis[i+39] == 0) flag = 1; } if (flag == 1) cout &lt;&lt; \"Sorry\" &lt;&lt; endl; else cout &lt;&lt; \"OK\" &lt;&lt; endl; } return 0;} 打表的话要在主函数中声明一次那个函数 判断素数的方法是 123456bool Isprime(int n){ if(n&lt;=1) return false for(int i = 2 ;i*i&lt;n;i++) if(n%i == 0) return false; return true;} hdoj 2024 c语言的合法运算符12345678910111213141516171819202122232425#include &lt;stdio.h&gt;#include &lt;ctype.h&gt;int main(void){ int i,n; char s[52]; scanf(\"%d\\n\",&amp;n); while(n--) { gets(s); if(s[0]!='_' &amp;&amp; !isalpha(s[0])) { printf(\"no\\n\"); continue; } for(i=1;s[i]!='\\0';i++) { if(s[i]!='_'&amp;&amp;!isalnum(s[i])) break; } if(s[i]=='\\0')printf(\"yes\\n\"); else printf(\"no\\n\"); } return 0;} 2019 拿另一个数组存","link":"/2019/11/13/菜鸟训练营/"},{"title":"","text":"网络通信概述UDP第一天1能用python发信息 什么是网络淘宝两块钱买网址 为什么要用对讲机说话？ 对讲机 红白机 50块钱 目的：不同电脑之间的通信 同一个班级，局域网 互联网，外围网 手里面提着箱子，箱子里面是密码，啊他网 软件核心：mac ox，windows，linux 硬件核心：cpu 资源进行共享 2为什么只有这个同学接收到 有人来标记这个电脑，标记了这条信息 IP地址 一坨数字 目的：标记网络上的一台电脑 网络的拓扑图 交换机 路由器 发送信息要写上：des_ip 系统会自己带上ip ip地址是什么，IP地址的作用是什么 3查询ip地址 更改网络适配器——网卡 右击状态——支持 win+r r==run ipconfig Ubuntu ————ifconfig sudu apt install net-tools 不同的东西叫网卡 inet叫ip地址 把网卡关闭或者禁用 cd返回原始文件夹 ctrl+a快速回到行首 ctrl+e 上下返回上一次命令 up开 down关 4ip的分类 ipv4 123是实验的版本 四组，靠点分开 256的四次方 每个人都有一批ip，有区域 不值得找你 所有的智能设备都有ip 根据四组数划分为很多种类 ipv4规律 我们班是一个局域网，在前面是一样的 网络号，主机号 最大和最小的不能用，即只能用254种 前面三组分为ABC D类单拨，多拨，广播 一对一 一对多，变成一个小组 很多人听到，广播 E类保留 0-255 ipv6 5一般是c类地址 你怎么知道给飞秋而不是qq 端口 到了相同的ip的地方之后，进行对比，然后存下来 src源ip， 收到数据之后然后再回一个 通信的基本过程 6端口的分类 213端口——门 门牌号，端口号 我们只关心端口号的值 进程线程协程 运行了之后就叫进程 网络就是进程和进程的通信 端口号是怎么分配的 知名端口：大家都默认使用的某个端口 网络是21号端口 &lt;1024 0-1023 1024-65535 端口号 7socket介绍 用socket通信，套接字，插口 不用关心怎么做 打开读写关闭 创建套接字，其中那个s是一个类 返回值是一个对象，所以这个是一个类 不是一个函数 必须通过socket才能实现 买了一个娃娃怎么办 浏览器都给我卸载了，因为其他浏览器都很烂 socket的参数 udp还是tcp的通信 第一个是协议组，ipv4还是ipv6 tcp，udp 导入模块的问题 import socke的话，还要用socket.socket 但是from socket import * 导入socket里面的所有函数 就不用写socket.socket前面的socket 如果返回没有问题就称为套接字对象 第二天 写程序 写程序的方式再windows里面一般要打开图形化的东西 但是再linux里面的话，我们不见得一定要打开 比如说我们可以用 sublime ctrl+放大 if 什么什么name== 什么什么main是怎么用的 c sharp lua写外挂 ob 开房rys 支持拖文件夹 右击删除就可以删除文件夹了 ctrl+s 保存 运行代码 ls一下 cd desktop 开始写程序 1234567891011tab快速补全ls 查看当前文件夹的wejiancd 打开文件夹cd空就是返回桌面：q退出当前文本 加上！强制退出vim 编辑文本 另外的方式运行 python3 加一个 这里面出现了中文，用python2写的，所以要加上-#coding=utf-8#- 用vim写 再用python3写 vim命令 esc进入命令行模式 v选中当前行 shift+小于号全体左缩进 ctrl+n 有补全 deb文件安装 sudo dpkg -i deb文件名 开始发送数据 通过socket发送一个数据 QT编译 64位是什么意思 结构体构造函数 开始发送数据会出现得问题 双引号左边写上b就是字节类型 他不要字符串，只要字节类型 网络unreachable ping一下ping成功才行 解决方法，改成桥接模式 sudo dhclient 等待别人给你分配一个ip，保证桥接了，要保证在同一个局域网 ：x保存并退出 2有可能你的电脑有好几个ip 以vmware开头的，虚拟的网卡 把虚拟的网卡关了 同一个wifi在一个局域网？ tab，元组 写代码不熟练 加注释 3b意味着什么 打开python3进入交互模式 ipython3 ![1570628821725](C:\\Users\\legion\\AppData\\Roaming\\Typora\\typora-user-images\\1570628821725.png 交互模式更加高端 ipython可以自动补全 而且可以清空 复制文件到另一个py文件 1cp xxx.py ttt.py 从键盘输入数据 yyp 复制 apt命令 下载慢更换镜像下载源 命中是什么意思 b转换格式 send_data.encode(“utf-8”) 聊天室循环发送数据 prompt 内存太高会产生内存交换 CTRL+c退出 带有退出功能的循环py if不用加括号 4接受udp信息端口写多少？ 创建套接字的时候是没有端口的 要通过bind创建端口号， ip+端口 空的双引号和单引号 shift+空格 全角和半角切换 写注释 行首# 文字后面&amp;nsbp&amp;nsbp#&amp;nsbpcontent 总结 bind要绑定自己的 打印东西要注意发送方的编码格式 触发器是什么 代码环节__name规范到底怎么写 if__ 中间要用空格 print的使用要学会 5绑定端口的问题 每次重新发送一次数据，又会有一个新的端口号，而且是发送一次，端口就是一个 发送的时候没有绑定端口系统会自动帮你绑定 同一端口不许同一时间使用两次 6网络中重要概念复习 udp很简单 数据共享 有ip地址来区分 私有ip，不能上互联网. 上互联网的就是自己的公有ip 端口 知名端口公用端口 0-1023 1024-8080 飞鸽传书的端口都是2425 python不用重复造轮子 7 udp聊天器 不用管那个网线拉了没 一个套接字可不可以同时收同时发 没学多任务 12345678mv 名字 名字 A到行末进行编辑小写字母i跳到行首mv 名字 名字 A到行末进行编辑小写字母i跳到行首ctrl+n补全ctrl+T加另外的标签-i install ftp ssh xshell 网络通信也能同一台电脑通信 lo代表的是环回的地址 recvfrom在没有接受到数据的时候是什么情况？ 阻塞 把他想象为电话 套接字可以同时收发数据 单工：百分之百只能指向一个位置，只能听 半双工：对讲机，收的时候发不了，发的时候收不了 都在用同一个频道，要抢到那个频道 全双工：同一时刻既可以收也可以发，socket是全双工 8 udp聊天器案例先去模仿，72变也是学过来的。学习核心 main函数是主要的函数 写代码要慢慢推 正着推，推不动然后反着想 函数和函数空两个行 剪切是d，复制是p 百分号前面要有空格 python红灯停绿灯行 “”“函数的解释说明”“” 点一次来一次，没有调用recvfrom 他有东西存起来了我们的信息cache 接受快递的存放处 这个是漏洞 把端口扫描一遍，看看有哪个是开的 然后不停的发送数据 要while true的收，即收的时候才开端口 不要端口一直开着随时去收 一定开了2425+++ 蓝牙也算ip？ TCPtcp介绍（传输控制协议）udp写信： 放进去就回发送走 收信人的地址 写信不安全 别人也会收到 飞秋可能收不到 tcp： 打电话 tcp有补救措施 保证数据一定会到 电流导致数据乱了 打电话要拨号，嘟嘟嘟的过程 必须先建立链接 tcp有应答机制 一段时间内没有应答，超时重传 迅雷下载的上传速度就是应答 错误校验 流量控制，阻塞管理 不能传太多 UDP 飞鸽传书 保证稳定 udp流程建立套接字 sento recvfrom bind端口 TCP流程严格区分客户端和服务器 选区：选择服务器，越近越不卡 提供服务的就是服务器 客户端：ipad点菜机 多了链接服务器 铁了心要用括号就要转义 大写的o前面插入，小写的o插入到下面 自己写的名字和import一样 tcp说多少句都是一个连接 客户端和服务器 udp 用户数据报协议","link":"/2019/10/24/网络通信概述/"},{"title":"背包问题","text":"01背包 01背包(最基础的背包问题):有N件物品和一个容量为V的背包。第i件物品的费用是c[i]，价值是w[i]。求解将哪些物品装入背包可使价值总和最大。问题特点：每种物品仅有一件，可以选择放或不放，用子问题定义状态：即f[i][v]表示前i件物品放入一个容量为v的背包可以获得的最大价值。状态转移方程： $$f[i][v]=max{f[i-1][v],f[i-1][v-c[i]]+w[i]}\\求f[n][v]$$ 思考一个问题: 为什么要加上前i件物品 不加的话，要Cm取n,选的三个人，不一定包含前一个或者前两个 非线性问题线性化 求子问题的最优解，确保我放的这一个只要求一个max就可以得到最优解(问题的刨分) 要么包含，要么不包含。包含的话，我要找到f[i-1,v-c[i]] 那个时候的最优解 先回顾一下动态规划的3个基本特征： 最优子结构 重叠子问题 无后效性 一个晚上就能学会的东西 加快效率—清华可能保研到，玩acm照样去清华 表格： 初始化: 把所有的都变为0.因为不放物品的时候。根本没有价值 时间复杂度O(NV),空间复杂度也是(NV) 优化 时间复杂度肯定是优化不了的，因为我要求出每一个物品的某个容量下的最优解 所以看看空间复杂度能不能优化 我们可以看到，每一行的数据，只和前一行有关，和前面的所有行都没有关系。 所以我们考虑只用一维数组 但是一维数组也有一个问题: 如果我们正着循环的话，假如背包容量为10，物品的重量为5，6。价值为3，5。在考虑10的那时候，dp[10]=6，但很显然不可能为6。因为每个物品只能用一次。所以dp[10]=5。 那么我能不能用完这个物品来标记一下呢？其实也不行，因为就算是你标记了，你也不知道这个物品不知道在哪里被用了。我们主要是想知道这个物品在哪里被用了。 hdoj 2602 bone collector1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;using namespace std;const int MAXN = 1005;//int v[MAXN],w[MAXN],int dp[MAXN]; // 设计成一个数组就好了struct BONE{ int val; int vol;} bone[1011]; //用结构体来存数据int T, N, V;int ans(){ memset(dp, 0, sizeof(dp)); //初始化为0 for (int i = 1; i &lt;= N; i++) for (int j = V; j &gt;= bone[i].vol; j--) dp[j] = max(dp[j], dp[j - bone[i].vol] + bone[i].val); return dp[V];}int main(){ cin &gt;&gt; T; while (T--) { cin &gt;&gt; N &gt;&gt; V; for (int i = 1; i &lt;= N; i++) { cin &gt;&gt; bone[i].val; } for (int i = 1; i &lt;= N; i++) { cin &gt;&gt; bone[i].vol; } cout &lt;&lt; ans() &lt;&lt; endl; } return 0;} V-VI[I] 数组不会越出 123456789101112131415161718192021222324252627282930#include&lt;bits/stdc++.h&gt;using namespace std;const int COIN = 101;const int MONEY = 251;int dp[MONEY][COIN]={0};int type[5] = {1,5,10,25,50};void solve(){ dp[0][0]=1; for (int i = 0; i &lt; 5; i++) //从第一个硬币开始，因为前面根本填不进来 for (int j = 1; j &lt; COIN; j++) // 能用多少个硬币 for (int k = type[i]; k &lt; MONEY; k++) // 在硬币币额之前根本用不上这个硬币 dp[k][j] += dp[k-type[i]][j-1]; // 状态转移方程 // 现在的状态等于不加这个硬币，所有的种类数，再加上，我不用这个硬币的时候，所有的种类数 // 也可以这样理解，当我的钱币进行组合的时候，分成两部分，一部分是加上这个金币，一部分是不加上这个金币 }int main(){ int s; int ans[MONEY] = {0}; solve(); for (int i = 0; i &lt; MONEY; i++) for (int j = 0; j &lt; COIN; j++) ans[i] += dp[i][j]; while (cin&gt;&gt;s) { cout&lt;&lt;ans[s]&lt;&lt;endl; } return 0; } hdoj 2546 饭卡12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int MAXN = 1001;bool cmp(int a, int b){ return a &gt; b;}int main(){ int N; int money; int cost[MAXN]; int dp[MAXN]; while (~scanf(\"%d\", &amp;N) &amp;&amp; N) { int MaxV; memset(dp, 0, sizeof(dp)); //memset(cost,0,sizeof(cost)); for (int i = 0; i &lt; N; i++) { cin &gt;&gt; cost[i]; } cin &gt;&gt; money; if (money &lt; 5) { cout &lt;&lt; money &lt;&lt; endl; continue; } sort(cost, cost + N, cmp); MaxV = cost[0]; money -= 5; for (int i = 1; i &lt; N; i++) { for (int j = money; j &gt;= cost[i]; j--) { dp[j] = max(dp[j], dp[j - cost[i]] + cost[i]); } } cout &lt;&lt; money + 5 - dp[money] - MaxV &lt;&lt; endl; } return 0;} 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int MAXN = 1001;bool cmp(int a, int b){ return a &gt; b;}int main(){ int N; int money; int cost[MAXN]; int dp[MAXN]; while (~scanf(\"%d\", &amp;N) &amp;&amp; N) { int MaxV; memset(dp, 0, sizeof(dp)); //memset(cost,0,sizeof(cost)); for (int i = 0; i &lt; N; i++) { cin &gt;&gt; cost[i]; } cin &gt;&gt; money; if (money &lt; 5) { cout &lt;&lt; money &lt;&lt; endl; continue; } sort(cost, cost + N, cmp); MaxV = cost[0]; money -= 5; for (int i = 1; i &lt; N; i++) { for (int j = money; j &gt;= cost[i]; j--) { dp[j] = max(dp[j], dp[j - cost[i]] + cost[i]); } } cout &lt;&lt; money + 5 - dp[money] - MaxV &lt;&lt; endl; } return 0;} hdoj1203 I NEED A OFFER!（数学题）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;bits/stdc++.h&gt;using namespace std;const int money = 10001;const int Maxn = 10001;double dp[Maxn];int N, M;struct School{ int money; double probability;} school[Maxn];int main(){ while (~scanf(\"%d %d\", &amp;N, &amp;M)) { //vector&lt;double&gt;v; //memset(dp,1.0,sizeof(dp)); 好像不能赋值小数 for (int i = 0; i &lt;= N; i++) { dp[i] = 1.0; //初始化注意 } //dp[0] = 1; double ans = 0; if (N == 0 &amp;&amp; M == 0) break; for (int i = 0; i &lt; M; i++) { scanf(\"%d %lf\",&amp;school[i].money,&amp;school[i].probability); //lf //cin &gt;&gt; school[i].money &gt;&gt; school[i].probability; school[i].probability = 1.0 - school[i].probability; } for (int i = 0; i &lt; M; i++) for (int j = N; j &gt;= school[i].money; j--) { dp[j] = min(dp[j], dp[j - school[i].money] * school[i].probability); // if(dp[j-school[i].money]+school[i].probality &gt; dp[j]) // { // dp[j] = dp[j-school[i].money]+school[i].probality; // v.push_back(school[i].probality); // } } // for (int i = 1; i &lt;= v.size(); i++) // { // } //记录用过的 double res = (1.0 - dp[N]) * 100.0; //是dp[N]不是dp[M] cout &lt;&lt; fixed &lt;&lt; setprecision(1) &lt;&lt; res &lt;&lt; \"%\" &lt;&lt; endl; } return 0;} 完全背包 同样是输入问题，但是现在允许使用物品无限次，求每个背包的最佳情况 当然，如果我们要求最大值，则把初始值定位0，如果要求最小值，则把初始值定位无穷大 非法的情况一般是-1或者无穷大 编程中无穷大常量的设定技巧如果问题中各数据的范围明确，那么无穷大的设定不是问题，在不明确的情况下，很多程序员都取0x7fffffff作为无穷大，因为这是32-bit int的最大值。如果这个无穷大只用于一般的比较（比如求最小值时min变量的初值），那么0x7fffffff确实是一个完美的选择，但是在更多的情况下，0x7fffffff并不是一个好的选择。 很多时候我们并不只是单纯拿无穷大来作比较，而是会运算后再做比较，例如在大部分最短路径算法中都会使用的松弛操作：if (d[u]+w[u][v]&lt;d[v]) d[v]=d[u]+w[u][v];我们知道如果u,v之间没有边，那么w[u][v]=INF，如果我们的INF取0x7fffffff，那么d[u]+w[u][v]会溢出而变成负数，我们的松弛操作便出错了，更一般的说，0x7fffffff不能满足“无穷大加一个有穷的数依然是无穷大”，它变成了一个很小的负数。 除了要满足加上一个常数依然是无穷大之外，我们的常量还应该满足“无穷大加无穷大依然是无穷大”，至少两个无穷大相加不应该出现灾难性的错误，这一点上0x7fffffff依然不能满足我们。 所以我们需要一个更好的家伙来顶替0x7fffffff，最严谨的办法当然是对无穷大进行特别处理而不是找一个很大很大的常量来代替它（或者说模拟它），但是这样会让我们的编程过程变得很麻烦。在我读过的代码中，最精巧的无穷大常量取值是0x3f3f3f3f，我不知道是谁最先开始使用这个精妙的常量来做无穷大，不过我的确是从一位不认识的ACMer(ID:Staginner)的博客上学到的，他/她的很多代码中都使用了这个常量，于是我自己也尝试了一下，发现非常好用，而当我对这个常量做更深入的分析时，就发现它真的是非常精巧了。 0x3f3f3f3f的十进制是1061109567，也就是10^9级别的（和0x7fffffff一个数量级），而一般场合下的数据都是小于10^9的，所以它可以作为无穷大使用而不致出现数据大于无穷大的情形。 另一方面，由于一般的数据都不会大于10^9，所以当我们把无穷大加上一个数据时，它并不会溢出（这就满足了“无穷大加一个有穷的数依然是无穷大”），事实上0x3f3f3f3f+0x3f3f3f3f=2122219134，这非常大但却没有超过32-bit int的表示范围，所以0x3f3f3f3f还满足了我们“无穷大加无穷大还是无穷大”的需求。 最后，0x3f3f3f3f还能给我们带来一个意想不到的额外好处：如果我们想要将某个数组清零，我们通常会使用memset(a,0,sizeof(a))这样的代码来实现（方便而高效），但是当我们想将某个数组全部赋值为无穷大时（例如解决图论问题时邻接矩阵的初始化），就不能使用memset函数而得自己写循环了（写这些不重要的代码真的很痛苦），我们知道这是因为memset是按字节操作的，它能够对数组清零是因为0的每个字节都是0，现在好了，如果我们将无穷大设为0x3f3f3f3f，那么奇迹就发生了，0x3f3f3f3f的每个字节都是0x3f！所以要把一段内存全部置为无穷大，我们只需要memset(a,0x3f,sizeof(a))。 所以在通常的场合下，0x3f3f3f3f真的是一个非常棒的选择。 负无穷大用0xcfcfcfcf比较好。 完全背包原理现在既然可以使用无限次物品，我们应该怎么写循环呢？ 还记不记得我们在上一个01背包的时候讲到，我们正着来，会导致一种情况—-重复用! 那现在我们就刚好可以重复用，每一行正着来，因为不怕重复用 用已知去解决未知的–去考证(用擅长的事情去做事) 强迫症情况 如果此时有一个强迫症强迫症，一定要装满或者说把东西全部都用完。应该怎么处理 只需考虑初始化问题就好了。因为初始化的时候。我们是默认第一行全部为0.即可以允许背包有剩余量的情况。 但现在一定是装满背包才算一种合法情况。所以我们需要把初始化定位第一个为0，其他的为无穷大 二位表格 初始化行不行 初始化改成-1，-1表示无解 这样的话可能会跨两行把 关键就是初始化 初始化的真正含义 0是合法的，-1是非法的 hdoj 1114 Piggy-Bank12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;using namespace std;const int MAXN = 10005;const int inf = 999999;//int v[MAXN],w[MAXN],int dp[MAXN]; // 设计成一个数组就好了struct MONEY{ int val; int vol;} money[MAXN];int T, E, F, N;int ans(){ memset(dp, 0x3f, sizeof(dp)); dp[0] = 0; for (int i = 1; i &lt;= N; i++) for (int j = money[i].vol; j &lt;= F - E; j++) dp[j] = min(dp[j], dp[j - money[i].vol] + money[i].val); return dp[F - E];}int main(){ cin &gt;&gt; T; while (T--) { cin &gt;&gt; E &gt;&gt; F; cin &gt;&gt; N; for (int i = 1; i &lt;= N; i++) { cin &gt;&gt; money[i].val &gt;&gt; money[i].vol; } if (ans() != 0x3f3f3f3f) cout &lt;&lt; \"The minimum amount of money in the piggy-bank is \" &lt;&lt; ans() &lt;&lt; \".\" &lt;&lt; endl; else cout &lt;&lt; \"This is impossible.\" &lt;&lt; endl; } return 0;} hdoj1248 寒冰王座12345678910111213141516171819202122232425262728293031#include &lt;bits/stdc++.h&gt;using namespace std;const int money = 10001;const int maxn = 10001;int dp[maxn];int type[3] = {150, 200, 350};void solve(){ dp[0] = 0; for (int i = 0; i &lt; 3; i++) for (int j = type[i]; j &lt;= money; j++) { dp[j] = max(dp[j], dp[j - type[i]] + type[i]); }}int main(){ int T; int money; cin &gt;&gt; T; while (T--) { memset(dp, 0, sizeof(dp)); cin &gt;&gt; money; solve(); cout &lt;&lt; money-dp[money]&lt;&lt;endl; } return 0;} hdoj 4508 湫湫系列故事——减肥记I1234567891011121314151617181920212223242526272829303132#include &lt;bits/stdc++.h&gt;using namespace std;const int money = 10001;const int Maxn = 101;int dp[100001], c[Maxn], v[Maxn], V, N;int solve(){ for (int i = 0; i &lt; N; i++) for (int j = c[i]; j &lt;= V; j++) { dp[j] = max(dp[j], dp[j - c[i]] + v[i]); } return dp[V];}int main(){ while (~scanf(\"%d\", &amp;N) &amp;&amp; N) { memset(dp, 0, sizeof(dp)); //memset(c,0,sizeof(c)); //memset(v,0,sizeof(v)); for (int i = 0; i &lt; N; i++) { cin &gt;&gt; v[i] &gt;&gt; c[i]; } cin &gt;&gt; V; cout &lt;&lt; solve() &lt;&lt; endl; } return 0;} 一种是可以打表的，其他的是不行的 多重背包 hdoj 2191有些物品有限制数量 优化前1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;using namespace std;static int dp[105][105]; //前i种物品价格为j的时候总重量static int p[105], h[105], c[105];int main(){ int C; scanf(\"%d\", &amp;C); while (C--) { int n, m; scanf(\"%d %d\", &amp;n, &amp;m); for (int i = 1; i &lt;= m; ++i) scanf(\"%d %d %d\", &amp;p[i], &amp;h[i], &amp;c[i]); memset(dp, 0, sizeof(dp)); int ans = 0; for (int i = 1; i &lt;= m; ++i) { for (int j = 0; j &lt;= n; ++j) { for (int k = 0; k &lt;= c[i]; ++k) { if (j &gt;= k * p[i]) { dp[i][j] = max(dp[i - 1][j - k * p[i]] + k * h[i], dp[i][j]); } } ans = max(ans, dp[i][j]); //显得有点冗杂，因为dp[i][j]已经表示当前位置的最大值，直接输出最后一个就好了 } } printf(\"%d\\n\", dp[m][n]); } return 0;} 变成普通的01背包，因为有些物品可能有超级多12345678910111213141516171819202122232425262728293031323334353637383940414243444546//化为01背包#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;using namespace std;static int dp[2010]; //前i种物品价格为j的时候总重量static int p[2010], h[2010];int main(){ int C; scanf(\"%d\", &amp;C); while (C--) { int n, m; int cs = 0; scanf(\"%d %d\", &amp;n, &amp;m); int c; int p1, h1; for (int i = 1; i &lt;= m; ++i) { scanf(\"%d %d %d\", &amp;p1, &amp;h1, &amp;c); for (int j = 1; j &lt;= c; ++j) { p[cs + j] = p1; h[cs + j] = h1; } cs += c; } memset(dp, 0, sizeof(dp)); int ans = 0; for (int i = 1; i &lt;= cs; ++i) { for (int j = n; j &gt;= p[i]; --j) { dp[j] = max(dp[j], dp[j - p[i]] + h[i]); ans = max(ans, dp[j]); } } printf(\"%d\\n\", ans); } return 0;} 效率不能保证 倍增优化，拆分成很多物品，倍增的12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;bits/stdc++.h&gt;using namespace std;#define mst(a, b) memset((a), (b), sizeof(a))#define f(i, a, b) for (int i = (a); i &lt;= (b); ++i)const int maxn = 105;const int mod = 9973;const int INF = 0x3f3f3f3f;const double eps = 1e-6;#define ll long long#define rush() \\ int T; \\ scanf(\"%d\", &amp;T); \\ while (T--)int p[maxn], h[maxn], c[maxn];int dp[maxn];struct node{ int v, w;} s[maxn * 10]; // 可以用一个结构体来存相关的信息int main(){ int n, m; rush() { scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 0; i &lt; m; i++) { scanf(\"%d%d%d\", &amp;p[i], &amp;h[i], &amp;c[i]); } int cnt = 0; for (int i = 0; i &lt; m; i++) { for (int k = 1; k &lt;= c[i]; k *= 2) //捆绑这件事情，是在第几件物品的循环里面 // k 一开始不能等于0 { s[cnt].v = p[i] * k; s[cnt++].w = h[i] * k; c[i] -= k; //c要随时变化 } if (c[i]) { s[cnt].v = p[i] * c[i]; s[cnt++].w = h[i] * c[i]; } } mst(dp, 0); for (int i = 0; i &lt; cnt; i++) for (int j = n; j &gt;= s[i].v; j--) dp[j] = max(dp[j], dp[j - s[i].v] + s[i].w); printf(\"%d\\n\", dp[n]); } return 0;} 单调队列1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;const int maxn = 110;int C, N, M, dp[maxn];int Q[maxn][2], head, tail; //Q[x][0]存g[s]，Q[x][1]存s以判断s是否符合限制条件int main(){ scanf(\"%d\", &amp;C); while (C--) { memset(dp, 0, sizeof(dp)); scanf(\"%d%d\", &amp;N, &amp;M); // 价钱，种类 for (int i = 1; i &lt;= M; i++) { int v, w, n; scanf(\"%d%d%d\", &amp;v, &amp;w, &amp;n); // 体积，价格，数量 for (int b = 0; b &lt; v; b++) { //枚举余数b head = tail = 1; //清空队列，加在这里是因为只能从余数相同的状态转移来，之前队列中的元素都不需要了 for (int j = 0; j &lt;= (N - b) / v; j++) { int tmp = dp[j * v + b] - j * w; //这里的dp是上一轮的，j代表s while (head &lt; tail &amp;&amp; tmp &gt;= Q[tail - 1][0]) --tail; //先插入以满足s≤min(n,a)的条件 Q[tail][0] = tmp, Q[tail++][1] = j; //这里j还是代表s while (Q[head][1] &lt; j - min(n, j)) ++head; //以下j代表a，删除队首以去除不满足a−min(n,a)≤s的状态 dp[j * v + b] = Q[head][0] + j * w; //队首即为最优 } } } printf(\"%d\\n\", dp[N]); } return 0;} https://blog.csdn.net/hhz6830975/article/details/79436320 https://www.cnblogs.com/JoeFan/p/4165956.html https://blog.csdn.net/flyinghearts/article/details/5898183 https://www.cnblogs.com/-guz/p/9866118.html https://blog.csdn.net/my_sunshine26/article/details/70991605 混合背包 hdoj 1171倍增优化,其实也是一道混合背包的题目1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;stdio.h&gt;#include &lt;string.h&gt;int max(int a, int b){ return a &gt; b ? a : b;}int main(){ int N, sum, V, i, j, k; int w[51], n[51]; //w[i]用来保存第i件物品的价值，此题中费用与同一物品的价值相等，n[i]用来保存第i件物品的数量 int dp[250000]; //总价值最大为250000 while (scanf(\"%d\", &amp;N), N &gt;= 0) { sum = 0; for (i = 0; i &lt; N; i++) //输入物品价值和个物品的数量 { scanf(\"%d%d\", w + i, n + i); sum += w[i] * n[i]; //求出所有物品 的总价值 } V = sum / 2; //因为要将物品尽可能的均匀分配，所以背包最大容量为总价值的一半 memset(dp, 0, sizeof(dp)); //将dp所有元素初始化为0 for (i = 0; i &lt; N; i++) { if (w[i] * n[i] &gt;= V) //采用完全背包,放第i种物品 完全背包就是，容量除以单位体积，远少于我拥有的数量 { for (j = w[i]; j &lt;= V; j++) dp[j] = max(dp[j], dp[j - w[i]] + w[i]); } else { k = 1; while (k &lt; n[i]) //采用01背包，第i中物品每次放k件， { for (j = V; j &gt;= k * w[i]; j--) dp[j] = max(dp[j], dp[j - k * w[i]] + k * w[i]); n[i] -= k; k *= 2; } //将剩余的n[i]件物品看能否放入背包中， for (j = V; j &gt;= n[i] * w[i]; j--) dp[j] = max(dp[j], dp[j - n[i] * w[i]] + n[i] * w[i]); } } printf(\"%d %d\\n\", sum - dp[V], dp[V]); //输出操作 } return 0;} 1059 divding https://blog.csdn.net/jijijix/article/details/53572304 多维费用背包 hdoj 21591 立体的，变成一层了","link":"/2019/10/23/背包专题/"},{"title":"","text":"如何准备蓝桥杯 课程的大致安排 做题的套路 递推与递归 以讲知识点为主，针对某一次比赛，考前冲刺 分成两部分，例题，习题，本周周内的课后习题 下周六来讲 前期刷题的数量 如何准备蓝桥杯设计课程内容 讲三个部分 历年题目 系统讲知识点 出模拟赛，两次模拟赛 有问题，基本没学过算法 直接放到例题和习题里面讲 模拟赛是很重要的一件事情，打一些真实的模拟赛，找一下考试的感觉和心态 十个重要的知识点 次数最多的知识点 上课–例题的思路一定要搞懂，全部自己写一遍 每周十道题，不算多 学习氛围很重要 提高量和基础课知识量比较多 蓝桥杯跟着直播来走 要刷一定量的题目，省一刷两百题 三百题左右，题目列表去做 自己耐心去调试，算法都在调试的能力，调试半小时以上 看到自己是个怎么样的水平，查漏补缺，模拟赛 国赛会讲解一些时间 把难度讲得更加平滑，在课上尽量听懂 基础课挺难的，知识点是基础的知识点 微积分是基础，难度是很难的 c11，万能头。。。？ 刷题量和调试 OI赛制，不太有激情 acm竞技性比较强 周日：讲课加知识点为主，周日是习题为主，扩展加习题为主 周六提高课 蓝桥杯的历年真题放到里面去 讲十个知识点 春节前 押题的性质 代码可以参考一下，作为笔记的功能 新功能上线，从开始写到AC的时间 考试的时候比的是一个熟练度 01背包4分钟写完 回放的功能 做题的套路模型比较少，知识点比较少，相对于数学物理 思维难度比较高，难度量比较大 写对并AC 先去看一下题目描述，抽象出来考察的模型，出题人想问的是什么东西 类似于爆搜的过程，解决不了就继续回溯，平时多去积累一些题目，积累装备积累金钱 如何去判断一个算法是否能用 正确性 时间和空间限制 是否会超时，时间是否达标 时间复杂度是否能打表c++评测机一秒只能搞108 18次方就是longlong的范围 卢卡斯定理 logn排序 出题人给了一个提示 n方dp lca问题，有作弊的成分 侧重于直播的课 递归怎么写学算法的时候，落实到代码上 能想出来但是写不出来， 123456789#include &lt;iostream&gt; //cin,cout建议加cstdio，algorithm有可能也有scanf#include &lt;cstdio&gt; //scanf#include &lt;cstring&gt; //memsetscanf 稍微长一点，难写一点，速度巨快c in c outcin，cout 速度稍慢小于5次方时间差不多快一倍左右 peding正在排队 输出好像差不多，输入差很多 分析递归的最常用的方式 递归搜索树 可能从左到右，也可能从右到左 递归就是自己调用自己 n–15 2的n次方 2的10次方背一下 2的20次方 一百万 32768 65536 2的63 递归递归dfs，顺序，不重不漏的全部找出来， n=3的时候，一开始的时候每个数都没有选 选或者不选就是慢慢的搜索，其实就是一颗递归树 空和选不选是不同的 记录的状态，选还是没选的状态要记录下来 状态就是st 除非自制力很强，很耽误时间 puts(“”) 空字符串加回车 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;const int N = 16;int n;int st[N]; // 状态，记录每个位置当前的状态：0表示还没考虑，1表示选它，2表示不选它vector&lt;vector&lt;int&gt;&gt; ways;void dfs(int u){ if (u &gt; n) { vector&lt;int&gt; way; for (int i = 1; i &lt;= n; i ++ ) // 记录方案 if (st[i] == 1) way.push_back(i); ways.push_back(way); return; } st[u] = 2; dfs(u + 1); // 第一个分支：不选 st[u] = 0; // 恢复现场 st[u] = 1; dfs(u + 1); // 第二个分支：选 st[u] = 0; // 恢复现场}int main(){ cin &gt;&gt; n; dfs(1); for (int i = 0; i &lt; ways.size(); i ++ ) { for (int j = 0; j &lt; ways[i].size(); j ++ ) printf(\"%d \", ways[i][j]); puts(\"\"); } return 0;} 依次枚举每个数放到每个位置 – 枚举和数字的数量有关 依次枚举每个位置放那个数 – 枚举和位置数有关 最好是边存值，然后有一个虚拟结点，其实也不算是虚拟结点，因为u那个地方已经表示为第一个位置了‘ 字典序最小–出题人比较懒，太麻烦了，要写一个程序 从小到大枚举就好了 全局变量初值一定是0 局部变量初值为随机值 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 10;int n;int state[N]; // 0 表示还没放数，1~n表示放了哪个数bool used[N]; // true表示用过，false表示还未用过void dfs(int u){ if (u &gt; n) // 边界 { for (int i = 1; i &lt;= n; i ++ ) printf(\"%d \", state[i]); // 打印方案 puts(\"\"); return; } // 依次枚举每个分支，即当前位置可以填哪些数 for (int i = 1; i &lt;= n; i ++ ) if (!used[i]) { state[u] = i; used[i] = true; dfs(u + 1); // 恢复现场 state[u] = 0; used[i] = false; }}int main(){ scanf(\"%d\", &amp;n); dfs(1); return 0;} 下周讲两个递推 斐波那契数列12345678910111213141516171819#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include &lt;iostream&gt;using namespace std;const int maxn =47;int fabonacci[maxn];int f(int n){ if(n==1) return 1; if(n==2) return 1; if(n&gt;2) return f(n-1)+f(n-2);}int main(){ int n; cout&lt;&lt;f(n)&lt;&lt;endl; } 递归实现指数型枚举1234567891011121314151617181920212223242526272829303132333435363738#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 16;int n; // 存储在全局变量的话有利于判断是否越界int vis[maxn]; // 如果有两种状态，一种是选了，一种是不选。则还要加上第三种，还没考虑void dfs(int u){ if (u &gt; n) { for (int i = 1; i &lt;= n; i++) { if (vis[i] == 1) printf(\"%d \", i); } puts(\"\"); return ; } else { vis[u] = 1; dfs(u + 1); vis[u] = 2; vis[u] = 0; dfs(u + 1); vis[u] = 2; } return ;}int main(){ scanf(\"%d\", &amp;n); dfs(1);} 费解的开关123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 6;int maze[maxn][maxn];int temp[maxn][maxn];//int step = 10000;int dir[4][2] = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};void turn(int x, int y){ temp[x][y] ^= 1; for (int i = 0; i &lt; 4; i++) { int dx = x + dir[i][0]; int dy = y + dir[i][1]; if (dx &lt;= 5 &amp;&amp; dx &gt; 0 &amp;&amp; dy &lt;= 5 &amp;&amp; dy &gt; 0) { temp[dx][dy] ^= 1; } } //temp[x][y] ^= 1;}void work(){ int step = 10000; int ans = 0; //memcpy(maze,temp,sizeof(maze)); for (int x = 0; x &lt; 1 &lt;&lt; 5; x++) { ans = 0; for (int j = 1; j &lt;= 5; j++) { if (x &gt;&gt; (j-1) &amp; 1) { ans++; turn(1, j); } } for (int i = 1; i &lt;= 5; i++) { for (int j = 1; j &lt;= 5; j++) { if (temp[i][j] == 0) { ans++; turn(i + 1, j); } } } bool flag = 1; for (int j = 1; j &lt;= 5; j++) { if (temp[5][j] == 0) { flag = 0; break; } } //cout &lt;&lt; step &lt;&lt; endl; if (flag == 1) { step = min(ans, step); } for (int i = 1; i &lt;= 5; i++) { for (int j = 1; j &lt;= 5; j++) { temp[i][j] = maze[i][j]; } } } if (step &gt; 6) cout &lt;&lt; \"-1\" &lt;&lt; endl; else cout &lt;&lt; step &lt;&lt; endl;}int main(){ int n; cin &gt;&gt; n; char ch; //ch = getchar(); while (n--) { ch = getchar(); for (int i = 1; i &lt;= 5; i++) { //ch = getchar(); for (int j = 1; j &lt;= 5; j++) { ch = getchar(); maze[i][j] = ch - '0'; temp[i][j] = maze[i][j]; } ch = getchar(); } // for (int i = 0; i &lt; 5; i++) // { // for (int j = 1; j &lt;= 5; j++) // { // cout&lt;&lt;maze[i][j]; // } // printf(\"\\n\"); // } work(); }} 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 7;int maze[maxn][maxn];int temp[maxn][maxn];int dir[4][2] = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};void turn(int x, int y){ temp[x][y] ^= 1; for (int i = 0; i &lt; 4; i++) { int dx = x + dir[i][0]; int dy = y + dir[i][1]; if (dx &lt; 5 &amp;&amp; dx &gt;= 0 &amp;&amp; dy &lt; 5 &amp;&amp; dy &gt;= 0) { temp[dx][dy] ^= 1; } } //temp[x][y] ^= 1;}void work(){ int step = 10000; int ans = 0; //memcpy(maze,temp,sizeof(maze)); for (int x = 0; x &lt; 1 &lt;&lt; 5; x++) { ans = 0; for (int j = 0; j &lt; 5; j++) { if (x &gt;&gt;j &amp; 1) { ans++; turn(0, j); } } for (int i = 0; i &lt; 4; i++) { for (int j = 0; j &lt; 5; j++) { if (temp[i][j] == 0) { ans++; turn(i + 1, j); } } } bool flag = 1; for (int j = 0; j &lt;5; j++) { if (temp[4][j] == 0) { flag = 0; break; } } //cout &lt;&lt; step &lt;&lt; endl; if (flag == 1) { step = min(ans, step); } for (int i = 0; i &lt; 5; i++) { for (int j = 0; j &lt; 5; j++) { temp[i][j] = maze[i][j]; } } } if (step &gt; 6) cout &lt;&lt; \"-1\" &lt;&lt; endl; else cout &lt;&lt; step &lt;&lt; endl;}int main(){ int n; cin &gt;&gt; n; char ch; while (n--) { ch = getchar(); for (int i = 0; i &lt; 5; i++) { for (int j = 0; j &lt; 5; j++) { ch = getchar(); maze[i][j] = ch - '0'; temp[i][j] = maze[i][j]; } ch = getchar(); } // for (int i = 0; i &lt; 5; i++) // { // for (int j = 1; j &lt;= 5; j++) // { // cout&lt;&lt;maze[i][j]; // } // printf(\"\\n\"); // } work(); }}","link":"/2019/12/01/蓝桥杯1 2（教学计划）/"},{"title":"","text":"贪心比较多 跳跃性比较强 结论证明很麻烦 找相似 DP找阶段找决策 三个贪心的模型和关系。怎么扩展题目 常用证明 差分 贪心的含义 找一个最优解 很短视，只会看当前 猜一下做法，再想一下怎么证明 贪心就是想一个策略 1234567891011121314151617181920212223242526272829#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 100010;int n;int price[N];int main(){ scanf(\"%d\", &amp;n); for (int i = 0; i &lt; n; i ++ ) scanf(\"%d\", &amp;price[i]); int res = 0; for (int i = 0; i + 1 &lt; n; i ++ ) { int dt = price[i + 1] - price[i]; if (dt &gt; 0) res += dt; } printf(\"%d\\n\", res); return 0;} 任何一个购买操作都等于一个集合 pending时间太长了 增加了五台评测机 因为会 越界 最后一天+1必定比最后一天小 上海落户 奇数个仓库是中间，偶数个仓库是距离中间 贪心是数学化，推公式 用公式化来表示 把数学模型抽象成贪心的题 看下标 因为1-n，2-n-1 这样的 越来越缩小区间了 慢慢就逼近到中间 12345678910111213141516171819202122232425262728#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;typedef long long LL;const int N = 100010;int n;int x[N];int main(){ scanf(\"%d\", &amp;n); for (int i = 0; i &lt; n; i ++ ) scanf(\"%d\", &amp;x[i]); sort(x, x + n); int c = x[n / 2]; LL res = 0; for (int i = 0; i &lt; n; i ++ ) res += abs(x[i] - c); printf(\"%lld\\n\", res); return 0;} 换成了9.2.1 用的不是flash所以延迟会高一点 亚研院中关村 糖果传递 毕设，推荐系统 推荐课表 最终一定有解 n个方程，n-1个未知数，所以可能是无解 每一个数字都能被其他的代替 找中位数 下标从一开始，所以是0 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;typedef long long LL;const int N = 1000010;int n;int a[N];LL c[N];int main(){ scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; i ++ ) scanf(\"%d\", &amp;a[i]); LL sum = 0; for (int i = 1; i &lt;= n; i ++ ) sum += a[i]; LL avg = sum / n; for (int i = n; i &gt; 1; i -- ) { c[i] = c[i + 1] + avg - a[i]; } c[1] = 0; sort(c + 1, c + n + 1); LL res = 0; for (int i = 1; i &lt;= n; i ++ ) res += abs(c[i] - c[(i + 1) / 2]); printf(\"%lld\\n\", res); return 0;} 玩了saber 终于跟上yls的代码速度1/3了 剑指offer的某个找中点之类的题 每个人用之前要评论老师 就是从所有岛从最右边开始，找到能够覆盖这个岛的最远的雷达 重叠 之前是覆盖的圆的部分，圆的并集 变成了一个线段的问题 现在是找容忍区间 最少选几个点能让 女少口阿 给一堆区间，找到一个策略，能达到我们的问题 整理这类问题，然后不同条件是哪些 将所有区间按端点排序 扫描每个线段 如果上一个点（前一次选出来的那个点）不在区间里面，就选右段点因为我们更有可能覆盖右边的区间 贪心问题就是不容易爬上这个墙 区间选点905 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;int ans=0;struct point{ double l,r;}a[1005];int d,bj=0;bool cmp(const point &amp;x,const point &amp;y){return x.l&lt;y.l;}void jisuan(int i,double x,double y){ double t=d*d-y*y; if(t&lt;0){bj=1;return;} a[i].l=x-sqrt(t); a[i].r=x+sqrt(t);}int main(){ int n,t=0; cin&gt;&gt;n&gt;&gt;d; t++;bj=0; for(int i=1;i&lt;=n;i++) { int x,y; scanf(\"%d%d\",&amp;x,&amp;y); jisuan(i,x,y); } sort(a+1,a+n+1,cmp); double pos=-0x7fffffff/2; for(int i=1;i&lt;=n;i++) { if(a[i].l&gt;pos) { ans++; pos=a[i].r; } else pos=min(pos,a[i].r); } if(bj==1||d&lt;0) { printf(\"-1\\n\"); } else printf(\"%d\\n\",ans); return 0;} seg={}是C11的语法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int N = 1010;int n, d;struct Segment{ double l, r; bool operator&lt; (const Segment&amp; t) const { return r &lt; t.r; }}seg[N];int main(){ scanf(\"%d%d\", &amp;n, &amp;d); bool failed = false; for (int i = 0; i &lt; n; i ++ ) { int x, y; scanf(\"%d%d\", &amp;x, &amp;y); if (y &gt; d) failed = true; else { double len = sqrt(d * d - y * y); seg[i].l = x - len, seg[i].r = x + len; } } if (failed) { puts(\"-1\"); } else { sort(seg, seg + n); int cnt = 0; double last = -1e20; for (int i = 0; i &lt; n; i ++ ) if (last &lt; seg[i].l) { cnt ++ ; last = seg[i].r; } printf(\"%d\\n\", cnt); } return 0;} 想问y总 ccf csp 咋准备 跟蓝桥杯比难度怎么样 csp比蓝桥杯简单 ccf","link":"/2020/02/02/蓝桥杯13讲（贪心）/"},{"title":"","text":"费解的开关翻硬币传统做法 初始状态，一些可以进行的操作，最少进行几步，从初始到目标状态 1.宽搜，状态看成是一个点，求两个点的最短距离 状态数量很多，局面很多 最坏需要50步 50的99次方 50步，每一种有99步 摁或者不摁 解只有一组解或者无解，是定死的 不是最优化而是模拟的问题，dp就是递推 最短路有向无环图 飞行员兄弟前面是可以通过某种顺序，只允许一个地方影响这个灯泡 暴力搜索的范围 字典序比较 小于一个亿就ok 枚举一更靠前的数 同一种步数是不是唯一的呢？ 高斯消元 5，最后有一个/0 https://www.acwing.com/activity/content/code/content/160005/ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#define x first#define y secondusing namespace std;typedef pair&lt;int, int&gt; PII;const int N = 5;char g[N][N], backup[N][N];int get(int x, int y){ return x * 4 + y;}void turn_one(int x, int y){ if (g[x][y] == '+') g[x][y] = '-'; else g[x][y] = '+';}void turn_all(int x, int y){ for (int i = 0; i &lt; 4; i ++ ) { turn_one(x, i); turn_one(i, y); } turn_one(x, y);}int main(){ for (int i = 0; i &lt; 4; i ++ ) cin &gt;&gt; g[i]; vector&lt;PII&gt; res; for (int op = 0; op &lt; 1 &lt;&lt; 16; op ++ ) { vector&lt;PII&gt; temp; memcpy(backup, g, sizeof g); // 备份 // 进行操作 for (int i = 0; i &lt; 4; i ++ ) for (int j = 0; j &lt; 4; j ++ ) if (op &gt;&gt; get(i, j) &amp; 1) { temp.push_back({i, j}); turn_all(i, j); } // 判断所有灯泡是否全亮 bool has_closed = false; for (int i = 0; i &lt; 4; i ++ ) for (int j = 0; j &lt; 4; j ++ ) if (g[i][j] == '+') has_closed = true; if (has_closed == false) { if (res.empty() || res.size() &gt; temp.size()) res = temp; } memcpy(g, backup, sizeof g); // 还原 } cout &lt;&lt; res.size() &lt;&lt; endl; for (auto op : res) cout &lt;&lt; op.x + 1 &lt;&lt; ' ' &lt;&lt; op.y + 1 &lt;&lt; endl; return 0;} 只是支持c99 负数取模还是负数，会越界 每次定义了一个新的就不用清空 会卡空格末回车 二分 确定一个区间，使得答案一定在区间中 二分其实是想一个性质，是边界 二段性百分之95的二分 一段满足，后面不满足。中间是无缝衔接的，没有缺失的地方。 答案是二段性的分界点 整数二分一个是左区间的终点，一种是右区间的起点 一、 左区间的终点（就等于找终点） 就等于我们找的其实是左边，最后的变化都是移动左边的指针。 不补一的话，如果我们算两个值。他的左边界一直都是左边界，永远跳不出循环。 L=M就补上加一 二、右区间的起点（就等于找起点） 因为我们要找的其实是MID。那么，如果我们要找右区间的起点，也就是要压缩右边的指针，来找到MID 123456将L,R分成L,M M+1,Rwhile(l&lt;r) m=l+r/2 if(m is green) R=M else L=M+1； 区间只有一个数字不会死循环，会直接退出 整数二分步骤： 找一个区间[L, R]，使得答案一定在该区间中 找一个判断条件，使得该判断条件具有二段性，并且答案一定是该二段性的分界点。 分析终点M在该判断条件下是否成立，如果成立，考虑答案在哪个区间；如果不成立，考虑答案在哪个区间； 如果更新方式写的是R = Mid，则不用做任何处理；如果更新方式写的是L = Mid，则需要在计算Mid时加上1。 是R=M,还是L=M 第一种是 L-MID MID+1 - N 第二种是 L-MID-1, MID -N 要找的是哪个位置就分为哪两段，然后移动的话就看MID的位置就可以移动了 数的范围1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 100005;int num[maxn];int main(){ int n, q; cin &gt;&gt; n &gt;&gt; q; for (int i = 1; i &lt;= n; i++) { scanf(\"%d\", &amp;num[i]); } while (q--) { int x; scanf(\"%d\", &amp;x); int l = 1, r = n; while (l &lt; r) // 寻找起点，即右边区间的起点 { int mid = l + r &gt;&gt; 1; if (num[mid] &gt;= x) r = mid; else l = mid + 1; } if (num[l] == x) printf(\"%d \", l-1); else printf(\"-1 \"); l = r; r = n; while (l &lt; r) // 寻找起点，即右边区间的起点 { int mid = (l + r + 1) &gt;&gt; 1; if (num[mid] &lt;= x) l = mid; else r = mid - 1; } if (num[l] == x) printf(\"%d \\n\", r-1); else printf(\"-1 \\n\"); }} 数学定理，公式讲了一遍，套公式，就可以了 不存在重复数字的，怎么写二分都一样？ 实数是可以恰好取到终点的，因为实数是稠密 区间长度足够小的时候就停止 数的三次方根1234567891011121314151617181920#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;int main(){ double n; scanf(\"%lf\",&amp;n); double left = -100; double right = 100; while (right-left &gt; 1e-8) // 加两位比较保险，如果两个不相等就循环 { double mid = (left+right)/2; // 实数二分不用讨论加减一的情况 if(mid*mid*mid&gt;=n) right= mid; else left= mid; } printf(\"%.6lf\",left); } 二分就是，如果找到的那个位置只有一个数字了，说明一定是这个值 不用讨论加减一的情况其实是划分区间的时候没有存在加减一的情况。 三分单峰，单股函数 大部分函数求导，对斜率的二分 斜率其实是后一个数减前一个数 两个三等分点，每次乘以2/3，这样就能不断的缩小区间 有水平的一段，三分法就不能用了","link":"/2019/12/08/蓝桥杯3（二分）/"},{"title":"","text":"算术基本定理分解成质因子组成的形式 第二个序列就是某一个质因子 x的所有质因子的排列数 6的阶乘除以3的阶乘 A22*A33 多重集合的排列数问题 如何分解质因数 筛法求素数，线性筛法o(N)的复杂度内求出所有的素数，以及每个数的最小质因子 prime存所有的质数，cnt有多少个 当前的数有没有被筛选过 st是一个bool值，看看有没有被筛选过 1表示被筛选过 两重循环，绝对是O（n）的 从小到大枚举所有的质数 筛掉的一定是合数，且一定是用最小质因子筛选的，用其最小质因子 有Pj一定不大于i的最小质因子 合数是否一定会被筛选掉 每次都能找到最小质因子 先求1-n-1里面所有的质因子 -1就是EOF 一共有多少个因子，最多有20个因子，因为20个因子的时候已经是最大的数字了 minp[x]表示为x的最小质因数 求一下总共的质数 20的阶乘 long long是2*10^64次方？？？ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;typedef long long LL;const int N = (1 &lt;&lt; 20) + 10;int primes[N], cnt;int minp[N];bool st[N];void get_primes(int n){ for (int i = 2; i &lt;= n; i ++ ) { if (!st[i]) { minp[i] = i; primes[cnt ++ ] = i; } for (int j = 0; primes[j] * i &lt;= n; j ++ ) { int t = primes[j] * i; st[t] = true; minp[t] = primes[j]; if (i % primes[j] == 0) break; } }}int main(){ get_primes(N - 1); int fact[30], sum[N]; int x; while (scanf(\"%d\", &amp;x) != -1) { int k = 0, tot = 0; while (x &gt; 1) { int p = minp[x]; fact[k] = p, sum[k] = 0; while (x % p == 0) { x /= p; sum[k] ++ ; tot ++ ; } k ++ ; } LL res = 1; for (int i = 1; i &lt;= tot; i ++ ) res *= i; for (int i = 0; i &lt; k; i ++ ) for (int j = 1; j &lt;= sum[i]; j ++ ) res /= j; printf(\"%d %lld\\n\", tot, res); } return 0;} 把逻辑背过就行了 聪明的燕姿约数和定理 有多少个约数 有多少种选法 有多少个正整数约数之和 课后预习 小学数奥是猜和枚举 编程是逻辑为主 为什么个数比较少？因为我加到6的时候已经超过数据范围了 个数比较少，所以可能要用爆搜 枚举P和α 爆搜的顺序一定要想清楚 可能要想一些剪枝，s除以logn个 判断质数的话可以用线性筛里面的那个st表吧 cin很顺不用来回动光标。能用cin就用cin 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 50000;int primes[N], cnt;bool st[N];int ans[N], len;void get_primes(int n){ for (int i = 2; i &lt;= n; i ++ ) { if (!st[i]) primes[cnt ++ ] = i; for (int j = 0; primes[j] * i &lt;= n; j ++ ) { st[primes[j] * i] = true; if (i % primes[j] == 0) break; } }}bool is_prime(int x){ if (x &lt; N) return !st[x]; for (int i = 0; primes[i] &lt;= x / primes[i]; i ++ ) if (x % primes[i] == 0) return false; return true;}void dfs(int last, int prod, int s){ if (s == 1) { ans[len ++ ] = prod; return; } if (s - 1 &gt; (last &lt; 0 ? 1 : primes[last]) &amp;&amp; is_prime(s - 1)) ans[len ++ ] = prod * (s - 1); for (int i = last + 1; primes[i] &lt;= s / primes[i]; i ++ ) { int p = primes[i]; for (int j = 1 + p, t = p; j &lt;= s; t *= p, j += t) if (s % j == 0) dfs(i, prod * t, s / j); }}int main(){ get_primes(N - 1); int s; while (cin &gt;&gt; s) { len = 0; dfs(-1, 1, s); cout &lt;&lt; len &lt;&lt; endl; if (len) { sort(ans, ans + len); for (int i = 0; i &lt; len; i ++ ) cout &lt;&lt; ans[i] &lt;&lt; ' '; cout &lt;&lt; endl; } } return 0;} 解题技巧创造出来 算法创造出来比较少 last上一个质数，避免重复枚举 product村的 是乘积，存的是答案的因式分解的成绩 五指山裴蜀定理 扩展欧几里得算法可以解决裴蜀定理 可以求一组解 可以使 ax0+by0 = d 所有解的形式是什么 为什么一定是这种形式，可以使用反证法或者正推 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;typedef long long LL;LL exgcd(LL a, LL b, LL &amp;x, LL &amp;y){ if (!b) { x = 1, y = 0; return a; } LL d = exgcd(b, a % b, y, x); y -= a / b * x; return d;}int main(){ int T; scanf(\"%d\", &amp;T); while (T -- ) { LL n, d, x, y, a, b; scanf(\"%lld%lld%lld%lld\", &amp;n, &amp;d, &amp;x, &amp;y); int gcd = exgcd(n, d, a, b); if ((y - x) % gcd) puts(\"Impossible\"); else { b *= (y - x) / gcd; n /= gcd; printf(\"%lld\\n\", (b % n + n) % n); } } return 0;}n","link":"/2020/02/09/蓝桥杯14讲/"},{"title":"","text":"时间效率差不多， 哈希的实际效果差不多 机器人跳跃问题整数，不是小数 最少或者最大是多少，可以用二分来做 是否具有二段性，或者是否用单调性。答案的单调性，答案可能的区间 二分就是在答案序列中快速搜索我们需要的值 我们二分的时候，我们要看我们找的是红色区间的终点还是绿色区间的起点 lowerbound，要传一个pair函数 因为E=2E-h，如果h很小的话，每次都约等于乘以2.所以很可能会爆掉int int最大是2的32次方 递推式子的观察： 假设中间建筑物的高度为max_h。只要某一个时刻大于等于max_h它就会开始递增了 递推的On的做法 max_h直接读入的时候输入或者10的五次方也行。 想清楚一遍就可以不用再想了 maxn加10个位置，是因为我们可能会用到第n个位置 第一步是找到答案的可能性 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 100010;int n;int h[N];bool check(int e){ for (int i = 1; i &lt;= n; i ++ ) // 从前往后去递推我们的E { e = e * 2 - h[i]; if (e &gt;= 1e5) return true; if (e &lt; 0) return false; } return true;}int main(){ scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; i ++ ) scanf(\"%d\", &amp;h[i]); int l = 0, r = 1e5; while (l &lt; r) { int mid = l + r &gt;&gt; 1; if (check(mid)) r = mid; else l = mid + 1; } printf(\"%d\\n\", r); return 0;} 四平方和递归要去看一下 四元组 n小于五百万 时间复杂度的问题 空间越来越不值钱了 可以开十亿个int cpu的运行速度，每秒也只能10的八次方 量子编程，cpu要两三千 只要枚举三个数字 只能枚举两个数字 考虑用空间换时间， 枚举的时候，三重循环 枚举一半，把一般的结果存起来 存起来是n方的复杂度，再枚举a和b 有没有出现呢，哈希，ologn 把c方和d方存起来，组合存起来，差值是否出现过 如何枚举字典序最小的解 哈希表可以只存字典序最小的一个解 其实是除以2，因为a&lt;b 没有循环次数超过十万的数据 二分的方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int N = 2500010;struct Sum{ int s, c, d; bool operator&lt; (const Sum &amp;t)const { if (s != t.s) return s &lt; t.s; if (c != t.c) return c &lt; t.c; return d &lt; t.d; }}sum[N];int n, m;int main(){ cin &gt;&gt; n; for (int c = 0; c * c &lt;= n; c ++ ) for (int d = c; c * c + d * d &lt;= n; d ++ ) sum[m ++ ] = {c * c + d * d, c, d}; sort(sum, sum + m); for (int a = 0; a * a &lt;= n; a ++ ) for (int b = 0; a * a + b * b &lt;= n; b ++ ) { int t = n - a * a - b * b; int l = 0, r = m - 1; while (l &lt; r) { int mid = l + r &gt;&gt; 1; if (sum[mid].s &gt;= t) r = mid; else l = mid + 1; } if (sum[l].s == t) { printf(\"%d %d %d %d\\n\", a, b, sum[l].c, sum[l].d); return 0; } } return 0;} 哈希表order_map 和相同，我们存最小的 只要存第一个，因为字典序是最小的 写的代码太好看了 二分是n方logn 哈希是n2，常数是不一样的 数组哈希会快一点 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;unordered_map&gt;#define x first#define y secondusing namespace std;typedef pair&lt;int, int&gt; PII;const int N = 2500010;int n, m;unordered_map&lt;int, PII&gt; S;int main(){ cin &gt;&gt; n; for (int c = 0; c * c &lt;= n; c ++ ) for (int d = c; c * c + d * d &lt;= n; d ++ ) { int t = c * c + d * d; if (S.count(t) == 0) S[t] = {c, d}; } for (int a = 0; a * a &lt;= n; a ++ ) for (int b = 0; a * a + b * b &lt;= n; b ++ ) { int t = n - a * a - b * b; if (S.count(t)) { printf(\"%d %d %d %d\\n\", a, b, S[t].x, S[t].y); return 0; } } return 0;} 所有测试数据总共的时间 暴力法12345678910111213141516171819202122232425262728293031#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cmath&gt;using namespace std;typedef long long ll;int main(){ ll n; cin &gt;&gt; n; for (int i = 0; i &lt; sqrt(5 * 1e6 / 4); i++) { for (int j = i; j &lt; sqrt(5 * 1e6 / 3); j++) { for (int k = j; k &lt; sqrt(5 * 1e6 / 2); k++) { ll l = n - i * i - j * j - k * k; ll d = sqrt(l); if (d * d == l) { printf(\"%d %d %d %d\\n\", i, j, k, d); return 0; } } } } // 判断一个数开根号之后是否为整数，sqrt（i）*sqrt（i） 是否等于i} 不能直接break，因为break的时候只是退出了当前循环，如果要结束的话应该return 0， 如果要跳出多重循环的话，就用goto L L：return0； 因为我们要输出第四个数，但是第四个数会因为开根号的原因，会变得异常，所以要用根号来判断 分巧克力边长越大切出来的块数就越小 最多取得块数是下取整 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 100010;int n, k;int h[N], w[N];bool check(int mid){ int res = 0; for (int i = 0; i &lt; n; i ++ ) { res += (h[i] / mid) * (w[i] / mid); // 不加括号就是先 if (res &gt;= k) return true; } return false;}int main(){ scanf(\"%d%d\", &amp;n, &amp;k); for (int i = 0; i &lt; n; i ++ ) scanf(\"%d%d\", &amp;h[i], &amp;w[i]); int l = 1, r = 1e5; while (l &lt; r) { int mid = l + r + 1 &gt;&gt; 1; if (check(mid)) l = mid; else r = mid - 1; } printf(\"%d\\n\", r); return 0;} 如果小于等于mid都成立，那就直接变成l=mid，为什么不是l=mid+1呢，因为可能只有mid一个答案。然后else的话就是。mid也不成立，只有mid-1以下的才行 估算log的计算次数。10^5是十万，然后2^16次方是多少，2^17次方是多少 N块巧克力，有10的五次方块巧克力要去尝试 前缀和快速得到某一个区间的和。（差分的思想） 1234567891011121314151617181920212223242526272829303132#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 100010;int n, m;int a[N]; // 表示原数组int s[N]; // 表示前缀和数组int main(){ scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 1; i &lt;= n; i ++ ) { scanf(\"%d\", &amp;a[i]); s[i] = s[i - 1] + a[i]; } while (m -- ) { int l, r; scanf(\"%d%d\", &amp;l, &amp;r); printf(\"%d\\n\", s[r] - s[l - 1]); } return 0;} 是什么，为什么，怎么做 做题太少根本不知道有什么应用 用容斥原理的思想 如何利用前缀和矩阵计算某一个子矩阵的和 建议大家用什么，bufferuser来写 1234567891011121314151617181920212223242526272829303132#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 1010;int n, m, q;int a[N][N], s[N][N];int main(){ scanf(\"%d%d%d\", &amp;n, &amp;m, &amp;q); for (int i = 1; i &lt;= n; i ++ ) for (int j = 1; j &lt;= m; j ++ ) { scanf(\"%d\", &amp;a[i][j]); s[i][j] = s[i - 1][j] + s[i][j - 1] - s[i - 1][j - 1] + a[i][j]; } while (q -- ) { int x1, y1, x2, y2; scanf(\"%d%d%d%d\", &amp;x1, &amp;y1, &amp;x2, &amp;y2); printf(\"%d\\n\", s[x2][y2] - s[x1 - 1][y2] - s[x2][y1 - 1] + s[x1 - 1][y1 - 1]); } return 0;} 这个数字代表的是以这个数字作为矩阵右下角的一个和矩阵 104个知识点","link":"/2019/12/13/蓝桥杯4（二分习题课）/"},{"title":"","text":"闫式dp法 想算一下 123 * 123 列竖式就简单很多 用竖式的方式简单很多 打草稿的方式理解dp问题 分为两个步骤 化零为整 求两大类值，最大或者最小 求个数，方案数是多少 问一个集合，集合里面的属性。每一个方案的 共性的零散的方案放到集合当中，集合划分的过程 化整为零 把集合又进行划分 01背包走法的问题 若干的东西，要挑一些东西出来 问题模型：其实是，组合模型 问我们，假设有一堆物品，挑一些出来，满足限制的条件下，所有组合里面最好的是什么 1000就是一个平方级别的算法 状态*转移大概是$n(n^2)$ 的东西 化零为整主要是 状态表示的过程，只能有二维。 F[I,J] 状态表示 集合 集合里面是一个怎么样的集合呢。所有只从前i个物品中选，且总体积不超过j的所有方案的集合。有跳跃性就意味着以后我们推导有问题。 数和集合的关系 数是集合的某个属性，就是min/max/count 化整为零 怎么算F[i,j] 不重不漏的子集。划分集合 找最后一个不同点，能区分开，有区分度的地方 测不准原理 有k个方案，前面有多少无所谓，最后一个必须包含i 一部分是变化的部分，一部分是不变的部分 全部减去了10分，不会影响最高分是谁 将所有方案同时减去第i个物品，然后找最大值，然后最大值再把第i个物品加上 集合也是看问的是什么，合法方案的最大值 控制一百万到一千万6-7之间 01背包是组合模型，这个是路线的模型还有一种是线性的模型 找不同，左边是第一大类，从上往下走 右边是从最后一步是从左往右走 考高分那个问题 找不同 闫分析法最重要就是划分，正确划分完了之后处理一下边界问题基本就没问题了算 是的。。我现在觉得最难搞就是边界。。 对称的一个思想，地位等同 DP边界问题其实就相当一递归的出口。 以这个结尾的子序列是怎么样的 初始化怎么去做，初始化就是为了状态计算和状态含义去做的 有疑问的话从原始定义出发主要是保证每个位置的状态是对的 恰好有k件的物品有多少种 状态数量505012*13 三十多万，四十万 25大概就是一个状态转移的计算量 乍一看以为是什么其实就是一个刷题的经验 缝合怪，模型就那么几种，考试就轻轻松松 学到家了！！！ 分成四类，取或者是不取 边界值怎么设置 只需要看起点就ok了 选择起点 10的9次方加7 2.多 乘以十的9次方，INT_max 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 55, MOD = 1000000007;int n, m, k;int w[N][N];int f[N][N][13][14];int main(){ cin &gt;&gt; n &gt;&gt; m &gt;&gt; k; for (int i = 1; i &lt;= n; i ++ ) for (int j = 1; j &lt;= m; j ++ ) { cin &gt;&gt; w[i][j]; w[i][j] ++ ; } f[1][1][1][w[1][1]] = 1; f[1][1][0][0] = 1; for (int i = 1; i &lt;= n; i ++ ) for (int j = 1; j &lt;= m; j ++ ) { if (i == 1 &amp;&amp; j == 1) continue; for (int u = 0; u &lt;= k; u ++ ) for (int v = 0; v &lt;= 13; v ++ ) { int &amp;val = f[i][j][u][v]; val = (val + f[i - 1][j][u][v]) % MOD; val = (val + f[i][j - 1][u][v]) % MOD; if (u &gt; 0 &amp;&amp; v == w[i][j]) { for (int c = 0; c &lt; v; c ++ ) { val = (val + f[i - 1][j][u - 1][c]) % MOD; val = (val + f[i][j - 1][u - 1][c]) % MOD; } } } } int res = 0; for (int i = 0; i &lt;= 13; i ++ ) res = (res + f[n][m][k][i]) % MOD; cout &lt;&lt; res &lt;&lt; endl; return 0;} 思路正确，代码的熟练度 肌肉记忆 考察的不是我们的创造力，是我们的记忆力 组合，背包 路线 序列 树的 连通性 状态压缩 背包类型的变形 波动数列刚才点外卖的时候，我突然想起来我已经160斤了，于是我狠狠地抽了自己一嘴巴！点外卖的时候怎么能分心呢 限制只有一个，第一项没有限制，可以是正可以是负 只能是加a或者减b 线性方程，有n个变量的的等式，然后可以变成n-1的变量 集合映射的关系 是n的倍数 有多少种不同的选法，使得s-这个值是n的倍数 一堆方案让我找到满足方案的要求的数量 背包的背景就是组合问题 所有前i个物品，只考虑前i项，且当前的总和除以n的余数是j 选法，其实都是背包问题 不换的话di乘以n-i 除0错误 1234567891011121314151617181920212223242526272829#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 1010, MOD = 100000007;int f[N][N];int get_mod(int a, int b) // 求a除以b的正余数{ return (a % b + b) % b; // 模完之后就会有负b减一到正b减一之间}int main(){ int n, s, a, b; cin &gt;&gt; n &gt;&gt; s &gt;&gt; a &gt;&gt; b; f[0][0] = 1; for (int i = 1; i &lt; n; i ++ ) for (int j = 0; j &lt; n; j ++ ) f[i][j] = (f[i - 1][get_mod(j - a * i, n)] + f[i - 1][get_mod(j + b * i, n)]) % MOD; cout &lt;&lt; f[n - 1][s % n] &lt;&lt; endl; return 0;} 每个位置有两种选择，然后大概有2^1000次方种方案 2的31次方已经一亿多了 没有单调性所以只能搞出一维来 如果不换下标的话，dn-1是最后一次选的是+a，这里的a应该只被加过一次趴😭 n-i就是不换下标是一样的 大于等于0，小于等于n 正余数返回正余数，负余数返回负余数 负数取模 dp问题和最短路问题其实是最短路问题，其实是有向无环图上的 dp是有向无环图 如果允许用多次的话就是很复杂的问题 数字三角形路径是线性的吧 最大流问题有模板吗 sup spfa dilic 有限制的话就是用最大费用的最大流就可以了 有环dp是不行，dp是特殊的图论 上限是noip set，只会让我们去用set 不会真的让我们去写平衡树 j只要取遍n的余数就可以了 只会考比较经典的内容，针对特点来讲","link":"/2019/12/23/蓝桥杯6（数学与简单DP习题课）/"},{"title":"","text":"学东西氛围里面很重要 靠自己的约束力比较难的一件事情 不能旋转，能旋转的话，就是离散化了，或者是最小覆盖 错位与不错位的问题，能框r+1个点 计算机的计算次数 i-r+1 —计算某个数字和某个数字相差三个位置的话，其实index只相差了2 时间复杂度：n-r+！ #define是在编译的预处理阶段起作用，而const是在 编译、运行的时候起作用 五千万个int 五千万4个bite / 10241024 这里不超空间是因为操作系统会对我们进行优化 #define只是简单的字符替换，没有类型检查,存在边界的错误，但是const对应数据类型，进行类型检查 define会快一些 一维会规定s0等于0 在算前缀和的时候，sr-sl-1，会出现越界。自动移到大于等于一的位置。 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 5010;int n, m;int s[N][N];int main(){ int cnt, R; cin &gt;&gt; cnt &gt;&gt; R; R = min(5001, R); n = m = R; while (cnt -- ) { int x, y, w; cin &gt;&gt; x &gt;&gt; y &gt;&gt; w; x ++, y ++ ; n = max(n, x), m = max(m, y); s[x][y] += w; } // 预处理前缀和 for (int i = 1; i &lt;= n; i ++ ) for (int j = 1; j &lt;= m; j ++ ) s[i][j] += s[i - 1][j] + s[i][j - 1] - s[i - 1][j - 1]; int res = 0; // 枚举所有边长是R的矩形，枚举(i, j)为右下角 for (int i = R; i &lt;= n; i ++ ) for (int j = R; j &lt;= m; j ++ ) res = max(res, s[i][j] - s[i - R][j] - s[i][j - R] + s[i - R][j - R]); cout &lt;&lt; res &lt;&lt; endl; return 0;} 大方向大家都差不多，都是在细节上出问题。一出问题就慌，然后就麻烦了 segment fault k倍区间先优化，想想有没有做过类似的题目 不用通过循环来求cnt 十的八次方 12345678910for(r = 1;r &lt;= n ;r++) for(l = 1;l &lt;= r;l++) { int sum = 0; for(i = l;i &lt;= r;i++) { sum += a[i]; if(sum%k==0) res++; } } 算区间和可以优化成前缀和 s[r]-s[l-1] 1-r -&gt; 0-r-1 找他之前的有几个余数相同的数字 还能怎么优化呢 当R固定时，在1-r之间找到有多少个L满足我们的K倍区间 空间换时间，拿一些空间换很多时间 1234567891011121314151617181920212223242526272829303132333435#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;typedef long long LL;const int N = 100010;int n, k;LL s[N], cnt[N];int main(){ scanf(\"%d%d\", &amp;n, &amp;k); for (int i = 1; i &lt;= n; i ++ ) { scanf(\"%lld\", &amp;s[i]); s[i] += s[i - 1]; } LL res = 0; cnt[0] = 1; for (int i = 1; i &lt;= n; i ++ ) { res += cnt[s[i] % k]; cnt[s[i] % k] ++ ; } printf(\"%lld\\n\", res); return 0;} 边界问题 写之前想一下有没有边界问题 凑数据来调试 前缀和最大是十万的平方，为什么，因为最多有十万个数字，然后每个数字最大为十万。所以是十万的平方。 int最大为2^9次方 cnt[0]为什么等于1 错误答案 segmentation fault exit（0）不管在什么地方也会跳出程序。类似于二分的思路 5*10的9次方，每个数字都是k，就会爆 有些东西只能通过练习来提高 记忆性，背一遍就可以了 还有一些是能力性，逻辑性，一步一步来，一步是怎么来的。把一步一步记住 要多练才可以了 买不到的数目 打表找规律 尽力分析。。。公约数大于1 互质是否，裴蜀定理 https://www.acwing.com/solution/acwing/content/3165/ 高中竞赛还是 homo都是程序员 打表就是一个暴力的问题 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;using namespace std;bool dfs(int m, int p, int q){ if (!m) return true; // if(dfs(m-p, p, q) &amp;&amp; (p&lt;=m)) return true; // if(dfs(m-q, p, q) &amp;&amp; (q&lt;=m)) return true; if ((p &lt;= m) &amp;&amp; dfs(m - p, p, q)) // 因为p可能大于m了，所以要先判断，不然又一次进入dfs的话会出错 return true; if ((q &lt;= m) &amp;&amp; dfs(m - q, p, q)) return true; return false;}int main(){ int q, p; cin &gt;&gt; p &gt;&gt; q; int res = 0; for (int i = 1; i &lt;= 1001; i++) { if (!dfs(i, p, q)) res = i; } cout &lt;&lt; res &lt;&lt; endl; return 0;}/*通过打表得到3 2 13 4 53 5 73 7 113 8 13也就是说，m等于两倍的q加上某个数。因为m的变化量和q的变化量一样，差值只是在y轴的值不一样然后我们就可以发现是2q-3其中，2是q-1.然后我们通过对称性可知，既然有q-1，也就有p-1。然后再猜测就得到了(p-1)*(q-1) -1*/ m之所以是两倍的n加上某个数，是因为变化量是2，但是要加上某个数 对称性，所有有q-1和p-1 12 蚂蚁感冒 首先判断是否会走下这个栏杆。因为可能会一直撞 会 看两端的应该就会走掉 从前向后看，两个蚂蚁只要方向不同ans++，如果不同接着向后看 相当于交换了 减治法 两端的一定会掉，掉了之后，原本在左右侧倒数第二个的就变成两端了，又一定会掉，以此类推，全部都会掉下去 队列？ 看有病的穿了几个 假如你站在飞机上 然后去看这一行蚂蚁 ，你就会看到一个恐怖的现象，感觉灵魂穿越 脑补一下 秒啊 就是y总说的这个 两个蚂蚁交换了灵魂，虽然掉头了，但是还是往前走 ants poj https://www.luogu.com.cn/problemnew/solution/P1007 因为 相撞之后状态相同 运行轨迹不变 两只蚂蚁都感冒了 因为两个都被感染了，而且速度相同 速度相同才是关键 1234567891011121314151617181920212223242526#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 55;int n;int x[N];int main(){ cin &gt;&gt; n; for (int i = 0; i &lt; n; i ++ ) cin &gt;&gt; x[i]; int left = 0, right = 0; // 分别表示左边向右走的蚂蚁数量，和右边向左走的蚂蚁数量 for (int i = 1; i &lt; n; i ++ ) if (abs(x[i]) &lt; abs(x[0]) &amp;&amp; x[i] &gt; 0) left ++ ; else if (abs(x[i]) &gt; abs(x[0]) &amp;&amp; x[i] &lt; 0) right ++ ; if (x[0] &gt; 0 &amp;&amp; right == 0 || x[0] &lt; 0 &amp;&amp; left == 0) cout &lt;&lt; 1 &lt;&lt; endl; else cout &lt;&lt; left + right + 1 &lt;&lt; endl; return 0;} 饮料换购小学数奥的题目 每次往队列里面放 上取整，ceil是double类型 上取整变成下取整 12345678910111213141516171819202122232425#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;cmath&gt;using namespace std;int main(){ int n; int sum = 0; // 储存总共喝的数目 int temp_cup = 0; // 储存当前所剩的瓶盖数 int temp_sum = 0; // 储存当前所剩的总的瓶盖 int temp_bottle = 0; // 储存当前能用瓶盖买几瓶 scanf(\"%d\",&amp;n); sum = n; temp_sum = n; while (temp_sum&gt;=3) { temp_bottle = floor(temp_sum/3); temp_cup = temp_sum%3; sum += temp_bottle; temp_sum = temp_bottle+temp_cup; } cout&lt;&lt;sum&lt;&lt;endl; 云端上线 地宫寻宝暴力dfs1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;using namespace std;const int maxn = 56;int mp[maxn][maxn];int vis[maxn][maxn];int dir[2][2] = {{0, 1}, {1, 0}};int n, m, k;int max_item;int ans;bool check1(int x, int y) // 判断是否有越界{ if (x &gt; 0 &amp;&amp; x &lt;= n &amp;&amp; y &gt; 0 &amp;&amp; y &lt;= m) return true; else return false;}// bool check2(int now, int pre, int cnt)// {// if (cnt == k)// return true;// else// {// if (now &gt; pre)// return true;// else// return false;// }// }void dfs(int x, int y, int cnt, int max_item){ if (x == n &amp;&amp; y == m) //到了终点要返回 { if (cnt == k) // 到了终点的时候，手中有k件物品，答案就加一 ans = (ans + 1) % 1000000007; return; } else { for (int i = 0; i &lt; 2; i++) // 向下或者向右 { int dx = x + dir[i][0]; int dy = y + dir[i][1]; if (!vis[dx][dy] &amp;&amp; check1(dx, dy)) { // 拿这件物品 if (cnt != k &amp;&amp; mp[dx][dy] &gt; max_item) { vis[dx][dy] = 1; // 如果当前手中已经有了k件就相当于不取物品，但是继续走 // if (cnt == k || mp[dx][dy]&lt;=max_item) // dfs(dx, dy, cnt, max_item); dfs(dx, dy, cnt + 1, mp[dx][dy]); vis[dx][dy] = 0; // vis[dx][dy] = 1; // dfs(dx, dy, cnt, max_item); // vis[dx][dy] = 0; } // 不拿这件物品 vis[dx][dy] = 1; dfs(dx, dy, cnt, max_item); vis[dx][dy] = 0; } } }}int main(){ cin &gt;&gt; n &gt;&gt; m &gt;&gt; k; for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= m; j++) { scanf(\"%d\", &amp;mp[i][j]); } } vis[1][1] = 1; dfs(1, 1, 1, mp[1][1]); vis[1][1] = 0; vis[1][1] = 1; dfs(1, 1, 0, 0); vis[1][1] = 0; cout &lt;&lt; ans &lt;&lt; endl;} 记忆化搜索123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#define MOD % 1000000007typedef long long ll;using namespace std;const int maxn = 56;int n, m, k;// dp[x][y][cnt][max_item+1] 的意思是// 我从x，y这个点出发，手中有cnt件物品，物品最大的价值为max_item。走到终点有几种方案ll dp[maxn][maxn][15][15];ll mp[maxn][maxn];int dfs(int x, int y, int cnt, int max_item){ ll s = 0; // 如果这个点访问过，我就不继续走下去了 if (dp[x][y][cnt][max_item + 1] != -1) return dp[x][y][cnt][max_item + 1]; if (x == n &amp;&amp; y == m) // 到达终点要返回 { if (cnt == k) // 手中已经有了k件物品，那我就不拿了 { return dp[x][y][cnt][max_item + 1] = 1; } else if (cnt == k - 1 &amp;&amp; mp[x][y] &gt; max_item) // 手中还可以再拿一件 { return dp[x][y][cnt][max_item + 1] = 1; } else // 不足k件 { return dp[x][y][cnt][max_item + 1] = 0; } } else { // 如果此时的物品大于我手中最大的价值，我有两种选择 // 拿或者不拿 if (mp[x][y] &gt; max_item) { if (x + 1 &lt;= n &amp;&amp; x + 1 &gt; 0) // 判断有没有出界 { s = (s + dfs(x + 1, y, cnt + 1, mp[x][y]) MOD + dfs(x + 1, y, cnt, max_item) MOD) MOD; } if (y + 1 &lt;= m &amp;&amp; y + 1 &gt; 0) { s = (s + dfs(x, y + 1, cnt + 1, mp[x][y]) MOD + dfs(x, y + 1, cnt, max_item) MOD) MOD; } } else //如果此时不大于，那就只能不拿 { if (x + 1 &lt;= n &amp;&amp; x + 1 &gt; 0) { s = (s + dfs(x + 1, y, cnt, max_item) MOD) MOD; } if (y + 1 &lt;= m &amp;&amp; y + 1 &gt; 0) { s = (s + dfs(x, y + 1, cnt, max_item) MOD) MOD; } } return dp[x][y][cnt][max_item + 1] = s MOD; }}int main(){ memset(dp, -1, sizeof(dp)); cin &gt;&gt; n &gt;&gt; m &gt;&gt; k; for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= m; j++) { cin &gt;&gt; mp[i][j]; } } dfs(1, 1, 0, -1); cout &lt;&lt; dp[1][1][0][0] &lt;&lt; endl; return 0;}","link":"/2019/12/16/蓝桥杯5（数学与简单DP）/"},{"title":"","text":"浙江工业大学yjc segment图形图像处理 图像分割segment with respect to 关于 顺时针逆时针小于180度 三个问题： p0p1 是否为p0p2的逆时针转过来的 凸包，第二个属性 两个线段判断是否相交 cross products叉乘 有符号的面积 P1*P2是有向的面积（有向是因为叉乘不满足交换律） liner线性 col共线，平行的 把向量相乘看看是不是为0 平移形成熟悉的 构造一个共点的两个向量 结论是反的是因为，向量是相反的 iff充要条件 straddle跨越—在两侧，两边的叉乘的正负号不一样 线段的端点在线段上面 已知四个点，判断是否相交，高斯消元 只看x或者只看y 期末考试不考计算几何 比标量的面积更能反映本质 知道了点求得了面积 但是数学上一般只给边长 重量的都在顶点上 质量知道，算一个权重 凸包，画风突变排序：比较和交换 最左下角的是大于等于0，小于等于180 保留在栈里面的点，就是在凸包上面的点 每一次都要找一个最小的 o（n），n趟，最坏的情况，椭圆和圆上 皮毛中的皮毛 拓扑排序，不需要很多时间，只需要半个小时","link":"/2019/11/27/计算几何/"},{"title":"","text":"chapter 1 概述 网络核心 路由器属于网络核心部分的设备 边缘路由器和网关路由器的区别 wlan 电路交换和分组交换：数据报交换交换，按需分配。统计复用，分组转发电路交换：预资源分配 时延：节点处理，排队，传输，传播 传播时延和链路入口点与出口点的距离D有关 传输时延和分组的位长L和链路传输率R有关（带宽？） 消息，报文段，数据报，帧，比特流 计算机网络由：资源子网和通信子网组成 数据报和虚电路。数据报都会携带目的地址 信道带宽能制约传输速率。带宽就是最大的传输速率 chapter 2 应用层（application layer） SMTP拿来发文件，但是只能用7位的ASCII码。如果想要接收多媒体格式的话就要用MIME格式,POP3，IMAP拿来收文件。pop3有删除和保留两个操作。IMAP的话就是可以保持状态，知道放到哪个文件夹里面去了。然后现在也能用HTTP来做这个事情。但是邮件服务器之间还是只能通过SMTP来传输 应用层与传输层之间的编程接口被称为套接字 chapter 3 传输层（transmition layer） TCP流量控制：通过使用可变大小的滑动窗口协议停等协议GBN，SR。发送窗口保存的是可发送的帧序号。接收窗口用来保证流量控制 接收窗口是分为 TCP拥塞控制算法：慢开始，拥塞避免，快重传，快恢复。也被称为加性倍增数减（AIMD）算法 使用端口号来区分不同的应用进程 被用来实现可靠数据传输服务的字段：检验和字段，顺序号字段，确认号字段 一个字节一个字节被传输 套接字编程。客户机：connect 服务器：bind，listen，accept chapter 4 网络层（network layer） RIP协议：水平分割：不要把从一个邻居学习到的路由再发送回该邻居 距离向量法：只与邻居交换信息，但是邻居会把它知道的全部告诉他 OSPF：使用dijkstra，和全部节点都会交流一遍，但是节点只会把他邻居的信息告诉他 链路状态算法 BGP：在不同自治系统之间的路由器间交换信息 ICMP（网际报文控制协议）：封装在ip数据报，网络层协议 ping实际上向目标主机发送了一个ICMP类型8编码0的报文 CIDR（子网划分） NAT：需要手动配置 私网地址 A:10.0.0.0-10.255.255.255 B: 172.16.0.0-172.31.255.255 C:192.168.0.0-192.168.255.255 CRC校验， IPV4由32位，4字节组成，包括网络号和主机号，使用点分十进制来表示，其中最大为255. 总的数量是2的32次方。MAC地址由6个字节组成，使用一杠加16进制来表示，最大为F。IPV6 有128位，是ipv4的128-32的二次方倍。然后他使用十六进制表示。其中零可以简写，但是一个区域只能使用一次：：，而且每个域开头是零也可以简写，但是要保证每个域至少有一位数字 IPV4和IPV6共存所用的技术是双栈技术和隧道技术 DHCP可动态获取一个IP地址、以及他的子网掩码、默认网关和DNS服务器地址 在一个自治系统内，有一个或者多个路由器来转发目的地不在本自治系统的分组。这些路由器叫做网关路由 校验和 不过在其他方面，尤其是大型私人网络，它也有应用。在普通大小的局域网里则较少应用，因为这些局域网一般使用私有网络。 127.xx.yy.zz环回地址 只能做源地址不能做目的地址的是0.0.0.0 ​ chapter 5 链路层 （link layer） HDLC协议 ARP协议：封装在以太网帧中发送 以太网是无连接不可靠的服务 交换机会分割冲突域，但是不会分割广播域。路由器会分割广播域和冲突域。集线器两个都不能分割。冲突域指的是我上传文件可能会和其他文件相冲突。广播域指的是我使用广播地址广播文件，大家都能收到 频分多路复用和时分多路复用，码分多路复用。是不会造成冲突的。因为他提前预定好了资源。但是CSMA/CD还有ALOHA，时隙aloha都是统计多路复用。都会在一定程度上造成冲突 纯aloha协议的话就是不分时隙。直接就莽发送。如果冲突了我就停止发送，然后等待一段随机的时间重新发送。时隙aloha的话就是分每个时间段，只能在每个时间段开始的时候才能发送数据。数据进来的时候也要缓冲一下。同样的，aloha也需要等待一段随机的时间重新发送 CSMA协议的话就是发送之前先监听一下信道，看看信道有没有正在发送的。如果没有，我就发送。但是这样有很严重的问题：1.多个人同时监听到了可以发送的信号2. 非坚持csma。冲突了，我就先不发，等一段时间再发。空闲马上发 坚持csma。冲突了，我坚持发送，只不过等待一段时间发送。空闲马上发 p坚持。空闲，我就以p概率发送。1-p概率不发送。冲突了 都是等待一个随机的时间 争议期指的是信号在最远的两个断电之间往返传输的时间 CSMA/CD的话就是有一个重传次数和回退算法。每一次冲突，我都在0-2^k-1次取一个数字，乘以512得到我的等待时间。如果超过了10，那就丢弃。数字不能超过1023。以太网用的就是这个协议 CSMA/CA 无线网络用的就是这个协议。会对接收到的数据帧进行确认。同时也不需要在发送过程中进行冲突检测。预约信道 以太网，逻辑拓扑是总线型，物理拓扑是星形。令牌网，逻辑结构是环形，物理拓扑是星形。FDII逻辑拓扑是环形，物理拓扑是双环 组成帧的方法有：字符计数法，字符填充法，位填充法，物理违规编码法 通过拨号上网的家庭电脑连接到ISP路由器之间的链路层协议是PPP协议，SLIP协议 IEEE802.3局域网 IEEE802.11无线局域网 IEEE802.4令牌网 BASE指的是信号为基带信号即基带传输，采用曼彻斯特编码。-X，表示最长的长度为X。T表示双绞线。F表示光纤。前面的数字表示数据率，即XMb/s。10左右的是总线型。100以上的就是星型了。10Gbit以太网只能工作在全双工模式。其他的两个都能用 滑动窗口协议，GBN的话就是2k-1，选择重传的话就是2^k-1.同时选择重传不是累计确认，GBN和ARQ都是累计确认。滑动窗口分为有确认部分和没有确认的部分。滑动窗口的k，其实指的是类似与哈希地址的K。假如k为7，则要发送的帧为0，1，2，3，4，5，6.然后上边界就是右边。滑动窗口发送其实是流水线式的发送 TDM用于数字传输而FDM用于模拟 令牌网络适合负载重的网络。并且共享带宽，因为要不停地传送那个令牌 多路复用器主要是结合来自两条或者更多条线路的传输 以太网也会造成网络风暴。因为他会发送大量的广播信息。所以在以太网中，如果A向b发数据，四台主机都会接收到。因为都在一条总线上以太网支持广播，单播和？给帧加序号是LLC层实现的功能.G比特以太网可以使用光纤和UTP5类线 chapter 6 物理层（physical layer） 曼彻斯特编码：1表示高-低，0表示低-高。每个比特的中间有翻转 绞线编码形式 物理层协议内容的特性：机械特性，电气特性，功能特性和规程特性 中继器和集线器是整形再生数字信号，放大器是模拟信号 网卡工作在物理层和数据链路层，然后他会有自己的时钟信号，是通过曼彻斯特编码机制实现的 应用层：BGP(TCP),RIP(Routing Information ProtocolUDP),HTTP(TCP 80),FTP()TCP 21 20,SMTP(TCP 25),POP3(TCP 110),DNS(UDP 53),SNMP(UDP 161),DHCP（UDP）,TELNET(TCP 23)，PING（回送请求和回答报文）,TFTP（69） 传输层：TCP,UDP,NAT 网络层：IP,ARP,OSPF,ICMP,IGM（management）P（组播），Traceroute（时间超过报文） 数据链路层：CSMA/CD CSMA CSMA/CA ALOHA,PPP，HDLC（保证能传输到） 物理层：","link":"/2020/01/01/计网基础知识/"},{"title":"","text":"不会有最优化的问题 dp，贪心，爆搜dfs。都是最优化 树状数组和线段树–数据结构优化我们的效率 移动距离曼哈顿距离只能沿着横放向和纵方向走 欧几里得距离：直线距离 10的十次方的数组比较极限，操作系统会对数组优化。开辟了没有使用他不会用 求出来坐标，做一个映射 变成从0开始，因为比较好算，不用特判 cpp的多维数组，存的时候，本质都是一维数组 做了一个下标的映射。看起来像个二维数组 折形就特判 优先级 加号比左移右移优先级高 比较运算符比左移右移高 sizof是运算符不是一个函数 日期问题回文日期当时是枚举所有日期看看是否规范 先找到一个枚举的顺序 从八位数枚举到八位数 判断是否合法，判断题目是否是给定的表示 字符串处理—printf或者scanf格式化输出的功能 高精度压位置就补0 cin cout是流式输出 sscanf是从字符串中格式化读入 scanf是从标准读入中读入 %22d 不足22位就前面补空格 %-22d 不足22位就后面补空格 %02d 不足两位就补0 %*d 反推法 check年份 排序 所有能过的里面选择最好写的 stl无非就是vector string map set 堆,pair min,max unique sort 航班问题流水行船问题，漂流问题 不知道水速，不知道船速 河流里面飘，船速和水速 逆流而上还是顺流而下 扔了一个木块，船离木块越来越远 20min，想把木块捡过来 转过头追这个木块 经过多久能把他捡过来 顺流而下 木块和船的距离是（船-水）*20min 回来就是d/相对速度 20分组最后都可以追过来 参考系换成水，船相对于水在动。所以往前走多少时间就会往回走多少时间 小学就有参考系问题 转化成小时分钟秒 读入一行可以用getline 没有加一我就补上加0，就统一成一种类 用getline第一行的回车不会读入 返回一个字符串的表示 想问一下 vectorstu(10) 跟 vectorstu[10] 有啥区别吗？ ![img](file:///C:\\Users\\WalterJ726\\Documents\\Tencent Files\\1281372141\\Image\\Group\\K1I$0I14R6AOH9I[RA~ZQYC.png) 另外有一些编译器自动会优化，视为在你访问的-1位置，其实是访问到了它给你开辟的新内存 外卖店优先级加到一个推荐列表里面去 先判断哪些店有订单，哪些店没有订单 在优先缓存中就会清除出去 一定对的做法，模拟每个时刻的情况 判断哪些店有订单哪些店没有订单 10^5次方 离散的有很多个订单，把中间压缩掉，连续没有订单的，放到购买订单那里处理 将所有订单按照时间顺序排序，一次处理一批订单相同的订单，相同时刻 模拟题伪代码比较重要 程序的草稿有很多种，框框图很不实用，要废很多脑细胞的 pair自带关键字排序，比较函数 pair是重载过等号，相等 ccf/csp 逆序对的数量i - mid 中数据的数量就是mid-i+1； 逆序对的逆序对是最大的 加号优先级比右移大 物归原主","link":"/2020/02/09/蓝桥杯8 （枚举模拟排序习题课）/"},{"title":"","text":"蓝桥杯安排 递推与递归 二分和前缀和 数学与简单DP 枚举与模拟排序 树状数组与线段树 BFS与图论 贪心 数论，快速幂扩展欧几里得 复杂一些的DP，树形DP和其他的结合 综合复习 连号区间1234567891011121314151617181920212223242526272829303132#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cmath&gt;using namespace std;const int maxn = 10010;int p[maxn];int main(){ int n; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) { scanf(\"%d\", &amp;p[i]); } int cnt = 0; for (int i = 0; i &lt; n; i++) { int max_num = p[i]; int min_num = p[i]; for (int j = i; j &lt; n; j++) { max_num = max(p[j], max_num); min_num = min(p[j], min_num); if ((max_num - min_num) == (j - i)) cnt++; } } cout &lt;&lt; cnt &lt;&lt; endl;} O（nlogn + n） O（n^3logn） 无巧不成题 代码长，常数大 想办法把方案枚举到 然后就是 顺序 优化===等价变形，优化某些步骤 三元组nlogn最多只能枚举一个数组 时间复杂度 方法一：前缀和 方法二：sort加二分 ​ 有多少个数小于这个数 方法三：双指针算法 在A中，i这个值出现了多少次 cnt[A[i]]++ 把cnt变成一个前缀和 前缀和是O(数值大小) ctrl + k找相同的 前缀和的相对位置 特别数之和如果n很大需要用数位DP x = x*10 + 位数 把位置挪出来 t = x%10 x/=10； 把数字抠出来 错误票据bool数组换成 set本质是一个平衡树，动态维护的有序序列 统计每个数出现过多少次，时间复杂度不是取决于数值大小 排序 重号，断号 cin会把空格删去，getline会把回车读入 用sstringsteam类似与sscanf 读到空为止 选择问题就是可以用背包来求解 回文日期noip普及组 枚举 中间一砍，左右对称 考虑代码的时候要注意的问题 时间复杂度 空间复杂度 代码复杂度 三百六十五万天*8判断百位 自己要写一个日历 调整枚举顺序 前四位确定，后四位也一定确定 枚举所有的回文串，再判断是否为日期 判断是否在范围内（要移到是否为日期的前面） 万年历 归并排序快排是先分然后再递归 确定分界点，mid=（l+r）/2 递归排序左边和右边 归并，把两个有序的数组合二为一（最难的地方） 抽象的算法都要举例子，一般是把第一个数放进去先。因为他是稳定的 是否稳定，位置不发生变化，就是稳定的算法。快排是不稳定的 把快排变成双元组，变成pair就可以排序了 双路归并合二为一","link":"/2020/02/03/蓝桥杯7（枚举模拟排序）/"},{"title":"","text":"字节的区别bit就是位，也叫比特位，是计算机中最小的单位byte是字节也就是B1字节（byte）=8位（bit）位只有两种形式0和1，只能表示2种状态，而字节是有8个位组成的。可以表示256个状态。 1byte = 1B1byte = 8bit1KB = 1024B1MB = 1024KB1GB = 1024MB1TB = 1024GB osi七层模型和tcpip模型 比较两种体系结构：1． 在分层上进行比较：OSI分七层，而TCP/IP分四层，它们都有网络层（或称互联网层）、传输层和应用层，但其他的层并不相同2．在通信上进行比较：OSI模型的网络层同时支持无连接和面向连接的通信，但是传输层上只支持面向连接的通信；TCP/IP模型的网络层只提供无连接的服务，但在传输层上同时支持两种通信模式。3．OSI/RM体系结构的网络功能在各层的分配差异大,链路层和网络层过于繁重,表示层和会话层又太轻，TCP/IP则相对比较简单。4．OSI-RM有关协议和服务定义太复杂且冗余，很难且没有必要在一个网络中全部实现。如流量控制、差错控制、寻址在很多层重复。TCP/IP则没什么重复。5．OSI的七层协议结构既复杂又不实用，但其概念清楚，体系结构理论较完整。TCP/IP的协议现在得到了广泛的应用，但它原先并没有一个明确的体系结构 通过对两种体系结构的学习，OSI/RM是先有协议才有网络体系结构来帮助人们理解的。我认为OSI/RM体系是一种比较完善的体系结构，它分为七个层次，每个层次之间的关系比较密切，但又过于密切，存在一些重复，我认为分层最重要的是不能有太多重复，否则就起不到分层的作用了。它是一种过于理想化的体系结构，在实际的实施过程中有比较大的难度。但它却很好的为我们担供了一个体系分层的参考。有着很好的指导作用。TCP/IP体系结构分为四层，层次相对要简单得多，因此在实际的使用中比OSI/RM更具有实用性，所以它得到了更好的发展。现在的计算机网络大多是TCP/IP体系结构。但这并不表示它就是完整的结构体系。它也同样存在一些问题。也许随着网络的发展，它发展得更加完美。OSI/RM是国际标准，但是并没有进行大规模的应用，而TCP/IP协议最终占领了几乎整个网络世界，这很形象的说明能够占领市场的才是最终的标准，这方面的例子在计算机领域太多了，如操作系统方面等。通过这个例子我们可以发现那些关系着整个世界的标准，常常会受到多方面因素的制约，如技术、利益等。当然最重要的是要简单，要易于实现，成本要低，要能够占领市场 OSI参考模型与TCP/IP参考模型的区别为：结构不同、性质不同、服务和协议不同。OSI参考模型和TCP/IP参考模型都采用了层次结构的方法。以传输层为界，其上层都依赖传输层提供端到端的与网络环境无关的传输服务。 一、结构不同 1、OSI参考模型：OSI参考模型划分为7层结构：物理层、数据链路层、网络层、传输层、会话层、表示层和应用层。 2、TCP/IP参考模型：TCP/IP参考模型划分为4层结构：应用层、传输层、互联网络层和主机-网络层。 二、性质不同 1、OSI参考模型：OSI参考模型是制定的适用于全世界计算机网络的统一标准，是一种理想状态，它结构复杂，实现周期长，运行效率低。 2、TCP/IP参考模型：TCP/IP参考模型是独立于特定的计算机硬件和操作系统，可移植性好，独立于特定的网络硬件，可以提供多种拥有大量用户的网络服务，并促进Internet的发展，成为广泛应用的网络模型。 三、服务和协议不同 1、OSI参考模型：OSI参考模型对服务和协议做了明确的区别。 2、TCP/IP参考模型：TCP/IP参考模型没有充分明确区分服务和协议 镜像站有什么用","link":"/2019/12/24/计算机网络学习笔记/"},{"title":"训练心得","text":"hdoj 1019lcm，gcd 12345678910111213141516171819202122232425262728293031323334#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;typedef long long ll;ll gcd(ll a,ll b){ return b == 0 ? a :gcd(b,a%b); //这个一定要记住}ll lcm(ll c,ll d){ return c/gcd(c,d)*d; //先除后乘}int main(){ int n,m; ll a=1; ll b; while (~scanf(\"%d\",&amp;n) &amp;&amp; n) { while (n--) { a=1; cin&gt;&gt;m; while (m--) { cin&gt;&gt;b; //如果第一组要处理两组数据的话，但是后面只是一个一个来，那就和第一个进行处理 a=lcm(a,b); } cout&lt;&lt;a&lt;&lt;endl; } } return 0;} hdoj1205 吃糖果12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;typedef long long ll;int main(){ int t; ll n; ll m; ll max=0; ll sum=0; cin&gt;&gt;t; while (t--) { cin&gt;&gt;n; sum=0; max=0; while (n--) { cin&gt;&gt;m; if (m &gt; max) { max=m; //如果某个数一直进去的话，sum永远0 } sum+=m; } if (max-1 &lt;= sum-max || n==1) { cout&lt;&lt;\"Yes\"&lt;&lt;endl; } else { cout&lt;&lt;\"No\"&lt;&lt;endl; } } return 0;} 1181vector的使用 vectorf sort(f.begin(),f.end().cmp); hdoj 1789初始化数组 memset（数组名，值，sizeof（数组名）） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;using namespace std; struct Node{ int dl; int scr;} data[1005];int vis[1005]; int cmp (Node a, Node b){ if (a.scr != b.scr) return a.scr &gt; b.scr; else return a.dl &lt; b.dl;} int main (){//freopen(\"sample.txt\", \"r\", stdin); int cas; scanf (\"%d\", &amp;cas); while (cas--) { int n; memset (vis, 0, sizeof(vis)); scanf (\"%d\", &amp;n); for (int i=0; i&lt;n; ++i) scanf (\"%d\", &amp;data[i].dl); for (int i=0; i&lt;n; ++i) scanf (\"%d\", &amp;data[i].scr); sort (data, data+n, cmp); int ans = 0; for (int i=0; i&lt;n; ++i) { int j=data[i].dl; for (; j&gt;=1; --j) // 枚举每一个合法的天数 if(!vis[j]) { vis[j] = 1; break; } if(j == 0) ans += data[i].scr; } printf (\"%d\\n\", ans); } return 0;} 今年暑假不AC203712345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn=1001;typedef long long ll;//int f1[201]={0};//int f2[201];struct Homework{ int start; int end; Homework(){} Homework(int a,int b):start(a),end(b){}};bool cmp(Homework x,Homework y){ if (x.end==y.end) { return x.start &gt;y.start; } return x.end&lt;y.end;}//int f1[maxn];int main(){ Homework homework[maxn]; int temp=0; int f,j=0; int ans=0; int n=0; while (scanf(\"%d\",&amp;n) &amp;&amp; n) { ans=0; for (int i = 0; i &lt; n; i++){ cin&gt;&gt;homework[i].start&gt;&gt;homework[i].end; } sort(homework,homework+n,cmp); temp=homework[0].end; for (int i = 1; i &lt; n; i++){ if (temp&lt;=homework[i].start) { temp=homework[i].end; ans++; } } cout&lt;&lt;ans+1&lt;&lt;endl; }} 注意初始条件和排序顺序 田忌赛马 10521234567891011121314151617181920212223242526272829田忌赛马问题的核心在于“略胜一筹”的概念（贪心算法）。我们始终优先考虑略胜一筹的情况，这样可以尽可能多得赢嘛。所以我们将田忌与齐王的马按照从优到劣进行排序。比赛以下情况：（需要注意的事，每次参赛的只有最优的马或者最劣的马，参赛完后，最优或者最劣的马就会被消耗掉，也就是从田忌以及齐王的数组中剔除，那么双方剩下的马仍然是一个有着最优和最劣马的相等的数组）只要田忌的最优马略胜齐王的最优马一筹，那么我们就比赛，赏金加200。如果田忌的最优马败于齐王的最优马，那么我们就把田忌的最劣马献祭掉，消耗掉齐王最优马。赏金减200.如果双方最优马实力相当，我们先比较一下最劣马，情况和最优马类似：1）：如果此时田忌最劣马略胜给齐王最劣马，那么比赛，赏金加200.2）：如果此时田忌最劣马略输给齐王最劣马，那么同理，我们将最劣马献祭掉，用来消耗齐王的最优马。赏金减200.3）：如果此时双方最劣马能力也相等，那么我们就要分以下2个情况谈论了：情况1：如果此时田忌最劣的马和田忌的最优的马质量是一样的。如代码的第二个测试数据一样。那么就说明田忌所剩的所有马还有齐王的所有马，质量通通是一样的。那么我们也就没有比较的必要了，全是平局。情况2：如果此时田忌最劣的马比田忌最优的马差，可此时田忌最劣的马与齐王最劣的马质量是一样的，意味着我这匹马没有任何胜利的可能，那么我就将其贡献最大化，将他与齐王最优马比赛，消耗掉齐王最好马。赏金-200。但是保证了我们能多赢一把，我们最好的马比他最差的马好呀。（此处如果有疑问，可以自己拿数据去尝试尝试，这样做最差的结果就是一胜一负，和两个平局结果一样，不会亏的！）————————————————版权声明：本文为CSDN博主「随缘头赠有缘人」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/qq_40194254/article/details/82989267贪心策略：1，如果田忌的最快马快于齐王的最快马，则两者比。（因为若是田忌的别的马很可能就赢不了了，所以两者比）2，如果田忌的最快马慢于齐王的最快马，则用田忌的最慢马和齐王的最快马比。（由于所有的马都赢不了齐王的最快马，所以用损失最小的，拿最慢的和他比）3，若相等，则比较田忌的最慢马和齐王的最慢马3.1，若田忌最慢马快于齐王最慢马，两者比。（田忌的最慢马既然能赢一个就赢呗，而且齐王的最慢马肯定也得有个和他比，所以选最小的比他快得。）3.2，其他，则拿田忌的最慢马和齐王的最快马比。（反正所有的马都比田忌的最慢马快了，所以这匹马必输，选贡献最大的，干掉齐王的最快马）————————————————版权声明：本文为CSDN博主「fanxingyue」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/a716121/article/details/46443829 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;stdio.h&gt;#include &lt;algorithm&gt;using namespace std;int T[1002],K[1002],n,win,lose;void read(){ for(int i=0;i&lt;n;i++) scanf(\"%d\",&amp;T[i]); for(int i=0;i&lt;n;i++) scanf(\"%d\",&amp;K[i]); sort(T,T+n); sort(K,K+n);}void race(){ win = lose =0; int t_slow=0,t_fast=n-1; int k_slow=0,k_fast=n-1; while(t_slow &lt;= t_fast) { if(T[t_slow] &gt; K[k_slow]) //情况1 { win++; t_slow++; k_slow++; } else if(T[t_slow] &lt; K[k_slow]) //情况2 { lose++; t_slow++; k_fast--; } else //情况3 { if(T[t_fast] &gt; K[k_fast]) //先别放水，让哥比完这场 { win++; t_fast--; k_fast--; } else //1、2、3、放 { if(T[t_slow] &lt; K[k_fast])//哥不一定会输哦~~~ lose++; t_slow++; k_fast--; } } }}int main(){ //freopen(\"1\",\"r\",stdin); //freopen(\"2\",\"w\",stdout); while(scanf(\"%d\",&amp;n),n) { read(); race(); printf(\"%d\\n\",200*(win-lose)); } return 0;} 我感觉这题的精髓就是，不管怎么比赛，都要让田忌的马发挥最大价值。 当然，马的第一要务是用来赢得比赛，而且要最大效益的赢，也就是要赢对方仅次于自己的马。 当他不能完成这个任务的时候就要去输，并拉对方最快的马下水，给自己后面的队友创造更大的胜利机会。 解题思路： 1.若田忌最慢的马可以战胜齐王最慢的马，那么就让它战胜那匹慢马，胜利场次加1。（田忌最慢马 &gt; 齐王最慢马） 2.若田忌最慢的马不能战胜齐王最慢的马，那么它更加不能战胜其他的马，那就让它输，而且输给齐王最快马，失败场次加1。（田忌最慢马 &lt; 齐王最快马） 3.若田忌最慢的马与齐王最慢的马速度相等。此时，不能简单地认为与它打成平手就是最好情况，相反，打平是下下策，为什么呢？ 因为自己后面的队友很有可能战胜此时对方的这匹慢马，所以就算自己输一场，队友也能帮忙赢回一场，而胜一场，输一场的收益和打平一场的收益是一样的，而且自己输的时候可以拉对方最快的马下水，给己方最快的马创造更大的胜利机会（因为它失去了一个强劲的对手），也就是说己方最快的马很可能因为自己的牺牲再胜利一场，从这个角度看，还是自己故意输掉比较好。 但是，还有一点需要注意，当自己放水前，如果己方最快的马原本就比对方最快的马快，然后还输给对方最快的马，那么己方最快的马的才华就浪费了，为什么？ 很简单，它原本就能赢，需要你放水么？- -！换句话说，这种情况下，自己的牺牲没有一点价值。 所以，在放水时，一定要保证己方最快马不快于对方最快马。满足此条件后，让己方最慢马与对方最快马去比赛（有可能平局），这样，田忌的马就得到了充分的利用。 DFS模板题123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;bits/stdc++.h&gt;using namespace std;int a[100],b[100],c[100],d[100];//a数组表示的是行；//b数组表示的是列；//c表示的是左下到右上的对角线；//d表示的是左上到右下的对角线；int total;//总数:记录解的总数int n;//输入的数，即N*N的格子，全局变量，搜索中要用int print(){ if(total&lt;=2)//保证只输出前三个解，如果解超出三个就不再输出，但后面的total还需要继续叠加 { for(int k=1;k&lt;=n;k++) cout&lt;&lt;a[k]&lt;&lt;\" \";//for语句输出 cout&lt;&lt;endl; } total++;//total既是总数，也是前三个排列的判断}void queen(int i)//搜索与回溯主体{ if(i&gt;n) { print();//输出函数，自己写的 return; } else { for(int j=1;j&lt;=n;j++)//尝试可能的位置 { if((!b[j])&amp;&amp;(!c[i+j])&amp;&amp;(!d[i-j+n]))//如果没有皇后占领，执行以下程序 { a[i]=j;//标记i排是第j个 b[j]=1;//宣布占领纵列 c[i+j]=1; d[i-j+n]=1; //宣布占领两条对角线 queen(i+1);//进一步搜索，下一个皇后 b[j]=0; c[i+j]=0; d[i-j+n]=0; //（回到上一步）清除标记 } } }}int main(){ cin&gt;&gt;n;//输入N*N网格，n已在全局中定义 queen(1);//第一个皇后 cout&lt;&lt;total;//输出可能的总数 return 0;} 总的来说，要做dfs有几个步骤 先确立数据结构 先写好模板比如 123456789101112void dfs(int a){ if (some condition){ printf return ; } do something}int main(){ dfs(first condition);}return 0; 目测检验 点对最短距离 1007 quoit design1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950//ECUST luoyongjun#include &lt;bits/stdc++.h&gt;using namespace std;const double eps = 1e-8;const int MAXN = 100010;const double INF = 1e20;int sgn(double x){ if(fabs(x) &lt; eps) return 0;//如果相等返回0 else return x&lt;0?-1:1; //跃迁函数，小于0返回-1}struct Point{ double x,y; };double Distance(Point A, Point B){return hypot(A.x-B.x,A.y-B.y);}//已知两条直角边，返回斜边长度bool cmpxy(Point A,Point B){ //排序：先对横坐标x排序，再对y排序 return sgn(A.x-B.x)&lt;0 || (sgn(A.x-B.x)==0 &amp;&amp; sgn(A.y-B.y)&lt;0);}bool cmpy (Point A,Point B){return sgn(A.y-B.y)&lt;0;}//只对y坐标排序Point p[MAXN],tmp_p[MAXN];double Closest_Pair(int left,int right){ double dis = INF; if(left == right) return dis; //只剩1个点 if(left + 1 == right) //只剩2个点 return Distance(p[left], p[right]); int mid = (left+right)/2; //分治 double d1 = Closest_Pair(left,mid); //求s1内的最近点对 double d2 = Closest_Pair(mid+1,right); //求s2内的最近点对 dis = min(d1,d2); int k = 0; for(int i=left;i&lt;=right;i++) //在s1和s2中间附近找可能的最小点对 if(fabs(p[mid].x - p[i].x) &lt;= dis) //按x坐标来找 tmp_p[k++] = p[i]; sort(tmp_p,tmp_p+k,cmpy);//按y坐标排序，用于剪枝。这里不能按x坐标排序 for(int i=0;i&lt;k;i++) for(int j=i+1;j&lt;k;j++){ if(tmp_p[j].y - tmp_p[i].y &gt;= dis) break; //剪枝 dis = min(dis,Distance(tmp_p[i],tmp_p[j])); } return dis; //返回最小距离}int main(){ int n; while(~scanf(\"%d\",&amp;n) &amp;&amp; n){ for(int i=0;i&lt;n;i++) scanf(\"%lf%lf\",&amp;p[i].x,&amp;p[i].y); sort(p,p+n,cmpxy); //先排序 printf(\"%.2f\\n\",Closest_Pair(0,n-1)/2); //输出最短距离的一半 } return 0;} 搜索剪枝策略由于在纵向的时候，如果有两个点的纵坐标相差大于y，这说明这个点要被舍弃，而且这种剪枝策略只需要最多检查六个点就可以了 判断可图(heavel定理) hdoj 254412345678910111213141516171819202122232425262728293031323334353637#include &lt;stdio.h&gt;#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;string.h&gt;#include &lt;algorithm&gt;using namespace std;#define LL long longconst int MAXV=1000+3;int V, deg[MAXV];int main(){ int T_T; scanf(\"%d\", &amp;T_T); while(T_T--) { scanf(\"%d\", &amp;V); for(int i=0;i&lt;V;++i) scanf(\"%d\", &amp;deg[i]); bool ok=true; for(int i=0;i&lt;V;++i) { sort(deg+i, deg+V, greater&lt;int&gt;()); if(deg[i]&lt;0 || i+deg[i]&gt;=V) { ok=false; break; } for(int j=1;j&lt;=deg[i];++j) --deg[i+j]; } puts(ok?\"yes\":\"no\"); } return 0;} heavel-hakami可图定理 先删除第一个数，然后把这个数之后的n个数都减一 然后排序 然后循环这个操作 如果有出现-1，直接break，不可能形成图 判断可图，并且把邻接矩阵打印出来123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;#define N 15struct node{ int id,degree;}point[N];int n,g[N][N];int cmp(node a,node b){ return a.degree&gt;b.degree;}bool Havel(){ int k,i; k=0; while(k&lt;n) { sort(point+k,point+n,cmp); if(point[k].degree&gt;n-k-1) break; for(i=1;i&lt;=point[k].degree;i++) { if(point[k+i].degree&lt;=0) break; point[k+i].degree--; g[point[k].id][point[k+i].id]=g[point[k+i].id][point[k].id]=1; } if(i&lt;=point[k].degree) break; k++; } if(k&lt;n) return false; else return true;}void Outputgraph(){ int i,j; printf(\"YES\\n\"); for(i=0;i&lt;n;i++) { for(j=0;j&lt;n;j++) { if(j) printf(\" \"); printf(\"%d\",g[i][j]); } printf(\"\\n\"); }}int main(){ int T,i; scanf(\"%d\",&amp;T); while(T--) { memset(g,0,sizeof(g)); scanf(\"%d\",&amp;n); for(i=0;i&lt;n;i++) { scanf(\"%d\",&amp;point[i].degree); point[i].id=i; } if(Havel()) Outputgraph(); else printf(\"NO\\n\"); if(T) printf(\"\\n\"); } return 0;} 师妹的问题12345678910111213141516171819202122232425262728293031323334353637#include&lt;stdio.h&gt;#include&lt;math.h&gt;double down(int n) //打代码记得缩进{ double sum=1; for(;n&gt;0;n--) //for循环里面的条件不写也行 { sum=sum*n; } return sum;}int main(){ double x; int n; int i; double a=1; double p; double result=1; while(~scanf(\"%lf %d\",&amp;x,&amp;n)) { result=1; a=1;//a也要重新定义一下。因为这里会出现正负的情况 if (x!=0.00) { for(i=1;i&lt;=n;i++) { p=pow(x,2*i);//少用pow，而且要注意pow返回的是double类型 a=-a; result=result+a*p/down(2*i); } } printf(\"%.4lf\\n\",result); } return 0;} hdoj484112345678910111213141516171819202122232425262728293031323334#include&lt;bits/stdc++.h&gt;using namespace std;vector&lt;char&gt;people;const int maxn=5005;int main(){ int n,m; int index=0; int left; while (~scanf(\"%d %d\",&amp;n,&amp;m) &amp;&amp; n &amp;&amp; m) { left=n; index=0; for (int i = 0; i &lt; n; i++) { people.push_back('G'); } for (int i = 1; i &lt;= left; i++) { if (index+=m &gt; left+n) { index=(index+m)%(left+n); } else { index+=m; } people.insert(people.begin()+index,'B'); index++; } } return 0;} 首先，这次考虑到了增加会往后移动一个元素 但是还是没有学会erase和insert的操作 erase是删除第i+1个元素 insert是在第i个元素前插入某个元素 主要是没解决从当前的G跳到下一个G的情况 算法是错的，因为不论插到什么地方，我都是插空法 总的想法还是从全好人-&gt;好坏全在一起 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;cstring&gt;using namespace std;const int M=32767+5;const int g=0,b=1;int vis[2*M];int main(){ int n,m,first=1; while(cin&gt;&gt;n&gt;&gt;m) { memset(vis,g,sizeof(vis)); vector&lt;int&gt; v(2*n); for(int i=0;i&lt;2*n;i++) v[i]=i; int no=0; for(int i=0;i&lt;n;i++) { no=(no+m-1)%v.size(); vis[v[no]]=b; v.erase(v.begin()+no); } for(int i=0;i&lt;2*n;i++) { if(i%50==0&amp;&amp;i&gt;0) cout&lt;&lt;endl; if(vis[i]==g) cout&lt;&lt;'G'; else cout&lt;&lt;'B'; } cout&lt;&lt;endl&lt;&lt;endl; } return 0;} 1021 斐波那契数列递归表达 1234567891011121314ll f0=7;ll f1=11;ll sum=0;if(n == 0) return 0;if(n == 1) return 0;while (n &gt; 1) { sum=(f0%3+f1%3)%3; f0=f1; f1=sum; n--;}if(sum == 0) return 1;else return 0; 1005 number sequence123456789101112#include&lt;stdio.h&gt;int main(){ int a,b,n,i,arr[49]={1,1}; while(scanf(\"%d%d%d\",&amp;a,&amp;b,&amp;n)&amp;&amp;(a|b|n)) { for(i=2;i&lt;49;i++) arr[i]=(a*arr[i-1]+b*arr[i-2])%7; printf(\"%d\\n\",arr[(n-1)%49]);//数组下标从0开始，所以n先减1 } return 0;} f(n)=(Af(n-1)+B(f-2))%7，计算过程中A和B的一直没有变，在变的是f(n-1)和f(n-2)。f(n)取决于前两个元素f(n-1)，f(n-2)，最终的结果与7相模除，f(n-1)的取值范围为[0,6]，同样f(n-2)的取值范围也是[0,6]，两个数的组合为(0,0),(0,1)(1,1)……(6,6)一共有7*7=49种不同的组合，但A，B的值固定不变，第49个元素之后又会重覆，然后继续下去。所以只要纪录前49个元素的值就可以。 其实取余的题都要小心，找到规律就好，没必要死搞 人见人爱a^b1234567891011121314typedef long long ll;ll mod;ll qpow(ll a, ll n)//计算a^n % mod{ ll re = 1; while(n) { if(n &amp; 1)//判断n的最后一位是否为1 re = (re * a) % mod; n &gt;&gt;= 1;//舍去n的最后一位 a = (a * a) % mod;//将a平方 } return re % mod;} 123456789101112131415ll qpow(ll a,ll b){ ll temp=a; ll mutiple=1; while (b != 0) { if (b&amp;1) { mutiple = (mutiple *temp)%1000; //乘等于可能会错 } b&gt;&gt;=1; temp=(temp * temp)%1000; //这里也要取余 } return mutiple%1000; } cf速度慢的原因1.右键单击开始按钮，打开资源管理器，在资源管理器的地址栏中填写“%SystemRoot%\\System32\\drivers\\etc”并进入。 2.右键单击“HOSTS”文件，选择“属性”去掉只读选项，确保“HOSTS”文件能被修改。 3.双击HOSTS，选择记事本打开，在最前面或者最后添加以下两行代码：183.136.133.218 fonts.googleapis.com183.136.133.218 fonts.gstatic.com4.保存HOSTS文件。 具体解决思路：CF使用了谷歌字体库（国内大部分网段对谷歌服务器的访问速度都比较慢，有时甚至无法连接。），以上方法是通过修改HOSTS文件，使用360提供的谷歌字体库的镜像重定向谷歌服务器，加速访问速度 质因数分解1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn=1005; // 这个要加分号int vis[4]={0};int check;int number[4]={2,3,5,7};int flag=0;void dfs(ll n,int step){ if(n == 0) {check=1; flag=1;} if(n!=0 &amp;&amp; step==4) return ; for (int i = 0; i &lt; 4; i++) { if (n%number[i] == 0) { n = n/number[i]; dfs(n,step+1); n = n*number[i]; } } if(flag!=1)check=0; }int main(){ int t; ll n; /* int f2=1 int f3=1 int f5=1 int f7=1; */ cin&gt;&gt;t; while (t--) { cin&gt;&gt;n; int step=15; while (n != 1 &amp;&amp; step&gt;0) { if (n%2 == 0) { n/=2; } if (n%3 == 0) { n/=3; } if (n%5 ==0) { n/=5; } if (n%7 == 0) { n/=7; } step--; } if (n == 1) { cout&lt;&lt;\"Yes\"&lt;&lt;endl; } else { cout&lt;&lt;\"No\"&lt;&lt;endl; min } }} hdoj206712345678910111213\"\"\"排列组合\"\"\" ll c(ll m,ll n){ ll a = 1,b = 1; n = min(n,m-n); //求简单一点的 例如C(5,4) 可以求C（5,1） if( n == 0 ) return 1; for( int i = m ; i &gt;=m-n+1 ; i-- ) a = a*i; for( int i = 1 ; i &lt;= n ; i++ ) b = b*i; return a/b;} 根据题意我们知道只能在对角线的一侧走，且对角线两边以对角线为轴对称。那么我们只用求一边的方案数就可以了。 观察每个方格，发现对于任意方格，只有从他的左边或者上方到达。 dp[i][j] = dp[i-1][j] + dp[i][j-1]。对于对角线上的点左半棋盘有 dp[i][j] = dp[i][j-1]，右半棋盘有 dp[i][j] = dp[i-1][j] 。 代码如下： 12345678910111213141516171819202122#include &lt;iostream&gt;using namespace std;long long dp[40][40]; int main(){ for (long long i = 1; i &lt;= 35;i++) dp[i][0]= 1 for (long long i = 1; i &lt;= 35;i++) for (long long j = 1; j &lt;= i;j++) dp[i][j]= dp[i - 1][j] + dp[i][j - 1];//由于题目说不能经过对角线，所以这只是算了一半的走法，最后要先乘2在输出。 long long n; int a=1; while(cin &gt;&gt; n) { if (n == -1) break; cout&lt;&lt; a++ &lt;&lt; \" \" &lt;&lt; n &lt;&lt; \" \" &lt;&lt; 2 * dp[n][n] &lt;&lt; endl; }} 1234567891011121314151617181920212223242526import java.math.BigInteger;import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner cin=new Scanner(System.in); BigInteger [] map=new BigInteger[1001]; map[0]=BigInteger.valueOf(1); map[1]=BigInteger.valueOf(1); for(int i=2;i&lt;1001;i++) { map[i]=map[i-1].multiply(BigInteger.valueOf(i*4-2)).divide(BigInteger.valueOf(i+1)); } while(cin.hasNext()) { int n=cin.nextInt(); if(n==-1) break; System.out.println(map[n]); } } }","link":"/2019/10/05/训练心得/"},{"title":"贪心小练习","text":"贪心小练习结构体排序首先是结构体的定义 123456789struct Wood{ string sth1; int sth2; //struct// Wood(){} //这两个构造函数到底是什么意思 Wood(string n,int s):name(n),sth2(s){}};struct Wood wood[number]; 比较字符串的话就是strcmp(数组名1，数组名2) 反正就是把一个字符型指针变量传进去 然后是结构体的排序 123bool cmp(Wood x,Wood y) //用这个结构体去定义另一个结构体？ Wood x 为什么可以看作一个结构体 hdoj 1051二维的比较其实就是最长公共子序列 所有的贪心只能比较一维的东西 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=5005;typedef long long ll;struct Wood{ int l; int w;};bool cmp(Wood x,Wood y)//这里从struct X改成Wood{ if(x.w == y.w) return x.l&gt;y.l; return x.w &gt; y.w;}int main(){ int n,t; int min=1; struct Wood wood[maxn]; cin&gt;&gt;n; while (n--) { cin&gt;&gt;t; min=1; for (int i = 0; i &lt; t; i++) { scanf(\"%d %d\",&amp;wood[i].l,&amp;wood[i].w); } sort(wood,wood+t,cmp); for (int i = 0; i &lt; t; i++) { //printf(\"%d %d\\n\",wood[i].l,wood[i].w); if(wood[i].l&gt;wood[i-1].l) min++; } cout&lt;&lt;min&lt;&lt;endl; } } return 0;} 多个样例测试 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=5005;typedef long long ll;int vis[maxn]={0};struct Wood{ int l; int w; Wood () {} Wood(int a,int b):l(a),w(b){}};bool cmp(Wood x,Wood y){ if(x.w == y.w) return x.l&gt;y.l; return x.w &gt; y.w;}int main(){ int n,t; int time=1; struct Wood wood[maxn]; while (~scanf(\"%d\",&amp;n) &amp;&amp; n) { while (n--) { cin&gt;&gt;t; time=1; for (int i = 0; i &lt; t; i++) { scanf(\"%d %d\",&amp;wood[i].l,&amp;wood[i].w); } sort(wood,wood+t,cmp); int min=wood[0].l; for (int i = 0; i &lt; t; i++) { if (vis[i]!=1) { for (int j = i+1; j &lt; t;j++) { //max=wood[j].l; if (wood[j].l&gt;min &amp;&amp; vis[j]!=1) { time++; vis[j]=1; break; } if (wood[j].l&lt;min) { min=wood[j].l; } vis[j]=1; } } } cout&lt;&lt;time&lt;&lt;endl; } } return 0;}//第二次错误 到底设立flag应该怎么比对 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=5010;typedef long long ll;struct Wood{ int l; int w;};bool cmp(Wood x,Wood y)//这里从struct X改成Wood{ if(x.w != y.w) return x.w&gt;y.w; else return x.l &gt; y.l;//结构体排序不是问题所在}int main(){ int n,t; int min=1; struct Wood wood[maxn]; cin&gt;&gt;n; while (n--) { cin&gt;&gt;t; min=1; for (int i = 0; i &lt; t; i++) { scanf(\"%d %d\",&amp;wood[i].l,&amp;wood[i].w); } sort(wood,wood+t,cmp); for (int i = 1; i &lt; t; i++) { //printf(\"%d %d\\n\",wood[i].l,wood[i].w); if(wood[i].l&gt;wood[i-1].l) {min++;} } if(t==0) printf(\"0\"); cout&lt;&lt;min&lt;&lt;endl; } return 0;} 继续错 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=5050;typedef long long ll;struct Wood{ int l; int w; Wood () {} Wood(int a,int b):l(a),w(b){}};bool cmp(Wood x,Wood y)//这里从struct X改成Wood{ if(x.w != y.w) return x.w&gt;=y.w; else return x.l &gt;= y.l;//结构体排序不是问题所在}int main(){ int n,t; int sum=1; struct Wood wood[maxn]; cin&gt;&gt;n; while (n--) { cin&gt;&gt;t; sum=1; for (int i = 0; i &lt; t; i++) { scanf(\"%d %d\",&amp;wood[i].l,&amp;wood[i].w); } sort(wood,wood+t,cmp); for (int i = 1; i &lt; t; i++) { //printf(\"%d %d\\n\",wood[i].l,wood[i].w); if(wood[i].l&gt;wood[i-1].l) {sum++;} } if(t==0) cout&lt;&lt;\"0\"&lt;&lt;endl; cout&lt;&lt;sum&lt;&lt;endl; } return 0;} 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=5005;typedef long long ll;int vis[maxn]={0};struct Wood{ int l; int w; Wood () {} Wood(int a,int b):l(a),w(b){}};bool cmp(Wood x,Wood y){ if(x.w == y.w) return x.l&gt;y.l; return x.w &gt; y.w;}int main(){ int n,t; int time=1; int min=0; struct Wood wood[maxn]; scanf(\"%d\",&amp;n); while (n--) { cin&gt;&gt;t; for (int i = 0; i &lt; t; i++) { scanf(\"%d %d\",&amp;wood[i].l,&amp;wood[i].w); vis[i]=0; } sort(wood,wood+t,cmp); time=0; min=0; for (int i = 0; i &lt; t; i++) { if (vis[i]!=1) { time++; min=wood[i].l; for (int j = i+1; j &lt; t;j++) { if (wood[j].l&lt;=min &amp;&amp; vis[j]!=1) { min=wood[j].l; vis[j]=1; } } } } cout&lt;&lt;time&lt;&lt;endl; } return 0;}//第二次错误 到底设立flag应该怎么比对 耗时最久的题，用时2h hdoj2546123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=5005;typedef long long ll;//int vis[maxn]={0};/*struct Wood{ int l; int w; Wood () {} Wood(int a,int b):l(a),w(b){}};*/bool cmp(int x,int y){ //if(x.w == y.w) return x.l&gt;y.l; return x&lt;y;}int main(){ int n,m; //int temp_money=0; int food[maxn]={0}; while (~scanf(\"%d\",&amp;n) &amp;&amp; n) { for (int i = 0; i &lt; n; i++) { scanf(\"%d\",&amp;food[i]); } cin&gt;&gt;m; if (m&gt;=5)//这算是一组测试数据 { sort(food,food+n,cmp); for (int i = 0; i &lt; n; i++) { if (m-food[i] &lt;5)//12225 7 { m-=food[n-1];//最后一个是n-1 break; } m-=food[i]; } } cout&lt;&lt;m&lt;&lt;endl; } return 0;}//第二次错误 到底设立flag应该怎么比对 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=5005;typedef long long ll;vector&lt;int&gt;food;//int vis[maxn]={0};/*struct Wood{ int l; int w; Wood () {} Wood(int a,int b):l(a),w(b){}};*/bool cmp(int x,int y){ //if(x.w == y.w) return x.l&gt;y.l; return x&gt;y;}int main(){ int n,m; int now; //int temp_money=0; //int food[maxn]={0}; while (~scanf(\"%d\",&amp;n) &amp;&amp; n) { for (int i = 0; i &lt; n; i++) { scanf(\"%d\",&amp;now); food.push_back(now); //这里要用i么 } //now=n; cin&gt;&gt;m; if (m&gt;=5)//这算是一组测试数据 { sort(food.begin,food.end,cmp); for (int i = 0; i &lt; n; i++)//要用迭代器iltertor么 { if (m-food[i] &lt;5)//12225 7 { continue; } if (m == 5) { m-=food.front; } m-=food[i]; food.pop_back() //now--; } } cout&lt;&lt;m&lt;&lt;endl; } return 0;}//第二次错误 到底设立flag应该怎么比对 如果用vector把数组弄出去的话，那个顺序已经变了，只能用其他方法 strcmp指的是字符串递减比较顺序 hdoj 2111123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=105;struct Treasure{ int p; int m;};bool cmp(Treasure x,Treasure y){ return x.p&gt;y.p;}int main(){ int v,n; struct Treasure treasure[maxn]; int sum=0; while (~scanf(\"%d\",&amp;v) &amp;&amp; v) { scanf(\"%d\",&amp;n); for (int i = 0; i &lt; n; i++) { cin&gt;&gt;treasure[i].p&gt;&gt;treasure[i].m; } sort(treasure,treasure+n,cmp); sum=0; for (int i = 0; i &lt; n; i++) { if (v-treasure[i].m &lt;= 0) { sum+=(treasure[i].p*v); v=0; break; } v=v-treasure[i].m; sum+=(treasure[i].p*treasure[i].m); //treasure[i].p=treasure[i].m=0; } cout&lt;&lt;sum&lt;&lt;endl; } return 0;} 达到最后的体积之后要及时break，要不然他还会继续进行下面的语句 贪心总结贪心法所不能解决的01背包问题即不可分割的问题01背包问题是 考虑整体最优解贪心策略适用的前提是：局部最优策略能导致产生全局最优解。 例题分析编辑 例题1、[0-1背包问题]有一个背包，背包容量是M=150。有7个物品，物品不可以分割成任意大小。要求尽可能让装入背包中的物品总价值最大，但不能超过总容量。物品 A B C D E F G重量 35kg 30kg 6kg 50kg 40kg 10kg 25kg价值 10$ 40$ 30$ 50$ 35$ 40$ 30$分析：目标函数：∑pi最大约束条件是装入的物品总重量不超过背包容量：∑wi&lt;=M(M=150 根据贪心的策略，每次挑选价值最大的物品装入背包，得到的结果是否最优？ 每次挑选所占重量最小的物品装入是否能得到最优解？ 每次选取单位重量价值最大的物品，成为解本题的策略。 ​ 值得注意的是，贪心算法并不是完全不可以使用，贪心策略一旦经过证明成立后，它就是一种高效的算法。 贪心算法还是很常见的算法之一，这是由于它简单易行，构造贪心策略不是很困难。 ​ 可惜的是，它需要证明后才能真正运用到题目的算法中。 一般来说，贪心算法的证明围绕着：整个问题的最优解一定由在贪心策略中存在的子问题的最优解得来的。 ​ 对于例题中的3种贪心策略，都是无法成立（无法被证明）的，解释如下： ⑴贪心策略：选取价值最大者。 12345反例：W=30物品：A B C重量：28 12 12价值：30 20 20 ​ 根据策略，首先选取物品A，接下来就无法再选取了，可是，选取B、C则更好。 ⑵贪心策略：选取重量最小。它的反例与第一种策略的反例差不多。 ⑶贪心策略：选取单位重量价值最大的物品。 12345反例：W=30物品：A B C重量：28 20 10价值：28 20 10 ​ 根据策略，三种物品单位重量价值一样，程序无法依据现有策略作出判断，如果选择A，则答案错误。 注意： 如果物品可以分割为任意大小，那么策略3可得最优解 //hdoj fat mouse ​ 对于选取单位重量价值最大的物品这个策略，可以再加一条优化的规则：对于单位重量价值一样的，则优先选择重量小的！这样，上面的反例就解决了。 但是，如果题目是如下所示，这个策略就也不行了。 W=40 物品：A B C 重量：25 20 15 价值：25 20 15 附：本题是个DP问题，用贪心法并不一定可以求得最优解，以后了解了动态规划算法后本题就有了新的解法。","link":"/2019/10/10/贪心小练习/"},{"title":"","text":"12345678910111213141516171819202122前面已经做了2个排序的题目，现在再升级一下——给定N个正整数，请按照从大到小的顺序输出前M个最大的数。Input输入数据第一行是一个正整数C（C&lt;=10），表示有C组测试用例。每组测试数据占两行——第一行是2个正整数N（N&lt;=1000）和M（M&lt;=N），表示本组数据一共有N个整数，需要输出前M个最大的数；第二行是本组的全部N个整数。### Output请按照“从大到小”的顺序，输出每组数据前M大的数。每组数据输出一行，每个数字后面是一个空格。### Sample Input​ 23 22 1 59 91 4 7 2 5 8 3 6 9​1234### Sample Output​ 5 29 8 7 6 5 4 3 2 1 1234567891011121314151617181920212223242526272829# b```cpp上次设计的“高级密码”被你们破解了，一丁小朋友很不服气！现在，他又设计了一套更加复杂的密码，称之为“超级密码”。说实话，这套所谓的“超级密码”其实也并不难：对于一个给定的字符串，你只要提取其中的数字，然后连在一起构成一个整数，再乘以刘一丁小朋友的幸运数字513，就是解密后的结果了~比如，字符串“ads2d4,122”，提取后的整数是24122，然后乘以513，就能得到解密后的结果：12374586。注：题目保证解密后的结果在32位无符号整数范围。Input输入首先包括一个正整数N，表示有N组测试用例。每组数据占一行，包含一个长度不超过30的字符串。Output请根据题目要求输出解密后的结果，每组数据输出一行。Sample Input2ads2d4,1220023asdf2AA90Sample Output1237458611947770 1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;cmath&gt;using namespace std;typedef long long ll;const int maxn = 36;char s[maxn];int temp[maxn];int main(){ int n; cin&gt;&gt;n; getchar(); while (n--) { int cnt = 0; gets(s); int len = strlen(s); for (int i = 0; i &lt; len; i++) { if(s[i]&gt;='0' &amp;&amp; s[i]&lt;='9') temp[cnt++] = s[i]-'0'; } // for (int i = 0; i &lt; cnt; i++) // { // cout&lt;&lt;temp[i]; // } // cout&lt;&lt;endl; ll res=0; int power = 0; for (int i = cnt-1; i &gt;= 0; i--) { res += pow(10,power++)*temp[i]; //cout&lt;&lt;res&lt;&lt;endl; } cout&lt;&lt;res*513&lt;&lt;endl; } return 0;} c12345678910111213141516171819一个数，如果他的素数因子只包括2,3,5,7，则称这个数为萌数，比如，下面这些数就是前20个萌数：1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 14, 15, 16, 18, 20, 21, 24, 25, 27。现在给你一个萌数，请编程计算它的约数的个数。比如，4是一个萌数，他有3个约数(1,2,4)；12也是一个萌数，他有 6 个约数（1,2,3,4,6,12）。Input输入包含多组测试用例。每个测试用例包含一个萌数n, 并且n在64位整数的范围( long long 类型，输入输出用%lld )。如果n为0，则标志结束输入，不做处理。Output对于每个测试用例中的萌数，请输出他的约数的个数。每个输出占一行。Sample Input4120Sample Output36 123456789101112131415161718192021222324#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;typedef long long ll;int main(){ ll n; while (scanf(\"%lld\", &amp;n), n) { int num[4] = {2, 3, 5, 7}; int ans[4] = {1, 1, 1, 1};//由在算的时候没有把0个2，0个3，0个5或者0个7的情况计算进去，所以一开始就加上 for (int i = 0; i &lt; n; i++) { while (n != 1 &amp;&amp; n % num[i] == 0)//算出2，3，5，7的个数 { ans[i]++; n /= num[i]; } } printf(\"%lld\\n\", ans[0] * ans[1] * ans[2] * ans[3]); } return 0;} d1234567891011121314151617181920Problem Description公元8888年，天下大旱！由于灾情越来越严重，学校师生的用水困难已成为现在最急需解决的问题，要给各学校提供用水，就必须先知道各学校是否与水库有道路相连。请你编写一个程序，读入水库与各个学校以及所有道路的信息，计算有多少学校没有路与水库相通。Input输入有多组数据，每组数据第一行包括两个正整数n，m（0&lt;n&lt;1000, 0&lt;m&lt;=(n*(n+1)/2), 其中，n表示学校的数目，m表示道路的数目），学校用1到n的整数编号，水库的编号永远记为0，接下来有m行，每行有两个数a和b，a和b用一个空格分开，表示a到b有一条路。请处理到文件结束。Output对于每组输入数据，如果所有的学校均与水库相通，则请在一行内输出0；如果有学校不通水库，则输出占两行，第一行是一个整数k（表示与水库无路连接的学校个数），第二行有k个正整数，分别表示无路与水库相连的学校的编号，按升序输出，每两个数之间用一个空格分开。Sample Input4 40 10 21 22 3Sample Output14 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cmath&gt;using namespace std;typedef long long ll;const int maxn = 5600;int s[maxn];int res[maxn];int find(int x){ int r =x; while (s[r] != r) { r = s[r]; } return r;}bool cmp(int a, int b){ return a &gt; b;}int main(){ int n, m; while (~scanf(\"%d %d\", &amp;n, &amp;m)) { int a, b; for (int i = 0; i &lt;= n; i++) { s[i] = i; } for (int i = 1; i &lt;= m; i++) { scanf(\"%d %d\", &amp;a, &amp;b); int fa = find(a); int fb = find(b); if (fa != fb) { if(fb==0)s[fa] = fb; else s[fb] =fa; } } int cnt = 0; for (int i = 1; i &lt;= n; i++) { int fa = find(i); if (fa != 0) res[cnt++] = i; } sort(res, res + cnt); printf(\"%d\\n\", cnt); if(cnt==0) continue; for (int i = 0; i &lt; cnt; i++) { if(i==cnt-1) {printf(\"%d\", res[i]);break;} printf(\"%d \", res[i]); } printf(\"\\n\"); } return 0;} e12345678910111213141516171819为情所困退学在家的钱哥毅然决定养猪！在2010年1月1日，他买了一只刚出生的母猪幼仔，假设每只小母猪从第3个年头开始，每年的第一天都会生出4只小母猪，同时，钱哥会在每年的12月31日售出所有差一天就要年满5周岁的猪。请计算：在第N年（2010年是第1年，2011是第2年，依次类推）的今天（5月4日），钱哥的养猪场会存栏多少只猪?Input输入数据第一行是一个整数T(0&lt;T&lt;=40)，表示测试数据的组数.接下来有T行，每行有一个数N(0&lt;N&lt;=40)表示一组测试数据，其含义如题目描述。Output对于每个测试实例，请输出在第N年的今天母猪的数量，每组数据的输出占一行。Sample Input3235Sample Output1529 123456789101112131415161718192021#include &lt;stdio.h&gt; int main(){ int test, n; int a[44] = {0, 1, 0, 4, 4}; int sum[44] = {0, 1, 1, 5, 9}; int i; for (i = 5; i &lt; 44; ++i) { a[i] = (a[i - 2] + a[i - 3] + a[i - 4]) * 4; sum[i] = sum[i - 1] + a[i] - a[i - 5]; } scanf(\"%d\", &amp;test); for (; test &gt; 0; --test) { scanf(\"%d\", &amp;n); printf(\"%d\\n\", sum[n]); } return 0;}","link":"/2019/12/18/训练赛1/"},{"title":"递归专题","text":"递推专题hdoj2040 problemA 先通过循环找到有多少种组，然后再对这些组合进行排列 用dfs，但是dfs根本就不能决定下一次是走2步还是一步 一个斐波那契数列，为什么是斐波那契数列呢，因为你可以这样想，如果前面的方法全部知道，那么最后一个f(n）的走法，就是f(n-1)+f(n-2)。 空间换时间的思想 12345678910111213141516171819202122232425262728293031323334353637#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;int a[100];//设置一个保存计算重复的数据int f(int n){ int ans; if (n == 1) return 1; if (n == 2) return 1; if (n &gt; 2)//如果N&gt;2需要调用前面的n-1和n-2进行计算 { if (a[n] != -1){//优先查看是否已经计算过 ans = a[n]; } else{//否则递归 ans = f(n - 1) + f(n - 2); a[n] = ans;//记得将这个递归计算的结果写入到以n为下标的数组，其他递推可以在计算时候直接调用这个值 } } return ans;}int main(){ int n,m; cin &gt;&gt; n; for (int i = 0; i &lt; 100; i++) a[i] = -1;//将数组置为-1 for (int i = 0; i &lt; n; i++){ cin &gt;&gt; m; cout &lt;&lt; f(m)&lt;&lt;endl; } return 0;} 迭代 12345678910111213int climbStairs(int n) { int sum=0,p1=1,p2=1; if(1==n) return 1; if(2==n) return 1; while(n&gt;2) { sum=p1+p2; p1=p2; p2=sum; n--; } return sum;} hdoj20441234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;int N;int a,b;long long dp[51];void solve(){ dp[0]=0; dp[1]=1; dp[2]=2; for(int i=3;i&lt;50;i++) { dp[i]=dp[i-1]+dp[i-2]; }}int main(){ cin&gt;&gt;N; solve(); while(N--) { scanf(\"%d%d\",&amp;a,&amp;b); cout&lt;&lt;dp[b-a]&lt;&lt;endl; } return 0;}//用数组存不会炸数 12345678910111213141516171819202122232425262728293031323334353637 #include &lt;bits/stdc++.h&gt;using namespace std;const int maxn=41;typedef long long ll;//int f1[201]={0};//int f2[201];//vector&lt;int&gt; f;//int f[maxn];int climbStairs(int n) { ll sum=0,p1=1,p2=2; if(n==0) return 0; if(n==1) return 1; if(n==2) return 2; while(n&gt;2) { sum=p1+p2; p1=p2; p2=sum; n--; } return sum;}int number,a,b=0;int main(){ while (~scanf(\"%d\",&amp;number)) { while (number--) { scanf(\"%d %d\",&amp;a,&amp;b); cout&lt;&lt;climbStairs(b-a)&lt;&lt;endl; }} return 0;}//用这个存会炸数 函数返回的时候，还有函数输入的时候也要表明longlong hdoj20451234567891011121314151617#include &lt;iostream&gt;using namespace std;int main(){ long long i,a[55]; a[1]=3; a[2]=6; a[3]=6; for(i=4;i&lt;=55;i++) a[i]=a[i-1]+a[i-2]*2; int n; while(scanf(\"%d\",&amp;n)!=EOF) { cout&lt;&lt;a[n]&lt;&lt;endl; } return 0;} 一般有递推的题目都是涉及到一步，两步的 而且要考虑少做一步和少做两步的情况 hdoj 2046这道题的话，首先我们不能仅仅只看前两个，要找到改变元素的基本单位元 就是假设，n-1的时候他有几种情况，n-2的时候会有几种不重复的情况 n-3的情况会不会又和n-1和n-2重复 分割问题123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899(1) n条直线最多分平面问题 题目大致如:n条直线，最多可以把平面分为多少个区域。 析:可能你以前就见过这题目，这充其量是一道初中的思考题。但一个类型的题目还是从简单的入手，才容易发现规律。当有n-1条直线时，平面最多被分成了f（n-1）个区域。则第n条直线要是切成的区域数最多，就必须与每条直线相交且不能有同一交点。这样就会得到n-1个交点。这些交点将第n条直线分为2条射线和n-2条线断。而每条射线和线断将以有的区域一分为二。这样就多出了2+（n-2）个区域。 故：f(n)=f(n-1)+n =f(n-2)+(n-1)+n …… =f(1)+1+2+……+n =n(n+1)/2+1 (2) 折线分平面（hdu2050） 根据直线分平面可知，由交点决定了射线和线段的条数，进而决定了新增的区域数。当n-1条折线时，区域数为f（n-1）。为了使增加的区域最多，则折线的两边的线段要和n-1条折线的边，即2*（n-1）条线段相交。那么新增的线段数为4*（n-1），射线数为2。但要注意的是，折线本身相邻的两线段只能增加一个区域。 故：f(n)=f(n-1)+4(n-1)+2-1 =f(n-1)+4(n-1)+1 =f(n-2)+4(n-2)+4(n-1)+2 …… =f(1)+4+4*2+……+4(n-1)+(n-1) =2n^2-n+1//不一定对 (3) 封闭曲线分平面问题 题目大致如设有n条封闭曲线画在平面上，而任何两条封闭曲线恰好相交于两点，且任何三条封闭曲线不相交于同一点，问这些封闭曲线把平面分割成的区域个数。 析：当n-1个圆时，区域数为f(n-1).那么第n个圆就必须与前n-1个圆相交，则第n个圆被分为2（n-1）段线段，增加了2（n-1）个区域。 故： f(n)=f(n-1)+2(n-1) =f(1)+2+4+……+2(n-1) =n^2-n+2 (4)平面分割空间问题（hdu1290） 由二维的分割问题可知，平面分割与线之间的交点有关，即交点决定射线和线段的条数，从而决定新增的区域数。试想在三维中则是否与平面的交线有关呢？当有n-1个平面时，分割的空间数为f（n-1）。要有最多的空间数，则第n个平面需与前n-1个平面相交，且不能有共同的交线。即最多有n-1 条交线。而这n-1条交线把第n个平面最多分割成g（n-1）个区域。（g（n）为（1）中的直线分平面的个数）此平面将原有的空间一分为二，则最多增加g（n-1）个空间。 故：f=f(n-1)+g(n-1) ps:g(n)=n(n+1)/2+1 =f(n-2)+g(n-2)+g(n-1) …… =f(1)+g(1)+g(2)+……+g(n-1) =2+(1*2+2*3+3*4+……+(n-1)n)/2+（n-1） =(1+2^2+3^2+4^2+……+n^2-1-2-3-……-n )/2+n+1 =(n^3+5n)/6+1 123首先我们从一条线的开始判断,要使得取的面最多，则n条线要与n-1条线之间都要有交点，则当第n条线与n-1条线相交的时候，则会出现n-2条线段和2条射线，此n-2条线段会将已有的面分成两个面，每条射线也会将已有的面分成两个面，则我们得出一下式子为f(n)=f(n-1)+n-2+2;起分别为当加入第n条线的时候，则会在第n-1条基础上再多家n-2（线段切割的面）+2(两条射线切割的面)当我们折线的时候，则在第n条折线的时候，我们首先利用第n条折线中的其中一条折边穿过第n-1条折线这些线，为了取得最多面，由于第n-1条折线会产生2(n-1)条线，则要使其折边穿过这2(n-1)条线，则当这条折边穿过这些线的时候会产生，2（n-1）-1条线段，以及两条射线，同理得另外一条折线也可以产生2（n-1）-1条线段，以及两条射线。则他们之间在第n-1条折线的基础上会多增加2（n-1）-1+2（其中一条折线产生的两条射线的多出的两面）+2（n-1）-1+2（另外一条折线产生的两条射线的多出的两面），但是由于这两条折线之间会有交点，则其这第n-1条折线总共会产生两条折线而已，又由于另外两条射线相交产生一个面，则要把这个面加上去，把另外射线产生的面给减掉，则得出公式为多：增加**2（n-1）-1+2（其中一条折线产生的两条射线的多出的两面）+2（n-1）-1+2（另外一条折线产生的两条射线的多出的两面）+1（两条射线产生的面）-2（去掉两条射线产生的面，因为他们之间相交了），则化简得公式f(n)=f(n-1)+4*n-3; 思路：和n条直线最多能把平面分成多少个部分规律相同，但需要进一步处理。 ​ 把画折线当作画直线处理即：每画一条折线，就当作画两条直线处理,最后由于两条直线相交时延长线就不再画出。所以在两条直线的基础上，减去2（折线情况比直线情况少2个部分,见图） 注意输入的时候可能会不对 hdoj2018123456789101112131415161718192021222324252627282930313233343536 #include &lt;bits/stdc++.h&gt;using namespace std;const int maxn=41;typedef long long ll;//int f1[201]={0};//int f2[201];//vector&lt;int&gt; f;//int f[maxn];ll color(int a){ ll n1=1; ll n2=2; ll n3=3; ll sum=0; if(a==1) return 1; if(a==2) return 2; if(a==3) return 3; for (int i = 3; i &lt; a; i++) { sum=n3+n1; n1=n2; n2=n3; n3=sum; } return sum;}int main(){ int n,t; while (~scanf(\"%d\",&amp;n) &amp;&amp; n) { printf(\"%d\\n\",color(n)); } return 0;}//用这个存会炸数 递推一定要找到变化量和不变量 比如说这个题，到什么时候某些数才会开始变化? f(n-1)同时还可以把年份和数量联系起来 第n年的母牛的来源分别来自于前一年剩下的和往前推3年的母牛（能生的母牛，最早的也算在里面） 以前5年为例：{1,2,3,4,6} 6 = 前一年剩下的4头牛+（第2年新产的母牛刚具有生育能力生下的1头+最早的母牛1头） #include &lt;stdio.h&gt; int main(){ int test, n; int a[22] = {0, 1, 0, 4, 4}; int sum[22] = {0, 1, 1, 5, 9}; int i; for (i = 5; i &lt; 21; ++i) { a[i] = (a[i - 2] + a[i - 3] + a[i - 4]) * 4; sum[i] = sum[i - 1] + a[i] - a[i - 5]; } scanf(“%d”, &amp;test); for (; test &gt; 0; –test) { scanf(“%d”, &amp;n); printf(“%d\\n”, sum[n]); } return 0;} hdoj 2190123456789101112131415161718192021#include &lt;iostream&gt;using namespace std;int main(){ long long i,a[55]; a[1]=1; a[2]=3; a[3]=5; for(i=4;i&lt;=55;i++) a[i]=a[i-1]+a[i-2]*2; int n,t; while(scanf(\"%d\",&amp;t)!=EOF) { while (t--) { cin&gt;&gt;n; cout&lt;&lt;a[n]&lt;&lt;endl; } } return 0;} 原题！！！ 竟然还不会做，这就是骨牌铺地砖、 hdoj 2501和前面一样的思路 dfs三个方向的深搜 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;fstream&gt;using namespace std;bool maze[25][50];int n,sum;int dir[3][2]={0,1,0,-1,-1,0};void dfs(int x,int y,int step){ if(step==n)sum++; else { for(int i=0;i&lt;3;i++) { int newx=x+dir[i][0]; int newy=y+dir[i][1]; if(maze[newx][newy])continue; maze[newx][newy]=1; dfs(newx,newy,step+1); maze[newx][newy]=0; } } }int main(){ int c; cin&gt;&gt;c; int ans[25]; ans[0]=0; for(n=1;n&lt;=20;n++) { memset(maze,0,sizeof(maze)); maze[20][20]=1; sum=0; dfs(20,20,0); ans[n]=sum; } ofstream fout; fout.open(\"file1.txt\"); for(int i=1;i&lt;=20;i++)fout&lt;&lt;ans[i]&lt;&lt;\" \"; /*while(c--) { cin&gt;&gt;n; cout&lt;&lt;ans[n]&lt;&lt;endl; }*/ return 0;} 1234567891011121314151617181920212223242526272829303132333435363738394041\"\"\"改进之后的版本\"\"\" #include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=55;int result=0;int sum=0;int cor[maxn][maxn]={0}; //如果要memset怎么搞int dir[3][2]={{1,0},{-1,0},{0,1}};void dfs(int x,int y,int n){ if (n == 0){ sum++; return; } for (int i = 0; i &lt; 3; i++){ //检查要放到for之后 if(cor[x+dir[i][0]][y+dir[i][1]] != 1){ cor[x+dir[i][0]][y+dir[i][1]] = 1;//不是cor[x][y]而是改变之后的坐标 dfs(x+dir[i][0],y+dir[i][1],n-1); //n++;这个为什么不用 cor[x+dir[i][0]][y+dir[i][1]] = 0; } } } //return ; int main(){ int c,n; scanf(\"%d\",&amp;c); while (c--) { sum=0; memset(cor,0,sizeof(cor)); cin&gt;&gt;n; cor[20][20]=1;//要把第一步弄为1 dfs(20,20,n); cout&lt;&lt;sum&lt;&lt;endl; } return 0;} 递推版本 12345678910111213141516171819202122232425262728#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=55; int StepL[maxn]={0};int StepR[maxn]={0};int StepUp[maxn]={0};int Sum[maxn]={0}; //全局范围内定义变量没问题int main(){ int c,n; StepL[0]=1; StepR[0]=1; StepUp[0]=1; Sum[0]=3; for (int i = 1; i &lt; 20; i++) { StepL[i]=StepUp[i-1]+StepR[i-1]; StepR[i]=StepL[i-1]+StepUp[i-1]; StepUp[i]=StepUp[i-1]+StepR[i-1]+StepL[i-1]; Sum[i]=StepL[i]+StepR[i]+StepUp[i]; } scanf(\"%d\",&amp;c); while (c--) { cin&gt;&gt;n; cout&lt;&lt;Sum[n-1]&lt;&lt;endl; } return 0;} 汉诺塔hdoj 1207 汉诺塔二（有四根柱子）首先这是个多柱汉诺塔问题，对于n阶汉诺塔，具体步骤如下： 首先我们将x个盘子移到B柱，步数为step(x); 然后将n-x个盘子移到C柱，步数为2^(n-x)-1; 最后我们再将B柱上的x个盘子移到C柱，步数为step(x)。 上面的x在1到n之间取值，对于每一个X，我们可以求出一个step(n),然后我们取其中的最小值作为最优解； step(n)为走到那里的最小步骤 123456789101112131415161718192021#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;double step[65]; //为防止溢出，使用doubleint main() { step[1] = 1; step[2] = 3; for(int i = 3; i &lt; 65; i ++) { step[i] = 100000; for(int j = 1; j &lt; i; j ++) { step[i] = min(step[i], (double)(2 * step[j] + pow(2, i - j) - 1)); } } int n; while(cin &gt;&gt; n) { cout &lt;&lt; step[n] &lt;&lt; endl; } return 0;} hdoj 2064 汉诺塔三（只能移到旁边）很郁闷，以前会做的汉诺塔问题居然一开始没想出来，好记性不如烂笔头，今日把这道题目记下来，方便以后查阅( ・◡・)这道题目和经典汉诺塔问题还不太一样，原题链接在此：HDU2064 不过题目再怎么变，思路还是一样的。汉诺塔问题重点在于找到递推式，分析思路即模拟搬圆盘的过程，设step[i]为搬动第i个圆盘需要的最小步数。思路如下： 首先将 i-1 个圆盘移动到最右边柱子上然后第 i 个圆盘移到中间前 i-1 个圆盘再移动到最左边的柱子上第 i 圆盘移动到最右边柱子上最后将i-1个圆盘移动到最右边的柱子上由上述过程可得递推式：step[i]=step[i-1]+1+step[i-1]+1+step[i-1]=3step[i-1]+2 整理之后也就是3^n次方 1234567891011121314#include&lt;cstdio&gt;using namespace std;int main(){ int n,i; long long step[35]; step[0]=2; for(i=1;i&lt;35;i++){ step[i]=3*step[i-1]+2; } while(scanf(\"%d\",&amp;n)!=EOF){ printf(\"%lld\\n\",step[n-1]); } return 0;} hdoj 2077 汉诺塔四（大的可以任意放）先引出：把i个盘子从左移到右且最大的盘子可以放在最上面 –最优做法为:先把上面i-1盘子移到中间 然后把最大的移到中间再移到右边 最后把中间i-1盘子移到右边则有公式：dp3[i] = 2*dp1[i-1]+2;现在我们需要求dp1的数据 即把i个盘子从左边移到中间所需次数且小的只能放在大的上面–最优做法为：先把i-1个盘子移到右边,把最大的移到中间,然后再把右边的i-1个盘子移到中间则有公式：dp1[i] = dp2[i-1] + dp1[i-1] +1; 1234567891011121314151617181920212223242526272829#include&lt;stdio.h&gt;#define max 20+1int dp2[max];//dp2[i]为汉诺塔3那道题的递推式(表示把i个盘子从左边移到右边所需次数),这里不做解释 int dp1[max];//dp1[i]表示把i个盘子从左边移到中间所需次数 需要借助dp2 的数据 int dp3[max];//dp3[i]就是照应题目的递推式 需要借助dp1的数据 int main(){ int t,n,i,j; dp2[1]=2;dp1[1]=1;dp3[1]=2; for(i=2;i&lt;max;i++) { dp2[i]=3*dp2[i-1]+2;//求dp2 } for(i=2;i&lt;max;i++)//求dp1 { dp1[i]=dp2[i-1]+1+dp1[i-1]; } for(i=2;i&lt;max;i++) { dp3[i]=2*dp1[i-1]+2; } scanf(\"%d\",&amp;t); while(t--) { scanf(\"%d\",&amp;n); printf(\"%d\\n\",dp3[n]); } return 0;} hdoj 1995 汉诺塔（求每个盘的移动次数）1.首先，k 号盘子的移动次数只与 k 下面的盘子数有关，而与 k 上面的盘子数无关，具体原因自己想一下（有问题可以在下方留言），所以，原问题就可以转化为这样： 给定 k 个盘子，最上方的盘子移动了多少次。 2.找规律：假设最上方的盘子编号为 1 。 k==1，移动 1 次 ； k==2，1 移动 2次， 2 移动 1 次； k==3，1 移动 4 次； 2 移动 2 次； 3 移动 1 次； 由此，我们猜测在移动过程中，i 号盘子的移动次数是 i-1 号盘子的两倍（实际上这就是正确的）； 则盘子数为 k ，1 号盘子的移动次数为 2^(k-1)； 3.得出答案：ans=2^(n-k)； 12345678910111213141516171819202122232425#include&lt;cstdio&gt;using namespace std; long long a[64]; void init(){ freopen(\"hdu1995.in\",\"r\",stdin); freopen(\"hdu1995.out\",\"w\",stdout);} void work(){ int i,j,k,t,n; for(a[0]=i=1;i&lt;=60;i++)a[i]=a[i-1]*2; while(scanf(\"%d\",&amp;t)==1)\\ for(i=1;i&lt;=t;i++)scanf(\"%d%d\",&amp;n,&amp;k),printf(\"%I64d\\n\",a[n-k]);} int main(){ init(); work(); return 0;} 正确代码 12345678910111213141516#include&lt;iostream&gt;#include&lt;stdio.h&gt;using namespace std;int main(){ int n,k; int t; scanf(\"%d \",&amp;t); while(t--){ cin&gt;&gt;n&gt;&gt;k; long long int sum=1; for(int i=1;i&lt;=n-k;i++) sum=sum*2; cout&lt;&lt;sum&lt;&lt;endl; } return 0;} 1996 汉诺塔6 （求汉诺塔摆放的总和）其实它就是求移动的所有可能，也就是n个盘子摆在三个塔上的任何可能的种数。可以这么思考这个问题：n个盘子分开摆在三个塔上，所有可能的种数（这个和高中时候的一个信封投递到邮箱的问题很类似，那个是4封信投到3个邮箱，求投的种数的）；n个盘子，每个盘子有3种摆法，所以n个盘子摆在3个塔上的摆法就有3n种。知道这个规律之后，我们的问题就迎刃而解了。 12345678910111213141516#include &lt;stdio.h&gt;#include &lt;math.h&gt;int main(){ int t; int n; while(scanf(&quot;%d&quot;,&amp;t)!=EOF) { while(t--) { scanf(&quot;%d&quot;,&amp;n); printf(&quot;%.0f\\n&quot;,pow(3,n)); } } return 0;}","link":"/2019/10/21/递归专题/"},{"title":"","text":"上一次是 排序，字符串，质数，约数定理，并查集，递推 第一次2033 人见人爱 A+B 模拟题HDOJ上面已经有10来道A+B的题目了，相信这些题目曾经是大家的最爱，希望今天的这个A+B能给大家带来好运，也希望这个题目能唤起大家对ACM曾经的热爱。这个题目的A和B不是简单的整数，而是两个时间，A和B 都是由3个整数组成，分别表示时分秒，比如，假设A为34 45 56，就表示A所表示的时间是34小时 45分钟 56秒。 Input 输入数据有多行组成，首先是一个整数N，表示测试实例的个数，然后是N行数据，每行有6个整数AH,AM,AS,BH,BM,BS，分别表示时间A和B所对应的时分秒。题目保证所有的数据合法。 Output 对于每个测试实例，输出A+B，每个输出结果也是由时分秒3部分组成，同时也要满足时间的规则（即：分和秒的取值范围在0~59），每个输出占一行，并且所有的部分都可以用32位整数表示。 2034 人见人爱A-B模拟题参加过上个月月赛的同学一定还记得其中的一个最简单的题目，就是{A}+{B}，那个题目求的是两个集合的并集，今天我们这个A-B求的是两个集合的差，就是做集合的减法运算。（当然，大家都知道集合的定义，就是同一个集合中不会有两个相同的元素，这里还是提醒大家一下） 呵呵，很简单吧？ Input 每组输入数据占1行,每行数据的开始是2个整数n(0&lt;=n&lt;=100)和m(0&lt;=m&lt;=100),分别表示集合A和集合B的元素个数，然后紧跟着n+m个元素，前面n个元素属于集合A，其余的属于集合B. 每个元素为不超出int范围的整数,元素之间有一个空格隔开.如果n=0并且m=0表示输入的结束，不做处理。 Output 针对每组数据输出一行数据,表示A-B的结果,如果结果为空集合，则输出“NULL”,否则从小到大输出结果,为了简化问题，每个元素后面跟一个空格. 2035 人见人爱A^B 快速幂求A^B的最后三位数表示的整数。说明：A^B的含义是“A的B次方” 2036 改革春风吹满地 计算几何“ 改革春风吹满地,不会AC没关系;实在不行回老家，还有一亩三分地。谢谢!（乐队奏乐）” 话说部分学生心态极好，每天就知道游戏，这次考试如此简单的题目，也是云里雾里，而且，还竟然来这么几句打油诗。好呀，老师的责任就是帮你解决问题，既然想种田，那就分你一块。这块田位于浙江省温州市苍南县灵溪镇林家铺子村，多边形形状的一块地，原本是linle 的，现在就准备送给你了。不过，任何事情都没有那么简单，你必须首先告诉我这块地到底有多少面积，如果回答正确才能真正得到这块地。发愁了吧？就是要让你知道，种地也是需要AC知识的！以后还是好好练吧… Input 输入数据包含多个测试实例，每个测试实例占一行，每行的开始是一个整数n(3&lt;=n&lt;=100)，它表示多边形的边数（当然也是顶点数），然后是按照逆时针顺序给出的n个顶点的坐标（x1, y1, x2, y2… xn, yn）,为了简化问题，这里的所有坐标都用整数表示。输入数据中所有的整数都在32位整数范围内，n=0表示数据的结束，不做处理。 Output 对于每个测试实例，请输出对应的多边形面积，结果精确到小数点后一位小数。每个实例的输出占一行。 12345678910111213141516171819202122232425262728293031323334#include&lt;stdio.h&gt;#include&lt;math.h&gt;int a[999];double s(int n,int m){ double len1; if(a[2*n]*a[2*n]+a[2*n+1]*a[2*n+1]==0) len1=0; else len1=sqrt(a[2*n]*a[2*n]+a[2*n+1]*a[2*n+1]); double len2; if(a[2*m]*a[2*m]+a[2*m+1]*a[2*m+1]==0) len2=0; else len2=sqrt(a[2*m]*a[2*m]+a[2*m+1]*a[2*m+1]); double len3; if((a[2*n]-a[2*m])*(a[2*n]-a[2*m])+(a[2*n+1]-a[2*m+1])*(a[2*n+1]-a[2*m+1])==0) len3=0; else len3=sqrt((a[2*n]-a[2*m])*(a[2*n]-a[2*m])+(a[2*n+1]-a[2*m+1])*(a[2*n+1]-a[2*m+1])); double p=(len1+len2+len3)/2; if(p*(p-len1)*(p-len2)*(p-len3)==0) return 0; else return sqrt(p*(p-len1)*(p-len2)*(p-len3));}int main(){ int n; double sum; while(scanf(\"%d\",&amp;n),n!=0){ for(int i=0;i&lt;2*n;i++) scanf(\"%d\",&amp;a[i]); sum=0; for(int i=0;i&lt;n;i++){ if(i!=n-1) sum+=s(i,i+1); else sum+=s(i,0); } printf(\"%.1lf\\n\",sum); } return 0;} 2037 今年暑假不AC 贪心“今年暑假不AC？”“是的。”“那你干什么呢？”“看世界杯呀，笨蛋！”“@#$%^&amp;*%…” 确实如此，世界杯来了，球迷的节日也来了，估计很多ACMer也会抛开电脑，奔向电视了。作为球迷，一定想看尽量多的完整的比赛，当然，作为新时代的好青年，你一定还会看一些其它的节目，比如新闻联播（永远不要忘记关心国家大事）、非常6+7、超级女生，以及王小丫的《开心辞典》等等，假设你已经知道了所有你喜欢看的电视节目的转播时间表，你会合理安排吗？（目标是能看尽量多的完整节目） Input 输入数据包含多个测试实例，每个测试实例的第一行只有一个整数n(n&lt;=100)，表示你喜欢看的节目的总数，然后是n行数据，每行包括两个数据Ti_s,Ti_e (1&lt;=i&lt;=n)，分别表示第i个节目的开始和结束时间，为了简化问题，每个时间都用一个正整数表示。n=0表示输入结束，不做处理。 Output 对于每个测试实例，输出能完整看到的电视节目的个数，每个测试实例的输出占一行。 Sample Input 1234567891011121314121 33 40 73 815 1915 2010 158 186 125 104 142 90 第二次2076 夹角有多大 模拟题 时间过的好快，一个学期就这么的过去了，xhd在傻傻的看着表，出于对数据的渴望，突然他想知道这个表的时针和分针的夹角是多少。现在xhd知道的只有时间，请你帮他算出这个夹角。 注：夹角的范围[0，180]，时针和分针的转动是连续而不是离散的。 1234567891011121314151617181920212223242526272829303132333435#include &lt;stdio.h&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;map&gt;#include &lt;cctype&gt;#define rep(i, a, n) for (int i = a; i &lt; n; i++)#define per(j, n, a) for (int j = n - 1; j &gt;= a; j--)using namespace std;int main(void){ int T; cin &gt;&gt; T; while (T--) { int h, m, s; cin &gt;&gt; h &gt;&gt; m &gt;&gt; s; if (h &gt; 12) { h -= 12; } double sum = 0.0; double n = s / 60.0 + m; sum += fabs(n * 6.0 - (h * 30.0 + n * 0.5)); if (sum &gt; 180.0) { sum = 360.0 - sum; } cout &lt;&lt; (int)sum &lt;&lt; endl; } return 0;} 2077 汉诺塔 递推还记得汉诺塔III吗？他的规则是这样的：不允许直接从最左(右)边移到最右(左)边(每次移动一定是移到中间杆或从中间移出)，也不允许大盘放到小盘的上面。xhd在想如果我们允许最大的盘子放到最上面会怎么样呢？（只允许最大的放在最上面）当然最后需要的结果是盘子从小到大排在最右边。 2078复习时间 排序12345678910111213141516171819202122232425#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;int main(){ int t; while(cin&gt;&gt;t) { int i,n,m; for(i=0;i&lt;t;i++) { cin&gt;&gt;n&gt;&gt;m; int j,a[50]; for(j=0;j&lt;n;j++) cin&gt;&gt;a[j]; sort(a,a+n); cout&lt;&lt;(100-a[0])*(100-a[0])&lt;&lt;endl; } } return 0;} 2079 选课时间 母函数又到了选课的时间了，xhd看着选课表发呆，为了想让下一学期好过点，他想知道学n个学分共有多少组合。你来帮帮他吧。（xhd认为一样学分的课没区别） 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;map&gt;#include&lt;string&gt;#include&lt;queue&gt;#pragma warning(disable:4996)#define sscc ios::sync_with_stdio(false)using namespace std;const int maxn = 110;#define inf 0x3f3f3f3f#define mem(k) memset(k,true,sizeof(k))#define memm(k) memset(k,0,sizeof(k))int t, n, m, q[maxn][3];int dp[maxn], a[maxn];int main(){ sscc; while (cin &gt;&gt; t){ while (t--){ memm(dp); cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; m; i++) { cin &gt;&gt; q[i][0] &gt;&gt; q[i][1]; } dp[0] = 1; for (int i = 0; i &lt; m; i++){ for (int j = n; j &gt;=q[i][0]; j--){ for (int k = 1; k &lt;= q[i][1]; k++){ if (j - k*q[i][0] &gt;= 0 &amp;&amp; dp[j - k*q[i][0]] != 0){ dp[j] += dp[j - k*q[i][0]]; } } } } cout &lt;&lt; dp[n] &lt;&lt; endl; } } return 0;} 母函数做法 用母函数解决即可，用c1[]初始化第一个多项式，数组下标代表多项式的指数，数组的值代表多项式的系数，用for循环模拟接下来的其它多项式，它们与c1[]相乘的结果存放在c2[]中，每一个多项式乘完后，把c2[]的结果赋值给c1[]，c2[]重新置空。 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;#include &lt;stdio.h&gt;using namespace std;int main(){ int cas,n,k,a[10],b[10],c1[50],c2[50]; int i,j,s; scanf(\"%d\",&amp;cas); while(cas--) { memset(c1,0,sizeof(c1)); memset(c2,0,sizeof(c2)); scanf(\"%d%d\",&amp;n,&amp;k); for(i=0;i&lt;k;i++) { scanf(\"%d%d\",&amp;a[i],&amp;b[i]); } for(i=0;i&lt;=b[0]&amp;&amp;i*a[0]&lt;=n;i++) { c1[i*a[0]]=1; } for(i=1;i&lt;k;i++) { for(j=0;j&lt;=b[i]&amp;&amp;j*a[i]&lt;=n;j++) { for(s=0;s&lt;=n;s++) { if(c1[s]&gt;0&amp;&amp;s+j*a[i]&lt;=n) c2[s+j*a[i]] = c2[s+j*a[i]] + c1[s]; } } memcpy(c1,c2,sizeof(c1)); memset(c2,0,sizeof(c2)); } printf(\"%d\\n\",c1[n]); } return 0;} 2080 夹角有多大Ⅱ 计算几何模板题这次xhd面临的问题是这样的：在一个平面内有两个点，求两个点分别和原点的连线的夹角的大小。 注：夹角的范围[0，180]，两个点不会在圆心出现。 1234567891011121314151617#include&lt;stdio.h&gt;#include&lt;math.h&gt;#define pi 3.1415926 int main(){ double a,b,c,A,x1,x2,y1,y2,t; scanf(\"%lf\",&amp;t); while(t--) { scanf(\"%lf%lf%lf%lf\",&amp;x1,&amp;y1,&amp;x2,&amp;y2); a=sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2)); b=sqrt(x1*x1+y1*y1); c=sqrt(x2*x2+y2*y2); A=acos((b*b+c*c-a*a)/(2*b*c))/pi*180; printf(\"%.2lf\\n\",A); }} 第三次2081 手机短号 字符串大家都知道，手机号是一个11位长的数字串，同时，作为学生，还可以申请加入校园网，如果加入成功，你将另外拥有一个短号。假设所有的短号都是是 6+手机号的后5位，比如号码为13512345678的手机，对应的短号就是645678。现在，如果给你一个11位长的手机号码，你能找出对应的短号吗？ 12345678910111213141516171819202122232425#include &lt;bits/stdc++.h&gt;using namespace std;char number[15];int main(){ int n; cin &gt;&gt; n; char ch; ch = getchar(); while (n--) { gets(number); cout &lt;&lt; \"6\"; for (int i = 0; number[i] != '\\0'; i++) { if (i &gt; 5) { cout &lt;&lt; number[i]; } } cout &lt;&lt; \"\\n\"; }} 2082 找单词 母函数只要是挑选组合的都是母函数 假设有x1个字母A， x2个字母B,….. x26个字母Z，同时假设字母A的价值为1，字母B的价值为2,….. 字母Z的价值为26。那么，对于给定的字母，可以找到多少价值&lt;=50的单词呢？单词的价值就是组成一个单词的所有字母的价值之和，比如，单词ACM的价值是1+3+14=18，单词HDU的价值是8+4+21=33。(组成的单词与排列顺序无关，比如ACM与CMA认为是同一个单词）。 Sample Input 12321 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 09 2 6 2 10 2 2 5 6 1 0 2 7 0 2 2 7 5 10 6 10 2 10 6 1 9 Sample Output 127379297 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;bits/stdc++.h&gt;#define fio ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);using namespace std;const int maxn = 55;int sup[maxn], temp[maxn];int a[maxn];/*2082:样例1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0母函数表达式为：x0 = 1(x0+1*x^1)(x0+1*x^2)(x0+1*x^3)= (1+x)(1+x^2)(1+x^3)= (1+x+x^2+x^3)(1+x^3)= 1 + x + x^2 + 2*x^3 + x^4 + x^5 + x^6&gt;=1 &amp;&amp; &lt;=50的指数前系数相加为7 */int main() { fio int n; cin &gt;&gt; n; while (n--) { //存放每个字母有多少个(项) for (int i = 1; i &lt;= 26; i++) cin &gt;&gt; a[i]; memset(sup, 0, sizeof(sup)); memset(temp, 0, sizeof(temp));//如果a存在&lt;=&gt;a≠0，a个数的指数项前系数赋1(a价值1) for (int i = 0; i &lt;= a[1]; i++) sup[i] = 1; //最外层表示正与第i个表达式相乘 for (int i = 2; i &lt;= 26; i++) { if (a[i] != 0) { //中层循环表示sup[]里的每一项 for (int j = 0; j &lt;= 50; j++) { //外层循环表示后面被乘多项式中的每一项 //k+=i：例如b有2(a[i] = 2)个，表达式为1+x^2+x^4; //i*a[i]，i为价值，a[i]为个数，相乘为每个字母的最大价值 for (int k = 0; k &lt;= i*a[i] &amp;&amp; j+k &lt;= 50; k += i) { temp[j+k] += sup[j];//j+k为相乘后的指数和 } } for (int j = 0; j &lt;= 50; j++) sup[j] = temp[j];//更新 memset(temp, 0, sizeof(temp)); } } int sum = 0; for (int i = 1; i &lt;= 50; i++) { sum += sup[i]; } cout &lt;&lt; sum &lt;&lt; endl; }} 2083 简易版之最短距离 排序输出与中位数相减的结果 Problem Description 寒假的时候，ACBOY要去拜访很多朋友，恰巧他所有朋友的家都处在坐标平面的X轴上。ACBOY可以任意选择一个朋友的家开始访问，但是每次访问后他都必须回到出发点，然后才能去访问下一个朋友。比如有4个朋友，对应的X轴坐标分别为1， 2， 3， 4。当ACBOY选择坐标为2的点做为出发点时，则他最终需要的时间为 |1-2|+|2-2|+|3-2|+|4-2| = 4。现在给出Ｎ个朋友的坐标，那么ACBOY应该怎么走才会花费时间最少呢？ Input 输入首先是一个正整数M，表示M个测试实例。每个实例的输入有2行，首先是一个正整数N（N &lt;= 500)，表示有N个朋友，下一行是N个正整数，表示具体的坐标(所有数据均&lt;=10000). Output 对于每一个测试实例，请输出访问完所有朋友所花的最少时间，每个实例的输出占一行。 Sample Input 1234522 2 4 3 2 4 6 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;iostream&gt;#include&lt;cmath&gt;#include&lt;string&gt;void bubbleSort(int a[],int n){ for( int i = 0;i &lt; n;i ++) { for( int j = i+1;j &lt; n;j ++) { if(a[j]&lt;a[i]) { int temp; temp = a[i]; a[i]=a[j]; a[j]=temp; } } } }using namespace std;int main(){ int m,n,i,sum,a[500]; cin &gt;&gt; m; while(m--) { cin &gt;&gt; n; sum = 0; for(i=0;i &lt; n;i ++) { cin &gt;&gt; a[i]; } bubbleSort(a,n); for( i = 0;i &lt; n;i++) { if(n%2==0) { sum += abs(a[n/2]-a[i]) ; } else { sum += abs(a[(n-1)/2]-a[i]); } } cout &lt;&lt; sum &lt;&lt; endl; } system(\"pause\"); } 2084 数塔 记忆化搜索+DP2085 核反应堆 递推某核反应堆有两类事件发生：高能质点碰击核子时，质点被吸收，放出3个高能质点和1个低能质点；低能质点碰击核子时，质点被吸收，放出2个高能质点和1个低能质点。假定开始的时候（0微秒）只有一个高能质点射入核反应堆，每一微秒引起一个事件发生(对于一个事件，当前存在的所有质点都会撞击核子)，试确定n微秒时高能质点和低能质点的数目。 Input 输入含有一些整数n(0≤n≤33)，以微秒为单位，若n为-1表示处理结束。 Output 分别输出n微秒时刻高能质点和低能质点的数量，高能质点与低能质点数量之间以逗号空格分隔。每个输出占一行。 Sample Input 125 2-1 Sample Output 12571, 20911, 4 非递归式版本 1234567891011121314151617181920#include &lt;iostream&gt;using namespace std;int main(){ int n = 0; while (cin &gt;&gt; n &amp;&amp; n != -1) { long long int a = 1, b = 0; while (n--) { long long int temp_1 = a; long long int temp_2 = b; a = 3 * temp_1 + temp_2 * 2; b = temp_1 + temp_2; } cout &lt;&lt; a &lt;&lt; \", \" &lt;&lt; b &lt;&lt; endl; } return 0;} 递归式版本 123456789101112#include &lt;cstdio&gt;long long int a[50] = {1, 3}, b[50] = {0, 1};int main(){ for (int i = 2; i &lt;= 33; i++) a[i] = 3 * a[i - 1] + 2 * b[i - 1], b[i] = a[i - 1] + b[i - 1]; int n; while (~scanf(\"%d\", &amp;n) &amp;&amp; n != -1) printf(\"%lld, %lld\\n\", a[n], b[n]); return 0;} 2086 A1？ 数学归纳法有如下方程：Ai = (Ai-1 + Ai+1)/2 - Ci (i = 1, 2, 3, …. n).若给出A0, An+1, 和 C1, C2, …..Cn.请编程计算A1 = ? Input 输入包括多个测试实例。对于每个实例，首先是一个正整数n,(n &lt;= 3000); 然后是2个数a0, an+1.接下来的n行每行有一个数ci(i = 1, ….n);输入以文件结束符结束。 Output 对于每个测试实例，用一行输出所求得的a1(保留2位小数). 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;stdio.h&gt;int main( void ){ int i, n; double a_0, a_n1, a_1,sum, c[3500]; while( scanf(\"%d\",&amp;n) != EOF ) //(n &lt;= 3000) { scanf(\"%lf%lf\",&amp;a_0,&amp;a_n1); //然后是2个数a0, an+1 for( i=1; i&lt;=n; i++ ) //n行每行有一个数ci(i = 1, ....n); scanf(\"%lf\",&amp;c[i]); //A1 = [nA0 + An+1 - 2(n*C1+(n-1)*C2+...+2*Cn-1+1*Cn) ]/(n+1) sum=0; for( i=1; i&lt;=n; i++ ) sum += (n-i+1) * c[i]; a_1 = ( n*a_0 + a_n1 - 2*sum ) / (n+1); printf(\"%.2lf\\n\",a_1); //用一行输出所求得的a1(保留2位小数). }}/*因为：Ai=(Ai-1+Ai+1)/2 - Ci, A1=(A0 +A2 )/2 - C1; A2=(A1 + A3)/2 - C2 , ... =&gt; A1+A2 = (A0+A2+A1+A3)/2 - (C1+C2) 2[(A1+A2)+(C1+C2)] = A0+A2+A1+A3; A1+A2 = A0+A3 - 2(C1+C2); =&gt; A1+A2 = A0+A3 - 2(C1+C2) 同理可得： A1+A1 = A0+A2 - 2(C1) A1+A2 = A0+A3 - 2(C1+C2) A1+A3 = A0+A4 - 2(C1+C2+C3) A1+A4 = A0+A5 - 2(C1+C2+C3+C4) ... A1+An = A0+An+1 - 2(C1+C2+...+Cn) ----------------------------------------------------- 左右求和 (n+1)A1+(A2+A3+...+An) = nA0 +(A2+A3+...+An) + An+1 - 2(nC1+(n-1)C2+...+2Cn-1+Cn) =&gt; (n+1)A1 = nA0 + An+1 - 2(nC1+(n-1)C2+...+2Cn-1+Cn) =&gt; A1 = [nA0 + An+1 - 2(nC1+(n-1)C2+...+2Cn-1+Cn)]/(n+1) *///https://blog.csdn.net/yu_ch_sh/article/details/38192243 1`/*纯粹数学题，找规律: An = (1/2)An-1 + (1/2)An+1 - Cn An-1 = (2/3)An-2 + (1/3)An+1 - (2/3)Cn - (4/3)Cn-1 An-2 = (3/4)An-3 + (1/4)An+1 - (1/2)Cn - Cn-1 - (3/2)Cn-2 An-3 = (4/5)An-4 + (1/5)An+1 - (2/5)Cn - (4/5)Cn-1 - (6/5)Cn-2 - (8/5)Cn-3 ...... 接着: A1 = (n/(n+1))A0 + (1/(n+1))An+1 - (2/(n+1))Cn - (4/(n+1))Cn-1 - ... -(2n/(n+1))C1 = [ nA0 + An+1 - 2(Cn + 2Cn-1 + 3Cn-2 + ... + nC1) ]/(n+1)*/` 第四次2107 founding of hdu 排序经过慎重的考虑，XHD,8600, LL，Linle以及RPG等ACM队员集体退役，甚至正在酝酿退学。为什么？要考研？那也不用退学呀…当然不是！真正的原因是他们想提前创业，想合伙成立一家公司，据说公司的名称都想好了，为了感谢多年的ACM集训队队长XHD，公司就叫海东集团(HaiDong Union),简称HDU.(对于这个公司名称,几个人私下里开玩笑说,外面的人看到HDU,可别以为是”胡捣集团”,呵呵)公司成立了，谁来做老大呢？这对于合伙的公司可是一个难题。好在几位同学经过几年的ACM训练，思维非常活跃，马上想到推选AC战斗力最强的一位来做老总。现在的问题就是，假设每人的AC战斗力是一个已知的整数，请编程输出最后选出的老总的AC战斗力。 Input 输入包含多组测试数据，每组数据占2行，首先一行是一个整数n(n&lt;100)，表示创立公司的人数，然后一行是n个32位整数，表示n个人的AC战斗力，n为0的时候结束输入。 Output 对于每个测试实例，请输出老总的AC战斗力，每个实例的输出占一行。 Sample Input 12331 2 30 12345678910111213141516171819#include&lt;stdio.h&gt;int main(void){ int n,i,m,x[100]; do { scanf(\"%d\",&amp;n); if(n==0) return -1; m=0; for(i=0;i&lt;n;i++) { scanf(\"%d\",&amp;x[i]); if(x[i]&gt;m) m=x[i]; } printf(\"%d\\n\",m); }while (n!=0); return 0;} 2108 shape of hdu 计算几何话说上回讲到海东集团推选老总的事情，最终的结果是XHD以微弱优势当选，从此以后，“徐队”的称呼逐渐被“徐总”所取代，海东集团（HDU）也算是名副其实了。创业是需要地盘的，HDU向钱江肉丝高新技术开发区申请一块用地，很快得到了批复，据说这是因为他们公司研发的“海东牌”老鼠药科技含量很高，预期将占全球一半以上的市场。政府划拨的这块用地是一个多边形，为了描述它，我们用逆时针方向的顶点序列来表示，我们很想了解这块地的基本情况，现在请你编程判断HDU的用地是凸多边形还是凹多边形呢？ Input 输入包含多组测试数据，每组数据占2行，首先一行是一个整数n，表示多边形顶点的个数，然后一行是2×n个整数，表示逆时针顺序的n个顶点的坐标（xi,yi），n为0的时候结束输入。 Output 对于每个测试实例，如果地块的形状为凸多边形，请输出“convex”,否则输出”concave”，每个实例的输出占一行。 Sample Input 12340 0 1 0 1 1 0 10 Sample Output 12345convex海东集团终于顺利成立了！后面的路，他们会顺顺利利吗？欲知后事如何，且听下回分解—— Author lcy 凸变形的特点是，对任意条边，其余的所有点都在这条变的一侧，用这个判断就行了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100算法： 过多边形任意一边做一条直线，如果其他各顶点都在这条直线的同侧，则把这个多边形叫做凸多边形我采用的是（1）输入数据（2）以相邻两点作为直线进行判断存在三种情况（我是利用高中的两点式求直线方程的~~）1平行x轴直线2平行y轴直线3既不平行x轴也不平行y轴（3）判断除了做这两条直线上的点，其他的点都是否在这条直线上的一边。判断是否满足条件~~~贴上代码~~#include&lt;stdio.h&gt;struct stu{ float x,y; } point[1000000];int n,sum1,sum2,sum,flag2,flag1,flag; //flag 是用来判断 特殊情况 平行x轴，y轴。 int judge(void);int judgex(int i); //判断平行x轴情况 int judgey(int i); //判断平行y轴情况 int main(){ int i,t,result; while(scanf(\"%d\",&amp;n)&amp;&amp;n!=0){ //输入数据 for(i=1;i&lt;=n;i++) scanf(\"%f %f\",&amp;point[i].x,&amp;point[i].y); point[i].x=point[1].x; point[i].y=point[1].y; sum1=sum2=sum=0; result=judge(); if(result==1)printf(\"convex\\n\"); //根据judge的返回值来判断是否是凸包 else printf(\"concave\\n\"); } }int judge(void){ int recycle,i,j; float a,b; recycle=n; for(j=1;j&lt;=recycle;j++){ //判断所有点是否在一条直线的同侧 flag1=flag2=flag=0; if(point[j].x-point[j+1].x==0){judgey(j);if(flag==1)sum++;/*printf(\"sum=%d\\n\",sum);*/continue; } if(point[j].y-point[j+1].y==0){judgex(j);if(flag==1)sum++;/*printf(\"sum=%d\\n\",sum);*/ continue; } a=(point[j].y-point[j+1].y)/(point[j].x-point[j+1].x); b=point[j].y-a*point[j].x; //printf(\"a=%f b=%f\\n\",a,b); // sum1=sum2=0; for(i=1;i&lt;=recycle;i++) { if(i==j||i==j+1) { sum1++;sum2++; //printf(\"sum1=%d sum2=%d\\n\",sum1,sum2); // continue; } if(a*point[i].x-point[i].y+b&gt;=0) sum1++; if(a*point[i].x-point[i].y+b&lt;=0) sum2++; //printf(\"sum1=%d sum2=%d\\n\",sum1,sum2); // } if(sum1==n||sum2==n) sum++; // printf(\"sum=%d\\n\",sum); } // printf(\"sum=%d\\n\",sum); // if(sum==n)return 1; else return 0; }int judgex(int i){ int j; for(j=1;j&lt;=n;j++) { if(point[i].y&gt;=point[j].y)flag1++; if(point[i].y&lt;=point[j].y)flag2++; } if(flag1==n||flag2==n)flag=1;}int judgey(int i){ int j; for(j=1;j&lt;=n;j++) { if(point[i].x&gt;=point[j].x)flag1++; if(point[i].x&lt;=point[j].x)flag2++; } if(flag1==n||flag2==n)flag=1; } 凸多边形是一个内部为凸集的简单多边形。凸多边形（Convex Polygon）指如果把一个多边形的所有边中，任意一条边向两方无限延长成为一直线时，其他各边都在此直线的同旁，那么这个多边形就叫做凸多边形，其内角应该全不是优角，任意两个顶点间的线段位于多边形的内部或边上。 2109 fighting of hdu 排序注意田忌赛马 在上一回，我们让你猜测海东集团用地的形状，你猜对了吗？不管结果如何，都没关系，下面我继续向大家讲解海东集团的发展情况：在最初的两年里，HDU发展非常迅速，综合各种ACM算法生成的老鼠药效果奇好，据说该药专对老鼠有效，如果被人误食了，没有任何副作用，甚至有传闻说还有健胃的效果，不过这倒没有得到临床验证。所以，公司的销量逐年递增，利润也是节节攀升，作为股东之一的公主负责财务，最近半年，她实在辛苦，多次因为点钞票造成双手抽筋而住院，现在在她面前你根本不要提到“钞票”二字，甚至“money”也不行，否则她立马双手抽筋，唉，可怜的公主…海东集团的发展令国人大为振奋，不过也引起了邻国同行业“东洋小苟株式会社”的嫉妒，眼看海东集团逐渐把他们原来的市场一一占领，心中自是不甘，于是派了n个人前来挑衅，提出要来一场比试真功夫的中日擂台赛，输的一方要自动退出老鼠药市场！他们提出的比赛规则是这样的：\\1. 每方派出n个人参赛；\\2. 出赛的顺序必须是从弱到强（主要担心中国人擅长的田忌赛马）；\\3. 每赢一场，得两分，打平得一分，否则得0分。东洋小苟果然够黑，不过他们万万没有想到，HDU可是卧虎藏龙，不仅有动若脱兔的Linle，还有力大如牛的伪**，更有下沙健美先生HeYing以及因为双手抽筋而练成鹰爪功的月亮公主，估计小苟他们也占不到什么便宜。假设每个队员的能力用一个整数来表示，你能告诉我最终的结果吗？ Input 输入包含多组测试数据，每组数据占3行，首先一行是一个整数n(n&lt;100)，表示每方上场队员的人数，接着的二行每行包含n个整数，分别依次表示中日两方人员的能力值，n为0的时候结束输入。 Output 对于每个测试实例，请输出比赛的结果，结果的格式如样例所示（数字和vs之间有且仅有一个空格），其中，HDU的比分在前。每个实例的输出占一行。 Sample Input 123435 2 61 3 40 Sample Output 12346 vs 0这次的擂台赛，HDU能赢吗？欲知后事如何，且听下回分解—— 123456789101112131415161718192021222324252627282930313233#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;int main(){ int n; while(cin&gt;&gt;n&amp;&amp;n!=0) { int a[105],b[105]; int i,x=0,y=0; for(i=0;i&lt;n;i++) { cin&gt;&gt;a[i]; } for(i=0;i&lt;n;i++) { cin&gt;&gt;b[i]; } sort(a,a+n); sort(b,b+n); for(i=0;i&lt;n;i++) { if(a[i]&gt;b[i]) {x+=2;} else if(a[i]&lt;b[i]) {y+=2;} else {x++;y++;} } cout&lt;&lt;x&lt;&lt;\" vs \"&lt;&lt;y&lt;&lt;endl; } return 0;} 2110 crisis of hdu 母函数话说上回讲到HDU大战东洋小苟，结果自然是中方大胜，这一战也使得海东集团在全球同行业中的地位更加巩固。随着集团的发展，很多创业时期的元老逐步功成身退，先是8600移民海外，然后是linle夫妇退隐山林，逐渐的，最初众多的元老只剩下XHD夫妇和Wiskey三人了。到了2020年，因为扩张过度加上老鼠数量逐年减少，公司的发展遇到了前所未有的危机，此时集团已经没有任何流动资金，更可怕的是，这个时候，wiskey也决定退出了！退出本身并不麻烦，麻烦的是，退出的人需要取走相应比例（1/3）金额的资产。假设公司此时一共有n种价值的资产，每种价值的资产数量已知，请帮助心烦意乱的XHD夫妇计算一共有多少种分割资产的方法。 Input 输入包含多个测试实例，每个实例的第一行是一个整数n(n&lt;100)，表示一共有n种价值的资产，接着的n行每行包含两个整数pi和mi(0&lt;pi,mi&lt;10)，分别表示某种价值和对应的数量，n为0的时候结束输入。 Output 对于每个测试实例，请输出分割资产的方案数%10000，如果不能分割，请输出“sorry”，每个实例的输出占一行。 Sample Input 123421 12 10 Sample Output 12341面对朋友的退出和资金短缺，海东集团能度过难关吗？作为老总的XHD如何来化解这场危机？欲知后事如何，且听下回分解—— 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;iostream&gt;using namespace std ;#define MAX 30005typedef struct infor{ int num , value ;}infor ;int c1[MAX] , c2[MAX] ;int main(void){ int n ; while(cin&gt;&gt; n &amp;&amp; n) { memset(c1 , 0 ,sizeof(c1)); memset(c2 , 0 ,sizeof(c2)); int i , j , k , sum = 0 ; infor a[102] ; for( i = 0 ; i &lt; n ; i++){ cin &gt;&gt; a[i].value &gt;&gt; a[i].num ; sum +=a[i].value * a[i].num ; } if(sum%3) { cout&lt;&lt;\"sorry\"&lt;&lt;endl; continue ; } sum /= 3 ; for( i = 0 ; i &lt;= a[0].num*a[0].value ; i +=a[0].value) c1[i] = 1 ; for( i = 1 ; i &lt; n ; i ++) { for( j = 0 ; j &lt;= sum ; j ++) for( k = 0 ; k &lt;= a[i].num * a[i].value ; k +=a[i].value) c2[j + k] +=c1[j] % 10000; for( j = 0 ; j &lt;= sum ; j ++) { c1[j] = c2[j] % 10000; c2[j] = 0; } } if(c1[sum]) cout&lt;&lt;c1[sum]%10000&lt;&lt;endl; else cout&lt;&lt;\"sorry\"&lt;&lt;endl; } return 0;} 2111 saving of hdu 贪心话说上回讲到海东集团面临内外交困，公司的元老也只剩下XHD夫妇二人了。显然，作为多年拼搏的商人，XHD不会坐以待毙的。 一天，当他正在苦思冥想解困良策的时候，突然想到了自己的传家宝，那是公司成立的时候，父亲作为贺礼送来的一个锦囊，徐父当时交代，不到万不得已的时候，不要打开它。“现在不正是最需要的时候吗？”，一边想，XHD一边找到了这个精心保管的锦囊，打开一看，里面只有一句话“杭城北麓千人洞有宝”。 二话不说，XHD拿起一个大口袋就出发了，这个千人洞他是知道的，小的时候，爸爸曾经带他来过这个隐蔽的路口，并告诉他，这是千人洞。他现在才明白爸爸当初这句话的含义。 尽管有点印象，XHD还是花了很大的精力才找到这个异常隐蔽的洞口，走进一看，几乎惊呆了，真的是眼花缭乱！不过尽管宝贝的种类不少，但是每种宝贝的量并不多，当然，每种宝贝单位体积的价格也不一样，为了挽救HDU，现在请你帮忙尽快计算出来XHD最多能带回多少价值的宝贝？（假设宝贝可以分割，分割后的价值和对应的体积成正比） Input 输入包含多个测试实例，每个实例的第一行是两个整数v和n(v,n&lt;100)，分别表示口袋的容量和宝贝的种类，接着的n行每行包含2个整数pi和mi(0&lt;pi,mi&lt;10)，分别表示某种宝贝的单价和对应的体积，v为0的时候结束输入。 Output 对于每个测试实例，请输出XHD最多能取回多少价值的宝贝，每个实例的输出占一行。 Sample Input 12342 23 12 30 Sample Output 1234565经过锦囊相助，HDU会脱离危机吗？欲知后事如何，且听下回分解—— Author lcy 注意 单价是单位体积的价格 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=105;struct Treasure{ int p; int m;};bool cmp(Treasure x,Treasure y){ return x.p&gt;y.p;}int main(){ int v,n; struct Treasure treasure[maxn]; int sum=0; while (~scanf(\"%d\",&amp;v) &amp;&amp; v) { scanf(\"%d\",&amp;n); for (int i = 0; i &lt; n; i++) { cin&gt;&gt;treasure[i].p&gt;&gt;treasure[i].m; } sort(treasure,treasure+n,cmp); sum=0; for (int i = 0; i &lt; n; i++) { if (v-treasure[i].m &lt;= 0) { sum+=(treasure[i].p*v); v=0; break; } v=v-treasure[i].m; sum+=(treasure[i].p*treasure[i].m); //treasure[i].p=treasure[i].m=0; } cout&lt;&lt;sum&lt;&lt;endl; } return 0;} 2112 HDU today 最短路径1234567891011121314151617181920212223242526272829303132经过锦囊相助，海东集团终于度过了危机，从此，HDU的发展就一直顺风顺水，到了2050年，集团已经相当规模了，据说进入了钱江肉丝经济开发区500强。这时候，XHD夫妇也退居了二线，并在风景秀美的诸暨市浬浦镇陶姚村买了个房子，开始安度晚年了。这样住了一段时间，徐总对当地的交通还是不太了解。有时很郁闷，想去一个地方又不知道应该乘什么公交车，在什么地方转车，在什么地方下车（其实徐总自己有车，却一定要与民同乐，这就是徐总的性格）。徐总经常会问蹩脚的英文问路：“Can you help me?”。看着他那迷茫而又无助的眼神，热心的你能帮帮他吗？请帮助他用最短的时间到达目的地（假设每一路公交车都只在起点站和终点站停，而且随时都会开）。 Input输入数据有多组，每组的第一行是公交车的总数N(0&lt;=N&lt;=10000)；第二行有徐总的所在地start，他的目的地end；接着有n行，每行有站名s，站名e，以及从s到e的时间整数t(0&lt;t&lt;100)(每个地名是一个长度不超过30的字符串)。note：一组数据中地名数不会超过150个。如果N==-1，表示输入结束。 Output如果徐总能到达目的地，输出最短的时间；否则，输出“-1”。 Sample Input6xiasha westlakexiasha station 60xiasha ShoppingCenterofHangZhou 30station westlake 20ShoppingCenterofHangZhou supermarket 10xiasha supermarket 50supermarket westlake 10-1 Sample Output50 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;bits/stdc++.h&gt;using namespace std;const int MAX_N = 10010;const int INF = 0x3f3f3f3f;typedef pair&lt;int,int&gt; P;struct edge{ int to , cost; edge(int tt, int tc) : to(tt) , cost(tc){};};vector&lt;edge&gt; G[MAX_N];map&lt;string,int&gt; name;int n; int Dijkstra(int st,int ed){ int dis[MAX_N]; fill(dis,dis+n+1,INF); priority_queue&lt; P , vector&lt;P&gt; , greater&lt;P&gt; &gt; que; dis[st] = 0; que.push( P(0,st) ); while(!que.empty()){ P p = que.top(); que.pop(); int v = p.second; if( dis[v] &lt; p.first ) continue; for(int i = 0 ; i &lt; G[v].size() ; i++){ edge e = G[v][i]; if( dis[e.to] &gt; dis[v] + e.cost ){ dis[e.to] = dis[v] + e.cost; que.push( P(dis[e.to] , e.to) ); } } } return dis[ed];}int main(){ string s , e , st , ed;; int cost; while(~scanf(\"%d%\",&amp;n) &amp;&amp; n != -1){ name.clear(); for(int i = 0 ; i &lt; MAX_N ; i++) G[i].clear(); int cnt = 1; cin&gt;&gt; st &gt;&gt; ed; name[st] = cnt++; name[ed] = cnt++; for(int i = 0 ; i &lt; n ; i++){ cin&gt;&gt; s &gt;&gt; e &gt;&gt; cost; if( !name[s] ) name[s] = cnt++; if( !name[e] ) name[e] = cnt++; G[ name[s] ].push_back( edge( name[e] , cost )); G[ name[e] ].push_back( edge( name[s] , cost )); } int ret = Dijkstra(name[st],name[ed]); if( ret == INF ) printf(\"-1\\n\"); else printf(\"%d\\n\",ret); } return 0;} 1）当起点等于终点时，hash会出错 2）无向图 3）两个点之间不只一条路径（取最短就好） 4）没有通路的情况（输出-1） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;cmath&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;string&gt;#include&lt;map&gt;using namespace std;const int inf=0x3f3f3f3f;char s1[50],s2[50];int d[1005],e[1005][1005],used[1005];void dij(int s,int n){ int v,u,max=0; memset(used,0,sizeof(used)); for(u=1;u&lt;=n;u++) d[u]=inf; d[s]=0; while(1) { v=-1; for(u=1;u&lt;=n;u++) { if(!used[u]&amp;&amp;(v==-1||d[u]&lt;d[v])) v=u; } if(v==-1) break; used[v]=1; for(u=1;u&lt;=n;u++) if(d[u]&gt;d[v]+e[v][u]) d[u]=d[v]+e[v][u]; }}int main(){ int n; while(~scanf(\"%d\",&amp;n)) { if(n==-1) break; map &lt;string,int&gt; mp; for(int i=0;i&lt;=200;i++) for(int j=0;j&lt;=200;j++) e[i][j]=inf; scanf(\"%s%s\",s1,s2); mp[s1]=1;mp[s2]=2; if(strcmp(s1,s2)==0) { e[1][2]=0; } int num=2; for(int i=0;i&lt;n;i++) { int w; scanf(\"%s%s%d\",s1,s2,&amp;w); if(mp[s1]==0) mp[s1]=++num; if(mp[s2]==0) mp[s2]=++num; e[mp[s1]][mp[s2]]=min(e[mp[s1]][mp[s2]],w); e[mp[s2]][mp[s1]]=min(e[mp[s2]][mp[s1]],w); } dij(1,num); if(d[2]&lt;2000000) printf(\"%d\\n\",d[2]); else printf(\"-1\\n\"); }} 第五次2148 score 排序找累加和12345678910111213141516171819202122232425#include &lt;stdio.h&gt;int main(){ int t, n, k, i, a[1001], sum; while(scanf(\"%d\", &amp;t) != EOF) { while(t--) { sum = 0; scanf(\"%d %d\", &amp;n, &amp;k); for(i = 1; i &lt;= n; i++) { scanf(\"%d\", &amp;a[i]); } for(i = 1; i &lt;= n; i++) { if(a[i] &gt; a[k]) sum++; } printf(\"%d\\n\", sum); } } return 0;} 2149 public sale 巴什博弈虽然不想，但是现实总归是现实，Lele始终没有逃过退学的命运，因为他没有拿到奖学金。现在等待他的，就是像FarmJohn一样的农田生涯。 要种田得有田才行，Lele听说街上正在举行一场别开生面的拍卖会，拍卖的物品正好就是一块20亩的田地。于是，Lele带上他的全部积蓄，冲往拍卖会。 后来发现，整个拍卖会只有Lele和他的死对头Yueyue。 通过打听，Lele知道这场拍卖的规则是这样的：刚开始底价为0，两个人轮流开始加价，不过每次加价的幅度要在1～N之间，当价格大于或等于田地的成本价 M 时，主办方就把这块田地卖给这次叫价的人。 Lele和Yueyue虽然考试不行，但是对拍卖却十分精通，而且他们两个人都十分想得到这块田地。所以他们每次都是选对自己最有利的方式进行加价。 由于Lele字典序比Yueyue靠前，所以每次都是由Lele先开始加价，请问，第一次加价的时候，Lele要出多少才能保证自己买得到这块地呢？ Input 本题目包含多组测试，请处理到文件结束(EOF)。每组测试占一行。每组测试包含两个整数M和N(含义见题目描述，0&lt;N，M&lt;1100) Output 对于每组数据，在一行里按递增的顺序输出Lele第一次可以加的价。两个数据之间用空格隔开。如果Lele在第一次无论如何出价都无法买到这块土地，就输出”none”。 Sample Input 1234 23 23 5 Sample Output 1231none3 4 5 123456789101112131415161718192021222324#include&lt;stdio.h&gt;int main(){ int n,i,m; while(scanf(\"%d%d\",&amp;n,&amp;m)!=EOF) { if(n&lt;=m) { for(i=n;i&lt;=m;i++) { if(i&lt;m) printf(\"%d \",i); else printf(\"%d\\n\",i); } } else { if(n%(m+1)==0) printf(\"none\\n\"); else printf(\"%d\\n\",n%(m+1)); } }return 0;} 对个解的情况就是走的步数多余上限的情况 否则就控制位置在(能走的最大步数 长度+ 1)倍数的位置 2150 pipe 计算几何12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;using namespace std;#define MAX 100+5typedef long long LL;const double pi=3.141592653589793;const int INF=1e9;const double inf=1e20;const double eps=1e-6;const int mod=1000000007;struct point{ int x,y;}p[35][105];double circulation(point a,point b,point c){ return (b.x-a.x)*(c.y-a.y)-(b.y-a.y)*(c.x-a.x);}bool cross(point a,point b,point c,point d){ if(max(a.x,b.x)&gt;=min(c.x,d.x)&amp;&amp; max(c.x,d.x)&gt;=min(a.x,b.x)&amp;&amp; max(a.y,b.y)&gt;=min(c.y,d.y)&amp;&amp; max(c.y,d.y)&gt;=min(a.y,b.y)&amp;&amp; circulation(a,b,c)*circulation(a,d,b)&gt;=0&amp;&amp; circulation(a,c,d)*circulation(b,d,c)&gt;=0) return true; return false;}int main(){ int n,k[35]; while(cin&gt;&gt;n){ memset(k,0,sizeof(k)); memset(p,0,sizeof(p)); for(int i=0;i&lt;n;i++){ cin&gt;&gt;k[i]; for(int j=0;j&lt;k[i];j++) scanf(\"%d%d\",&amp;p[i][j].x,&amp;p[i][j].y); } if(n==1){ printf(\"No\\n\"); continue; } int flag=0; for(int i=0;i&lt;n-1;i++){ for(int j=1;j&lt;k[i];j++){ for(int t=i+1;t&lt;n;t++){ for(int h=1;h&lt;k[t];h++){ if(cross(p[i][j-1],p[i][j],p[t][h-1],p[t][h])){ flag=1; break; } } } } } if(flag) printf(\"Yes\\n\"); else printf(\"No\\n\"); } return 0;} 2151 worm 数塔dp自从见识了平安夜苹果的涨价后，Lele就在他家门口水平种了一排苹果树，共有N棵。 突然Lele发现在左起第P棵树上(从1开始计数)有一条毛毛虫。为了看到毛毛虫变蝴蝶的过程，Lele在苹果树旁观察了很久。虽然没有看到蝴蝶，但Lele发现了一个规律：每过1分钟，毛毛虫会随机从一棵树爬到相邻的一棵树上。 比如刚开始毛毛虫在第2棵树上，过1分钟后，毛毛虫可能会在第1棵树上或者第3棵树上。如果刚开始时毛毛虫在第1棵树上，过1分钟以后，毛毛虫一定会在第2棵树上。 现在告诉你苹果树的数目N，以及毛毛刚开始所在的位置P，请问，在M分钟后，毛毛虫到达第T棵树，一共有多少种行走方案数。 Input 本题目包含多组测试，请处理到文件结束(EOF)。每组测试占一行，包括四个正整数N,P,M,T(含义见题目描述，0&lt;N,P,M,T&lt;100) Output 对于每组数据，在一行里输出一共的方案数。题目数据保证答案小于10^9 Sample Input 123 2 4 23 2 3 2 Sample Output 1234567840Hint第一组测试中有以下四种走法：2-&gt;1-&gt;2-&gt;1-&gt;22-&gt;1-&gt;2-&gt;3-&gt;22-&gt;3-&gt;2-&gt;1-&gt;22-&gt;3-&gt;2-&gt;3-&gt;2 123一开始觉得是一道组合数学的问题，因为从起点P走到终点T必为向左走或向右走的有限集合（即只可以由向左走或向右走构成），且从起点P走到终点T的步是必走的，那么走M步减去从起点P到T必走的步后就是点与点之间的来回走了（即剩下的步向左走与向右走的步数必相等），那么总的方案数就是从走M步中挑出向左走或向右走的较少步（即为C(较少步，M)）。如果从起点P走到终点T为一直向左走，那么向右走就为较少步，同理，如果是向右走，那么向左走就为较少步，不难得出，较少步即为(M-|P-T|)/2,所有最终结果即为C((M-|P-T|)/2,M)。但是这种走法必须是不受限制的，比如如果起点为2，那么不能开始连续向左走2步，如果走到3，就不能连续向左走3步，所以这种方法解决不了。 换个思路，其实从第M步走到T只有两种可能，即第M-1步已经走到T-1了，然后从T-1走一步到T，或者第M-1步已经走到T+1了，然后从T+1走一步到T，而M-1步走到T-1必为从M-2步走到T-2或者从M-2步走到T走一步到T-1，同理，第M-1步走到T+1必为从第M-2步走到T或者走到T+2走一步到T+1，那么，很明显的dp了。 我们设数组dp[i][j].表示第i分钟从起点p走到j的方案数，很明显，按照以上结论，第i分钟从p走到j为从第i-1分钟在j-1或者第i-1分钟在j+1走一步第j,即dp[i][j]=dp[i-1][j-1]+dp[i-1][j+1](即从起点走i步到j的方案数等于从起点走i-1步到j-1或者从起点走i-1步到j+1的方案数之和)。枚举i从第一分钟到第M分钟，枚举j从第一个点到第N个点就AC了。 12345678910111213141516171819202122232425262728#include&lt;stdio.h&gt;#include&lt;string.h&gt;int mem[110][110];int dp(int n,int p,int m,int t){ int ans=0; if(mem[m][p]&gt;=0) return mem[m][p]; if(m==0){ if(p==t) return 1; else return 0; } if(p&gt;=1&amp;&amp;p&lt;n) ans+=dp(n,p+1,m-1,t); if(p&gt;1&amp;&amp;p&lt;=n) ans+=dp(n,p-1,m-1,t); mem[m][p]=ans; return ans;}int main(){ int n,p,m,t; while(~scanf(\"%d%d%d%d\",&amp;n,&amp;p,&amp;m,&amp;t)) { memset(mem,-1,sizeof(mem)); printf(\"%d\\n\",dp(n,p,m,t)); } return 0;} 12345678910111213141516171819202122232425//二维数组#include&lt;iostream&gt;using namespace std;int dp[101][101];int main(){ int i,j,k,l,n,m,p,t; while(scanf(\"%d%d%d%d\",&amp;n,&amp;p,&amp;m,&amp;t)!=EOF) { memset(dp,0,sizeof(dp)); dp[0][p]=1; for(i=1;i&lt;=m;i++) { for(j=1;j&lt;=n;j++) { if(dp[i-1][j-1]!=0 || dp[i-1][j+1]!=0) { dp[i][j]=dp[i-1][j-1]+dp[i-1][j+1]; } } } cout&lt;&lt;dp[m][t]&lt;&lt;endl; } return 0;} 123456789101112131415161718192021#include&lt;stdio.h&gt;double dp[100][100];int main(){ int n,p,m,t; int i,j; while(scanf(\"%d%d%d%d\",&amp;n,&amp;p,&amp;m,&amp;t)!=EOF){ for(i=0;i&lt;=m;i++) for(j=1;j&lt;=n;j++) dp[i][j]=0; dp[m][t]=1; for(i=m-1;i&gt;=0;i--){ for(j=2;j&lt;n;j++){ dp[i][j]=dp[i+1][j-1]+dp[i+1][j+1]; } dp[i][1]=dp[i+1][2]; dp[i][n]=dp[i+1][n-1]; } printf(\"%.0lf\\n\",dp[0][p]); } return 0;} 2152 fruit 母函数转眼到了收获的季节，由于有TT的专业指导，Lele获得了大丰收。特别是水果，Lele一共种了N种水果，有苹果，梨子，香蕉，西瓜……不但味道好吃，样子更是好看。 于是，很多人们慕名而来，找Lele买水果。 甚至连大名鼎鼎的HDU ACM总教头 lcy 也来了。lcy抛出一打百元大钞，”我要买由M个水果组成的水果拼盘，不过我有个小小的要求，对于每种水果，个数上我有限制，既不能少于某个特定值，也不能大于某个特定值。而且我不要两份一样的拼盘。你随意搭配，你能组出多少种不同的方案，我就买多少份！” 现在就请你帮帮Lele，帮他算一算到底能够卖出多少份水果拼盘给lcy了。 注意，水果是以个为基本单位，不能够再分。对于两种方案，如果各种水果的数目都相同，则认为这两种方案是相同的。 最终Lele拿了这笔钱，又可以继续他的学业了～ Input 本题目包含多组测试，请处理到文件结束(EOF)。每组测试第一行包括两个正整数N和M(含义见题目描述，0&lt;N,M&lt;=100)接下来有N行水果的信息，每行两个整数A,B(0&lt;=A&lt;=B&lt;=100)，表示至少要买该水果A个，至多只能买该水果B个。 Output 对于每组测试，在一行里输出总共能够卖的方案数。题目数据保证这个答案小于10^9 Sample Input 12345672 31 21 23 50 30 30 3 Sample Output 12212 12345678910111213141516171819202122232425262728293031323334353637#include &lt;bits/stdc++.h&gt;using namespace std;int main(){ int a[200][2]; int b[1005],c[1005];//b为正式数组，c为临时数组 int n,m; while(~scanf(\"%d%d\",&amp;n,&amp;m)) { memset(a,0,sizeof(a)); memset(b,0,sizeof(b)); for(int i=0;i&lt;n;i++) { scanf(\"%d%d\",&amp;a[i][0],&amp;a[i][1]); } for(int i=a[0][0];i&lt;=a[0][1];i++)//第一个水果初始化 { b[i]=1; } for(int i=1;i&lt;n;i++)//循环n-1个水果 { memset(c,0,sizeof(c));//c初始化为0 for(int x=0;x&lt;=m;x++)//循环0~m个水果的次数 { for(int y=a[i][0];y&lt;=a[i][1]&amp;&amp;x+y&lt;=m;y++)//循环第i+1个的水果 { c[x+y]+=b[x];//每次加上前一次的组合数 } } for(int x=0;x&lt;=m;x++)//将储存在c的组合数存入b数组 b[x]=c[x]; } cout&lt;&lt;b[m]&lt;&lt;endl; } return 0; } 第六次2186 一定要记住我爱你 简单计算2187 老人是真饿了 简单计算注意可能是性价比之类的问题 — 贪心 对于幸存的灾民来说，最急待解决的显然是温饱问题，救灾部队一边在组织人员全力打通交通，一边在组织采购粮食。现在假设下拨了一定数量的救灾经费要去市场采购大米（散装）。如果市场有m种大米，各种大米的单价和重量已知，请问，为了满足更多灾民的需求，最多能采购多少重量的大米呢？ Input 输入数据首先包含一个正整数C，表示有C组测试用例，每组测试用例的第一行是两个整数n和m（0&lt;n&lt;=1000,0&lt;m&lt;=1000）,分别表示经费的金额和大米的种类，然后是m行数据，每行包含2个整数p和h(1&lt;=p&lt;=25,1&lt;=h&lt;=100)，分别表示单价和对应大米的重量。 Output 对于每组测试数据，请输出能够购买大米的最多重量（你可以假设经费买不光所有的大米）。每个实例的输出占一行，保留2位小数。 Sample Input 123417 23 34 4 Sample Outputz 12.33 注意可能是性价比之类的问题 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;struct intn{ int p,h;}d[1100];bool cmp(intn a,intn b){ if(a.p==b.p)return a.h&gt;b.h; return a.p&lt;b.p;}int main(){ int c,n,m,i,money; double sum; while(cin&gt;&gt;c) { while(c--) { cin&gt;&gt;n&gt;&gt;m; for(i=0;i&lt;m;i++) cin&gt;&gt;d[i].p&gt;&gt;d[i].h; sort(d,d+m,cmp); sum=0; money=0; for(i=0;i&lt;m;i++) { money+=d[i].p*d[i].h; sum+=d[i].h; if(money&gt;n) { sum-=(money-n)*(double)1/d[i].p; break; } } printf(\"%.2lf\\n\",sum); } } return 0;} 2188 选拔志愿者 巴什博弈12345678910111213141516171819202122232425262728293031#include&lt;iostream&gt;using namespace std;int main(){ int c,n,m,i,j; cin&gt;&gt;c; while(c--) { cin&gt;&gt;n&gt;&gt;m; if(m&gt;=n) cout&lt;&lt;\"Grass\"&lt;&lt;endl; else { if(m==1) { if(n%2!=0) cout&lt;&lt;\"Grass\"&lt;&lt;endl; else cout&lt;&lt;\"Rabbit\"&lt;&lt;endl; } else { if(n%(m+1)) cout&lt;&lt;\"Grass\"&lt;&lt;endl; else cout&lt;&lt;\"Rabbit\"&lt;&lt;endl; } } } return 0;} 这几天开始学习博弈，发现这一块是个难啃的骨头。以下是我从网上收集的资料汇总： 我国民间有个古老的游戏：就是有物品若干堆，（物品可以是火柴，围棋都可以）。两个人轮流从堆中取若干件，规定取光物体者为胜。这个就是我们今天要研究的组合游戏。组合游戏定义： 1、有且仅有两个玩家 2、游戏双方轮流操作 3、游戏操作状态是个有限的集合（比如：取石子游戏，石子是有限的，棋盘中的棋盘大小的有限的） 4、游戏必须在有限次内结束 5、当一方无法操作时，游戏结束。现在我们来研究如何取胜: （一）巴什博奕（Bash Game）：有一堆n个物品，两人轮流从堆中取物品，每次取 x 个 （ 1 ≤ x ≤ m）。最后取光者为胜。 如果 n = m + 1， 一次至多取 m 个，所以无论先取者，取了多少个，一定还剩余 x 个（ 1 ≤ x ≤ m）。所以，后取者必胜。因此我们发现了取胜的秘诀：如果我们把 n 表示为n = (m + 1) * r + s 。（0 ≤ s &lt; m , r ≥ 0）。先取者 拿走 s 个, 后取者 拿走 k 个 (1 ≤ k ≤ m)，那么先取者 再 拿走 m + 1 - k 个。结果还剩下 ( m + 1 ) * ( r - 1 ) 个。我们只要始终给对手留下 m + 1 的倍数，那么 先取者 肯定必胜。 现在 我们可以知道，如果 s = 0，那么后取者必胜。 否则 先取者 必胜。 看完这个可以用这个练练手：hdu 1846 Brave Game （二）威佐夫博奕（Wythoff Game）：有两堆各若干个物品，两个人轮流从某一堆或同时从两堆中取同样多的物品，规定每次至少取一个，多者不限，最后取光者得胜。 这种情况下是颇为复杂的。我们用（a[k]，b[k]）（a[k] ≤ b[k] ,k=0，1，2，...,n)( a[k] 其中 k 为下标 )表示两堆物品的数量并称其为局势，如果甲面对（0，0），那么甲已经输了，这种局势我们称为奇异局势。前几个奇异局势是：（0，0）、（1，2）、（3，5）、（4，7）、（6，10）、（8，13）、（9，15）、（11，18）、（12，20）。 可以看出,a[0] = b[0] = 0,a[k]是未在前面出现过的最小自然数,而 b[k] = a[k] + k。奇异局势的性质： 1、任何自然数都包含在一个且仅有一个奇异局势中。 由于ak是未在前面出现过的最小自然数，所以有a[k] &gt; a[k-1] ，而 b[k] = a[k] + k &gt; a[k-1] + k &gt; a[k-1] + k - 1 = b[k-1] &gt; a[k-1] 。所以性质1成立。2。任意操作都可将奇异局势变为非奇异局势。 事实上，若只改变奇异局势（a[k]，b[k]）的某一个分量，那么另一个分量不可能在其他奇异局势中，所以必然是非奇异局势。如果使（a[k]，b[k]）的两个分量同时减少，则由于其差不变，且不可能是其他奇异局势的差，因此也是非奇异局势。3。采用适当的方法，可以将非奇异局势变为奇异局势。 假设面对的局势是（a , b），若 b = a，则同时从两堆中取走 a 个物体，就变为了奇异局势（0，0）；如果 a = a[k] ，b &gt; b[k] ,那么，取走b - b[k]个物体，即变为奇异局势；如果 a = a[k] ， b &lt; b[k] 则同时从两堆中拿走a - a[b-a] 个物体(如果不懂为什么减去a - a[b-a]，详见文章最后的注释1)变为奇异局势（ a[b-a], a[b-a] + b - a）；如果a &gt; a[k] ，b= a[k] + k 则从第一堆中拿走多余的数量a - a[k] 即可；如果a &lt; a[k] ，b= a[k] + k,分两种情况，第一种，a=a[j] （j &lt; k）从第二堆里面拿走 b - b[j] 即可；第二种，a=b[j] （j &lt; k）从第二堆里面拿走 b - a[j] 即可。 由上述性质可知，如果双方都采取正确操作，那么面对非奇异局势，先取者必胜。 那么我们要如何判断一个局势是否为奇异局势？公式如下： a[k] = [k（1+√5）/2]（a[k]这个方括号为下标运算符，[k（1+√5）/2]这个方括号为取整运算符），b[k] = a[k] + k 。奇妙的是其中出现了黄金分割数（1+√5）/2 = 1.618…因此，由a[k]，b[k]组成的矩形近似为黄金矩形，由于2/（1+√5）=（√5-1）/2，可以先求出 j = [a（√5-1）/2]，若 a = [ j（1+√5）/2]，那么a = a[j]，b[j] = a[j] + j，若不等于，那么a = a[j]+1，b = a[j] + j + 1，若都不是，那么就不是奇异局势。然后再按照上述法则进行，一定会遇到奇异局势。看完这个可以做一做poj 1067 取石子游戏，练练手【代码实现】 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;math.h&gt; int main(){ int a,b,k,a_k; while(scanf(“%d%d”,&amp;a,&amp;b)!=EOF){ k = abs(a-b); a = a &lt; b? a : b; a_k = floor(k*(1.0 + sqrt(5.0))/2); printf(“%d\\n”,a!=a_k); //输出为0，说明该点为必败点，1为必胜点 } return 0;}【文字描述上面代码】 k = | a - b |, a[k] = [ k（1+√5）/2], 如果 a,b中的最小值， min{a,b} 与 a[k]相等，那么 他就是奇异局势。 （三）尼姆博奕（Nimm Game）：有三堆各若干个物品，两个人轮流从某一堆取任意多的物品，规定每次至少取一个，多者不限，最后取光者得胜。 这种情况最有意思，它与二进制有密切关系，我们用（a，b，c）表示某种局势，首先（0，0，0）显然是奇异局势，无论谁面对奇异局势，都必然失败。第二种奇异局势是（0，n，n），只要与对手拿走一样多的物品，最后都将导致（0，0，0）。仔细分析一下，（1，2，3）也是奇异局势，无论对手如何拿，接下来都可以变为（0，n，n）的情形。计算机算法里面有一种叫做按位模2加，也叫做异或的运算，我们用符号（+）表示这种运算，先看（1，2，3）的按位模2加的结果：1 =二进制012 =二进制103 =二进制11 （+）———————0 =二进制00 （注意不进位）对于奇异局势（0，n，n）也一样，结果也是0。任何奇异局势（a，b，c）都有a（+）b（+）c =0。注意到异或运算的交换律和结合律，及a（+）a=0，:a（+）b（+）(a（+）b)=(a（+）a)（+）(b（+）b)=0（+）0=0。所以从一个非奇异局势向一个奇异局势转换的方式可以是：1）使 a = c（+）b2）使 b = a（+）c3）使 c = a（+）b 取火柴的游戏题目1：今有若干堆火柴，两人依次从中拿取，规定每次只能从一堆中取若干根，可将一堆全取走，但不可不取，最后取完者为胜，求必胜的方法。题目2：今有若干堆火柴，两人依次从中拿取，规定每次只能从一堆中取若干根，可将一堆全取走，但不可不取，最后取完者为负，求必胜的方法。嘿嘿，这个游戏我早就见识过了。小时候用珠算玩这个游戏：第一档拨一个，第二档拨两个，依次直到第五档拨五个。然后两个人就轮流再把棋子拨下来，谁要是最后一个拨谁就赢。有一次暑假看见两个小孩子在玩这个游戏，我就在想有没有一个定论呢。下面就来试着证明一下吧先解决第一个问题吧。定义：若所有火柴数异或为0，则该状态被称为利他态，用字母T表示；否则，为利己态，用S表示。[定理1]：对于任何一个S态，总能从一堆火柴中取出若干个使之成为T态。证明： 若有n堆火柴，每堆火柴有A(i)根火柴数，那么既然现在处于S态， c = A(1) xor A(2) xor … xor A(n) &gt; 0; 把c表示成二进制，记它的二进制数的最高位为第p位，则必然存在一个A(t),它二进制的第p位也是1。（否则，若所有的A(i)的第p位都是0，这与c的第p位就也为0矛盾）。 那么我们把x = A(t) xor c,则得到x &lt; A(t).这是因为既然A(t)的第p位与c的第p位同为1,那么x的第p位变为0,而高于p的位并没有改变。所以x &lt; A(t).而 A(1) xor A(2) xor … xor x xor … xor A(n) = A(1) xor A(2) xor … xor A(t) xor c xor … xor A(n) = A(1) xor A(2) xor… xor A(n) xor A(1) xor A(2) xor … xor A(n) = 0这就是说从A(t)堆中取出 A(t) - x 根火柴后状态就会从S态变为T态。证毕[定理2]：T态，取任何一堆的若干根，都将成为S态。证明：用反证法试试。 若 c = A(1) xor A(2) xor … xor A(i) xor … xor A(n) = 0； c’ = A(1) xor A(2) xor … xor A(i’) xor c xor … xor A(n) = 0; 则有c xor c’ = A(1) xor A(2) xor … xor A(i) xor … xor A(n) xor A(1) xor A(2) xor … xor A(i’) xor c xor … xor A(n) = A(i) xor A(i’) =0 进而推出A(i) = A(i’)，这与已知矛盾。所以命题得证。[定理 3]：S态，只要方法正确，必赢。 最终胜利即由S态转变为T态，任何一个S态，只要把它变为T态，（由定理1，可以把它变成T态。）对方只能把T态转变为S态(定理2)。这样，所有S态向T态的转变都可以有己方控制，对方只能被动地实现由T态转变为S态。故S态必赢。[定理4]：T态，只要对方法正确，必败。 由定理3易得。接着来解决第二个问题。定义：若一堆中仅有1根火柴，则被称为孤单堆。若大于1根，则称为充裕堆。定义：T态中，若充裕堆的堆数大于等于2，则称为完全利他态，用T2表示；若充裕堆的堆数等于0，则称为部分利他态，用T0表示。 孤单堆的根数异或只会影响二进制的最后一位，但充裕堆会影响高位（非最后一位）。一个充裕堆，高位必有一位不为0，则所有根数异或不为0。故不会是T态。[定理5]：S0态，即仅有奇数个孤单堆，必败。T0态必胜。证明：S0态，其实就是每次只能取一根。每次第奇数根都由己取，第偶数根都由对方取，所以最后一根必己取。败。同理, T0态必胜#[定理6]：S1态，只要方法正确，必胜。证明：若此时孤单堆堆数为奇数，把充裕堆取完；否则，取成一根。这样，就变成奇数个孤单堆，由对方取。由定理5，对方必输。己必胜。 #[定理7]：S2态不可转一次变为T0态。证明：充裕堆数不可能一次由2变为0。得证。 #[定理8]：S2态可一次转变为T2态。证明：由定理1，S态可转变为T态，态可一次转变为T态，又由定理6，S2态不可转一次变为T0态，所以转变的T态为T2态。 #[定理9]：T2态，只能转变为S2态或S1态。证明：由定理2，T态必然变为S态。由于充裕堆数不可能一次由2变为0，所以此时的S态不可能为S0态。命题得证。[定理10]：S2态，只要方法正确，必胜.证明：方法如下： 1） S2态，就把它变为T2态。（由定理8） 2） 对方只能T2转变成S2态或S1态（定理9） 若转变为S2, 转向1） 若转变为S1, 这己必胜。（定理5）[定理11]：T2态必输。证明：同10。综上所述，必输态有： T2,S0 必胜态： S2,S1,T0.两题比较：第一题的全过程其实如下：S2-&gt;T2-&gt;S2-&gt;T2-&gt; …… -&gt;T2-&gt;S1-&gt;T0-&gt;S0-&gt;T0-&gt;……-&gt;S0-&gt;T0(全0)第二题的全过程其实如下：S2-&gt;T2-&gt;S2-&gt;T2-&gt; …… -&gt;T2-&gt;S1-&gt;S0-&gt;T0-&gt;S0-&gt;……-&gt;S0-&gt;T0(全0)下划线表示胜利一方的取法。 是否发现了他们的惊人相似之处。我们不难发现(见加黑部分)，S1态可以转变为S0态（第二题做法），也可以转变为T0（第一题做法）。哪一方控制了S1态，他即可以有办法使自己得到最后一根（转变为T0）,也可以使对方得到最后一根（转变为S0）。 所以，抢夺S1是制胜的关键！ 为此，始终把T2态让给对方，将使对方处于被动状态，他早晚将把状态变为S1. 下一次将会和大家介绍，组合博弈游戏中的利器SG函数和SG定理。 注释1：因为奇异局势的项数是有 b[k] - a[k] 的差决定，每一个奇异局势的项数都是独一无二的。也就是说，我们 只能将 (a , b) (a = a[k], b &lt; b[k])转化为 （a[b-a], b[b-a]）。因为他们的差是确定的始终都是 b-a，故可以转化为 第 b-a 项。由此我们可以 将 (a , b) (a = a[k], b &lt; b[k]) 转化为奇异局势 （a[b-a], b[b-a]）也就是 （ a[b-a], a[b-a] + b - a）。所以我们可以逆推得出，只要将 两边 同时减去 a - a[b-a] 即可。 2189 来生一起走 母函数1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;iostream&gt;using namespace std;int prime[50]={2,3,5};int c1[152],c2[152];void primm(){ int k=3; for(int i=7;i&lt;=170;i++) { bool flag=true; for(int j=2;j*j&lt;=i;j++) { if(i%j==0) { flag=false; break; } } if(flag)prime[k++]=i; }}int main(){ int t,n,i,j,k; primm(); cin&gt;&gt;t; while(t--) { cin&gt;&gt;n; for(i=0;i&lt;=n;i++) { c2[i]=c1[i]=0; } for(i=0;i&lt;=n;i+=prime[0]) { c1[i]=1; } for(i=1;prime[i]&lt;=n;i++) { for(j=0;j&lt;=n;j++) { for(k=0;k+j&lt;=n;k+=prime[i]) { c2[k+j]+=c1[j]; } } for(j=0;j&lt;=n;j++) { c1[j]=c2[j]; c2[j]=0; } } cout&lt;&lt;c1[n]&lt;&lt;endl; } return 0;} 第X个素数是什么 素数就是不能再进行等分的整数。比如：7，11。而9不是素数，因为它可以平分为3等份。一般认为最小的素数是2，接着是3，5，…请问，第100002(十万零二)个素数是多少？请注意：2 是第一素数，3 是第二个素数，依此类推。 123456789101112131415161718192021222324252627282930313233343536373839#include&lt;iostream&gt;#define n 10000000using namespace std;bool a[10000000];int main(){ int x; x=100002; for(int i=2;i&lt;n/2;i++) { if (a[i]==1) { ; } else { for (int k=2;k&lt;=n/i;k++) { if (i*k&lt;n) a[i*k]=1; } } } int m=0; for (int i=2;i&lt;n;i++) { if (a[i]==0) { m++; if (m==x) { cout&lt;&lt;i; return 0; } } } return 0;} 2190 重建希望小学 递推地砖的那个公式 2191 珍惜现在感恩生活 01背包1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;using namespace std;static int dp[105][105]; //前i种物品价格为j的时候总重量static int p[105], h[105], c[105];int main(){ int C; scanf(\"%d\", &amp;C); while (C--) { int n, m; scanf(\"%d %d\", &amp;n, &amp;m); for (int i = 1; i &lt;= m; ++i) scanf(\"%d %d %d\", &amp;p[i], &amp;h[i], &amp;c[i]); memset(dp, 0, sizeof(dp)); int ans = 0; for (int i = 1; i &lt;= m; ++i) { for (int j = 0; j &lt;= n; ++j) { for (int k = 0; k &lt;= c[i]; ++k) { if (j &gt;= k * p[i]) { dp[i][j] = max(dp[i - 1][j - k * p[i]] + k * h[i], dp[i][j]); } } ans = max(ans, dp[i][j]); } } printf(\"%d\\n\", dp[m][n]); } return 0;} 第七次2500 做一个正气的杭电人 字符串123456789101112131415161718192021#include&lt;stdio.h&gt;int main(){ int n; scanf(\"%d\",&amp;n); while(n--) { int k,i=0,j=0; scanf(\"%d\",&amp;k); for(i=0;i&lt;k*3;i++) { for(j=0;j&lt;k;j++) { printf(\"HDU\"); } printf(\"\\n\"); } } return 0;} 2501 tiling_easy version 骨牌递推2502 月之数 递推当寒月还在读大一的时候，他在一本武林秘籍中（据后来考证，估计是计算机基础，狂汗-ing），发现了神奇的二进制数。如果一个正整数m表示成二进制，它的位数为n（不包含前导0），寒月称它为一个n二进制数。所有的n二进制数中，1的总个数被称为n对应的月之数。例如，3二进制数总共有4个，分别是4（100）、5（101）、6（110）、7（111），他们中1的个数一共是1＋2＋2＋3=8，所以3对应的月之数就是8。 Input 给你一个整数T，表示输入数据的组数，接下来有T行，每行包含一个正整数 n（1&lt;=n&lt;=20）。 Output 对于每个n ，在一行内输出n对应的月之数。 Sample Input 12343123 Sample Output 123138 123456789101112131415161718192021222324题意:统计N位二进制数的总1数。对于N位二进制数来说。首位必须是1,因此我们只要知道N-1位二进制数有多少个，且有多少个1就能递推得到N位二进制数有多少个1。显然n的答案为n-1的答案（即n-1）时的所有二进制的1的总和 + n-1的所有二进制数目（因为首位是1,所有n-1的所有二进制数前面在补个1就是N位的二进制数了，所以开头这个1的出现总数就等于n-1的所有二进制数目）要想知道一个n位的二进制数目有多少个就很简单了，2的n次方就是答案。因此，第二部分直接可以求，当然，这题如果数据要求过大，2的n次方可用位运算快速计算，或者直接套个快速幂来快速计算。那么问题在于n-1时所有的2进制数目有多少。这时候可能有朋友会说啦，啊，那直接加上n-1的答案就好了啊？错！我们开头就说过对于N位二进制数来说首位必须是一，因此你没考虑（n-1）（假设这里n=6）位如果是00001 00010 00011这些情况，因此要算上a1+a2+a3+a4+.....a(n-1)，这部分记为S。得递推式为：a(n)=S+2^(n-1)当然S这部分实际上可以根据排列组合的乘法原理优化成一个式子更简单，或者你用前缀和也可以再o(1)的复杂度内计算出S这部分秒出答案。 12345678910111213141516#include&lt;stdio.h&gt;main(){ int a[100][100],n,s,m,k,p; scanf(\\\"%d\\\",&amp;p); while(p--){ scanf(\\\"%d\\\",&amp;n); for(m=0;m&lt;n;m++){ a[m][m]=1; a[m][0]=1;} for(m=2;m&lt;n;m++){ for(k=1;k&lt;m+1;k++){ a[m][k]=a[m-1][k-1]+a[m-1][k];}} m=n;s=0; for(k=1;k&lt;=n;k++){ s=s+k*a[m-1][k-1];} printf(\\\"%d\\\\n\\\",s);}} 123456789101112131415161718192021#include&lt;cstdio&gt;int main(){ int t,n; int a[25]; int sum=0,p=1; for(int i=1;i&lt;25;i++) { a[i]=sum+p; sum+=a[i]; p*=2; //printf(\"%d\\n\",a[i]); } scanf(\"%d\",&amp;t); while(t--) { scanf(\"%d\",&amp;n); printf(\"%d\\n\",a[n]); } return 0;} 2503 a/b+c/d 公约数给你2个分数，求他们的和，并要求和为最简形式。 Input 输入首先包含一个正整数T（T&lt;=1000），表示有T组测试数据，然后是T行数据，每行包含四个正整数a,b,c,d（0&lt;a,b,c,d&lt;1000），表示两个分数a/b 和 c/d。 Output 对于每组测试数据，输出两个整数e和f，表示a/b + c/d的最简化结果是e/f，每组输出占一行。 Sample Input 12321 2 1 34 3 2 3 Sample Output 125 62 1 1234567891011121314151617181920212223242526272829303132#include &lt;stdio.h&gt;int main(){ int n,a,b,c,d,e,f,gys; int gbs(int,int); scanf(\"%d\",&amp;n); while(n--) { scanf(\"%d %d %d %d\",&amp;a,&amp;b,&amp;c,&amp;d); e=a*d+b*c; f=b*d; gys=gbs(e,f); printf(\"%d %d\\n\",e/gys,f/gys); }return 0;}int gbs(int a,int b){ int k,i; if(a%b==0||b%a==0) k=a&lt;b?a:b; else { k=(a&lt;b?a:b)/2;//从ab中的最小值开始计算。 for(i=0;i&lt;(a&lt;b?a:b);i++,k--) { if((a%k==0)&amp;&amp;(b%k==0)) break;//最大公约数。 } } return k;} 2504 又见GCD有三个正整数a,b,c(0&lt;a,b,c&lt;10^6)，其中c不等于b。若a和c的最大公约数为b，现已知a和b，求满足条件的最小的c。 Input 第一行输入一个n，表示有n组测试数据，接下来的n行，每行输入两个正整数a,b。 Output 输出对应的c，每组测试数据占一行。 Sample Input 12326 212 4 Sample Output 1248 1234567891011121314151617181920212223242526知道a,c的最大公约数为b,已知a,b，求最 小的c也就是已知gcd（a,c) = b，求最小的c。不要天真的的以为c=2b;不容忽视的是，题目要求b! = c,也就是c值从2b开始，然后一步步加c再判断a,c的最大公约数是否等于b，满足时输出c.AC代码:#include &lt;iostream&gt;using namespace std;int GCD(int x,int y){ return y==0?x:GCD(y,x%y);}int main(){ int t,a,b; cin&gt;&gt;t; while(t--) { cin&gt;&gt;a&gt;&gt;b; int c = 2*b; while(GCD(a,c)!=b) { c+=b; } cout&lt;&lt;c&lt;&lt;endl; } return 0;} 第八次2567 寻梦 字符串一开头想着搞个循环的合成 其实根本不用合成，直接输出就好了 墓碑上有2行字符串，其中第一个串的长度为偶数，现在要求把第2个串插入到第一个串的正中央，如此便能开启墓碑进入墓中 123456789101112131415#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;int main(){ int c; cin&gt;&gt;c; while(c--) { string a,b; cin&gt;&gt;a&gt;&gt;b; cout&lt;&lt;a.substr(0,a.size()/2)&lt;&lt;b&lt;&lt;a.substr(a.size()/2)&lt;&lt;endl; } return 0;} 2568 前进 模拟现已知yifenfei使用了2招（剑招A和剑招B）：剑招A，一招能杀死一半的蝙蝠。但是如果当前的蝙蝠数为奇数，那么就必须先出一招剑招B杀死其中任意一个，使蝙蝠数为偶数，再出剑招A。现在请问：杀死n只蝙蝠需要使出多少招剑招B？ Input 输入数据首先给出一个整数C，表示测试组数。然后是C组数据，每组包含一个正整数n (n&lt;2^31)。 Output 对应每组数据，请输出一个整数，表示yifenfei使用的剑招B的数目，每组输出占一行。 Sample Input 123215 Sample Output 1212 123456789101112131415#include&lt;stdio.h&gt;int main(){ int i,t,a,b; scanf(\"%d\",&amp;t); while(t--) { scanf(\"%d\",&amp;a); b=0; while(a!=0) b+=a&amp;1,a&gt;&gt;=1; printf(\"%d\\n\",b); } return 0;} 123456789101112131415161718192021#include &lt;stdio.h&gt;int main(){ int t,n,c; scanf(\"%d\",&amp;t); //输入测试数据的组数 while(t--) { c=0; //使用剑招B次数 scanf(\"%d\",&amp;n); //输入蝙蝠数 while(n) { if(n%2==1) //当n为奇数时,需要使用剑招B次数c++ c++; n=n/2; //当n为偶数时，使用剑招A，一招能杀死一半的蝙蝠 } printf(\"%d\\n\",c); } return 0;} 2569 彼岸 递推123456789101112131415161718192021222324252627282930用1,2,3表示三种颜色n=1时： n=2时： 计算n=3时：1 112 22 ---这里3种可以与3个方案搭配(即是1,2,3)搭配 所以可以计算n=3时3 33/ 3*3+6*2=21共3种 12--与1,2搭配 然而为什么前面3种可以与任何其他搭配？ 13--与1,3搭配 为什么是3？ 21--与1,2搭配 这里6种可以2个方案搭配 原因是只要和前一个的方案加 23--与2,3搭配 / 一个重复的颜色的话就可以得到当前的情形 31--与1,3搭配 / 由此可知a[3]=3*a[1]+2*(a[2]-a[1])=2*a[2]+a[1] 32--与2,3搭配/ 与此类推变得 a[n]=2*a[n-1]+a[n-2](n&gt;=3)——————————————————————————————————————————————-—————#include &lt;iostream&gt;using namespace std;int main(){ int a[41],t,n; a[1]=3;a[2]=9; for(int i=3;i&lt;=40;i++) a[i]=2*a[i-1]+a[i-2]; cin&gt;&gt;t; while(t--) { cin&gt;&gt;n; cout&lt;&lt;a[n]&lt;&lt;endl; } return 0;} 2570 迷障 贪心通过悬崖的yifenfei，又面临着幽谷的考验——幽谷周围瘴气弥漫，静的可怕，隐约可见地上堆满了骷髅。由于此处长年不见天日，导致空气中布满了毒素，一旦吸入体内，便会全身溃烂而死。幸好yifenfei早有防备，提前备好了解药材料（各种浓度的万能药水）。现在只需按照配置成不同比例的浓度。现已知yifenfei随身携带有n种浓度的万能药水，体积V都相同，浓度则分别为Pi%。并且知道，针对当时幽谷的瘴气情况，只需选择部分或者全部的万能药水，然后配置出浓度不大于 W%的药水即可解毒。现在的问题是：如何配置此药，能得到最大体积的当前可用的解药呢？特别说明：由于幽谷内设备的限制,只允许把一种已有的药全部混入另一种之中（即：不能出现对一种药只取它的一部分这样的操作）。 Input 输入数据的第一行是一个整数C，表示测试数据的组数；每组测试数据包含2行，首先一行给出三个正整数n,V,W(1&lt;=n,V,W&lt;=100)；接着一行是n个整数，表示n种药水的浓度Pi%(1&lt;=Pi&lt;=100)。 Output 对于每组测试数据，请输出一个整数和一个浮点数；其中整数表示解药的最大体积，浮点数表示解药的浓度(四舍五入保留2位小数)；如果不能配出满足要求的的解药，则请输出0 0.00。 Sample Input 123456731 100 101002 100 2420 303 100 2420 20 30 Sample Output 1230 0.00100 0.20300 0.23 Author yifenfei 123456789101112131415161718192021222324252627282930313233#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;int main(){ int n; while(cin&gt;&gt;n) { while(n--){ int u,v,w;//u-药水数目 v-药水体积 w-药水目标浓度 cin&gt;&gt;u&gt;&gt;v&gt;&gt;w; int current_v=0; float current_w=0.0; int a[105]; float temp; for(int i=0;i&lt;u;i++)cin&gt;&gt;a[i]; sort(a,a+u); for(int i=0;i&lt;u;i++) { temp=((current_w*current_v+v*a[i])/(current_v+v)); if(temp&lt;=w) {current_v+=v;current_w=temp;} else break; } printf(\"%d %.2f\\n\",current_v,current_w/100.0); } } return 0;} 2571 命运 记忆化搜索穿过幽谷意味着离大魔王lemon已经无限接近了！可谁能想到，yifenfei在斩杀了一些虾兵蟹将后，却再次面临命运大迷宫的考验，这是魔王lemon设下的又一个机关。要知道，不论何人，若在迷宫中被困1小时以上，则必死无疑！可怜的yifenfei为了去救MM，义无返顾地跳进了迷宫。让我们一起帮帮执着的他吧！命运大迷宫可以看成是一个两维的方格阵列，如下图所示：yifenfei一开始在左上角，目的当然是到达右下角的大魔王所在地。迷宫的每一个格子都受到幸运女神眷恋或者痛苦魔王的诅咒，所以每个格子都对应一个值，走到那里便自动得到了对应的值。现在规定yifenfei只能向右或者向下走，向下一次只能走一格。但是如果向右走，则每次可以走一格或者走到该行的列数是当前所在列数倍数的格子，即：如果当前格子是（x,y），下一步可以是（x+1,y），(x,y+1)或者(x,y*k) 其中k&gt;1。为了能够最大把握的消灭魔王lemon，yifenfei希望能够在这个命运大迷宫中得到最大的幸运值。 Input 输入数据首先是一个整数C，表示测试数据的组数。每组测试数据的第一行是两个整数n,m，分别表示行数和列数(1&lt;=n&lt;=20,10&lt;=m&lt;=1000)；接着是n行数据，每行包含m个整数，表示n行m列的格子对应的幸运值K ( |k|&lt;100 )。 Output 请对应每组测试数据输出一个整数，表示yifenfei可以得到的最大幸运值。 Sample Input 1234513 89 10 10 10 10 -10 10 1010 -11 -1 0 2 11 10 -20-11 -11 10 11 2 10 -10 -10 Sample Output 152 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263数组从1开始比较方便，否则对于第三个k倍跳跃的情况DFS直接无限递归了……（0的k倍还是0），调试半天发现是从0开始的锅，改为1就行了#include &lt;stdio.h&gt;#include &lt;bits/stdc++.h&gt;using namespace std;#define INF 0x3f3f3f3f#define CLR(arr,val) memset(arr,val,sizeof(arr))const int N=25;const int M=1010;int pos[N][M];int dp[N][M];int vis[N][M];int n,m;void init(){ CLR(vis,0); CLR(dp,0); CLR(pos,0);}bool check(int x,int y){ return (x&gt;=1&amp;&amp;x&lt;=n&amp;&amp;y&gt;=1&amp;&amp;y&lt;=m);}int dfs(int x,int y){ if(vis[x][y]) return dp[x][y]; else { vis[x][y]=1; int pre_max=-INF; if(check(x+1,y))//向右 pre_max=max&lt;int&gt;(pre_max,dfs(x+1,y)); if(check(x,y+1))//向下 pre_max=max&lt;int&gt;(pre_max,dfs(x,y+1)); for (int k=2; y*k&lt;=m; ++k)//向右k(k&gt;1)倍 { int tx=x; int ty=y*k; if(check(tx,ty)) pre_max=max&lt;int&gt;(pre_max,dfs(tx,ty)); } if(pre_max==-INF)//四周找不到了，此时不能用-INF，只能用pos[x][y]因此变相去掉pre_max pre_max=0; return dp[x][y]=pre_max+pos[x][y]; }}int main(void){ int tcase,i,j; scanf(\"%d\",&amp;tcase); while (tcase--) { init(); scanf(\"%d%d\",&amp;n,&amp;m); for (i=1; i&lt;=n; ++i) for (j=1; j&lt;=m; ++j) scanf(\"%d\",&amp;pos[i][j]); dfs(1,1); printf(\"%dn\",dp[1][1]); } return 0;} 2572 终曲 kmp站在yifenfei和MM面前的只剩下邪恶的大魔王lemon一人了！战胜他，yifenfei就能顺利救出MM。Yifenfei和魔王lemon的挑战很简单：由lemon给出三个字符串，然后要yifenfei说出第一串的某个子串，要求该子串长度最小，并且同时包含第2个串和第3个串。特别地，如果有多个这样的子串，则请输出字母序最小的一个。 Input 输入数据首先是一个整数C，表示测试数据有C组；接着是C组数据，每组包含三行字符串，第一个字符串长度大于1小于100后面两个串的长度大于1且小于10 Output 请对应每组输入数据输出满足条件的最短子串；如果没有，请输出 No Sample Input 12345672abcdabbcabcabbd Sample Output 12abcNo 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include &lt;iostream&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;queue&gt;#include&lt;cstdio&gt;using namespace std;typedef long long ll;const ll inf = 0xfffffffff;string s1, s2, ss;int vis[6005], ne[200];void ge(string a){ int j = 0, k = -1; int n = a.size(); memset(ne, 0, sizeof(ne)); ne[0] = -1; while (j &lt; n) { if (k == -1 || a[j] == a[k]) ne[++j] = ++k; else k = ne[k]; }}int kmp(string a, string b){ int j = 0, i = 0; ge(b); int m = a.size(); int n = b.size(); while (i &lt; m&amp;&amp;j &lt; n) { if (j == -1||b[j] == a[i] ) i++, j++; else j = ne[j]; } if (j == n) return 1; else return 0;}int main(){ ios::sync_with_stdio(false); int t; string s,cs; while (cin &gt;&gt; t) { while (t--) { int sg, fg = 0; cin &gt;&gt; ss &gt;&gt; s1 &gt;&gt; s2; int n = ss.size(); cs = ss; for (int i = 0; i &lt;n; i++) { for (int j = i; j &lt; n; j++) { s = ss.substr(i, j - i + 1);//枚举所有的字串 if (kmp(s, s1) &amp;&amp; kmp(s, s2)) { if (s.length() &lt; cs.length()) { cs = s; fg = 1; }//选个最短的 else if (s.length() == cs.length()) { cs = min(cs, s); fg = 1; }//如果一样短，比较字典序。 } } } if (!fg) cout &lt;&lt; \"No\" &lt;&lt; endl; else cout &lt;&lt; cs &lt;&lt; endl; } } return 0;} 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#define LOCAL#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cctype&gt;#include &lt;sstream&gt;#include &lt;vector&gt;using namespace std;int main(){ #ifdef LOCAL freopen(\"input.txt\",\"r\",stdin); freopen(\"output.txt\",\"w\",stdout); #endif int n;cin&gt;&gt;n;getchar(); string str,sub1,sub2; while(n--){ vector&lt; pair&lt;int,int&gt; &gt; V1; vector&lt; pair&lt;int,int&gt; &gt; V2; getline(cin,str);getline(cin,sub1);getline(cin,sub2); int i=0; while(1){ i = str.find(sub1,i); if(i==-1) break; pair&lt;int,int&gt; tmp(i,i+sub1.size()-1); V1.push_back(tmp); i++; } i=0; while(1){ i = str.find(sub2,i); if(i==-1) break; pair&lt;int,int&gt; tmp(i,i+sub2.size()-1); V2.push_back(tmp); i++; } if(V1.size()==0 || V2.size()==0){cout&lt;&lt;\"No\"&lt;&lt;endl;continue;} int MIN = str.size(); int ans[2]; for(i=0;i&lt;V1.size();i++){ int l1 = V1[i].first; int r1 = V1[i].second; for(int j=0;j&lt;V2.size();j++){ int l2 = V2[j].first; int r2 = V2[j].second; int l = min(l1,l2); int r = max(r1,r2); int len = r-l+1; if(len&lt;MIN){ MIN = len; ans[0] = l; ans[1] = r; }else if(len == MIN){ if(str.substr(l,len) &lt; str.substr(ans[0],ans[1]-ans[0]+1)){ ans[0] = l; ans[1] = r; } } } } cout&lt;&lt;str.substr(ans[0],ans[1]-ans[0]+1)&lt;&lt;endl; } return 0;} 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;stdio.h&gt;#include&lt;string.h&gt;int main(){ char str[200],str1[200],str2[200],str4[200],str3[200]; int i,j,n,m,t,t1,j1; while(~scanf(\"%d\",&amp;m)) { while(m--) { scanf(\"%s%s%s\",&amp;str,&amp;str1,&amp;str2); n=strlen(str); t1=0; if(strstr(str,str1)==NULL||strstr(str,str2)==NULL) printf(\"No\\n\"); else { for(i=0;i&lt;n;++i) { for(j=n-1;j&gt;=i;--j) { for(j1=i;j1&lt;=j;++j1) { str3[j1-i]=str[j1]; } str3[j1-i]='\\0'; if(strstr(str3,str1)!=NULL&amp;&amp;strstr(str3,str2)!=NULL) { if(t1==0) { strcpy(str4,str3); t1++; } else { if(strlen(str3)&lt;strlen(str4)||strlen(str3)==strlen(str4)&amp;&amp;strcmp(str3,str4)&lt;0) { strcpy(str4,str3); } } } } } printf(\"%s\\n\",str4); } } } return 0; } 约数定理设d(x)d(x)为xx的约数个数，给定NN、MM，求 ∑Ni=1∑Mj=1d(ij)∑i=1N∑j=1Md(ij)输入输出格式输入格式：输入文件包含多组测试数据。第一行，一个整数T，表示测试数据的组数。接下来的T行，每行两个整数N、M。 输出格式：T行，每行一个整数，表示你所求的答案。 输入输出样例输入样例#1： 27 45 6 输出样例#1： 110121 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;iostream&gt;#define N 50010using namespace std;typedef long long LL;int T, n, m;LL g[N], Ans;int prime[N], miu[N], cnt;bool vis[N];void Get_miu(){ for(int i = 1; i &lt; N; i++){ int last; for(int j = 1; j &lt;= i; j = last+1){ last = i/(i/j); g[i] += (LL)(i/j)*(LL)(last-j+1); } } vis[1] = true; miu[1] = 1; for(int i = 2; i &lt; N; i++){ if(!vis[i]){ prime[++cnt] = i; miu[i] = -1; } for(int j = 1; j &lt;= cnt &amp;&amp; i * prime[j] &lt; N; j++){ vis[i * prime[j]] = true; if(i % prime[j] == 0){ miu[i * prime[j]] = 0; break; } else miu[i * prime[j]] = -miu[i]; } } for(int i = 1; i &lt; N; i++) miu[i] += miu[i-1];}int main(){ Get_miu(); scanf(\"%d\", &amp;T); while(T --){ scanf(\"%d%d\", &amp;n, &amp;m); if(n &gt; m) swap(n, m); Ans = 0; int last; for(int i = 1; i &lt;= n; i = last+1){ last = min(n/(n/i), m/(m/i)); Ans += (LL)(miu[last] - miu[i-1]) * g[n/i] * g[m/i]; } printf(\"%lld\\n\", Ans); } return 0;} 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;bits/stdc++.h&gt;#define ll long longusing namespace std;const int MAX=5e4;ll mu[MAX+10],sum[MAX+10];int prime[MAX+10];bool p[MAX+10];int T,n,m,k,len;void init(){ mu[1]=1; for (int i=2;i&lt;=MAX;i++) { if (!p[i]) { prime[++len]=i; mu[i]=-1; } for (int j=1;j&lt;=len&amp;&amp;prime[j]*i&lt;=MAX;j++) { p[prime[j]*i]=1; if (i%prime[j]==0) { mu[prime[j]*i]=0; break; } mu[prime[j]*i]=-mu[i]; } } for (int i=1;i&lt;=MAX;i++) mu[i]+=mu[i-1]; for (int i=1;i&lt;=MAX;i++) { for (int j=1;j&lt;=i;j=k+1){ k=i/(i/j); sum[i]+=(k-j+1)*(i/j); } } }ll solve(int n,int m){ ll ans=0; for (int i=1;i&lt;=min(n,m);i=k+1) { k=min(n/(n/i),m/(m/i)); ans+=sum[n/i]*sum[m/i]*(mu[k]-mu[i-1]); } return ans;}int main(){ scanf(\"%d\",&amp;T); init(); while (T--){ scanf(\"%d%d\",&amp;n,&amp;m); cout &lt;&lt; solve(n,m) &lt;&lt; endl; }} hdoj 1492这里先讲一下约数个数定理： 对于正整数x，将其质因分解为 x = pow(p1, a) * pow*(p2, b) * pow(p3, c) * … 则其约数个数为：num(x) = (a+1) * (b+1) * (c+1) *… 推导： 由约数定义可知p1^a1的约数有:p1^0, p1^1, p1^2……p1^a1 ，共（a1+1）个;同理p2^a2的约数有（a2+1）个……pk^ak的约数有（ak+1）个。 故根据乘法原理：n的约数的个数就是(a1+1)(a2+1)(a3+1)…(ak+1)。 那么这道题直接代这个公式好啦～ 题意： 给出一个64bit的数，求它的约数的个数； 1234567891011121314151617181920#include &lt;iostream&gt;#include &lt;stdio.h&gt;#define ll long longusing namespace std;int main(void){ ll n; while(scanf(\"%lld\", &amp;n)&amp;&amp;n){ int a[4]={1, 1, 1, 1}; int b[4]={2, 3, 5, 7}; for(int i=0; i&lt;4; i++){ while(n%b[i]==0){ a[i]++; n/=b[i]; } } printf(\"%d\\n\", a[0]*a[1]*a[2]*a[3]); } return 0;}","link":"/2019/12/24/ACM程序设计期末考试/"},{"title":"","text":"汕头大学 ACM 模板目录[TOC] 动态规划背包问题状态：从前 n 个背包中组成重量为 m 的…… 01背包$O(VN)$ 滚动数组，从右往左。 完全背包$O(VN)$ 滚动数组，从左往右。 多重背包$O(V\\sum \\log M_i)$ 每种物品分解成多个01背包中的物品，每个物品个数分别为1、2、4……个。 可行性多重背包$O(VN)$ 状态：用了前$i$种物品填满容量为$j$的背包后，最多还剩下几个第$i$种物品可用。$$dp\\left[i\\right]\\left[j\\right]=\\begin{cases}M\\left[i\\right], &amp; \\text{if $dp\\left[i-1\\right]\\left[j\\right]\\geq 0$}\\[2ex]\\max { dp\\left[i\\right]\\left[j - C\\left[i\\right]\\right] - 1} (C\\left[i\\right] \\leq j \\leq V), &amp; \\text{if $dp\\left[i-1\\right]\\left[j\\right]\\lt 0$}\\end{cases}$$ 123456789101112131415161718// HDU 2844int n, m;while (cin &gt;&gt; n &gt;&gt; m &amp;&amp; n) { for (int i = 1; i &lt;= n; ++i) cin &gt;&gt; a[i]; for (int i = 1; i &lt;= n; ++i) cin &gt;&gt; c[i]; memset(dp, -1, sizeof(dp)); dp[0] = 0; for (int i = 1; i &lt;= n; ++i) { for (int j = 0; j &lt;= m; ++j) { if (dp[j] &gt;= 0) dp[j] = c[i]; else if (j &gt;= a[i]) dp[j] = max(dp[j], dp[j - a[i]] - 1); } } int ans = 0; for (int i = 1; i &lt;= m; ++i) if (dp[i] &gt;= 0) ++ans; cout &lt;&lt; ans &lt;&lt; '\\n';} LIS$dp[i]$表示长度为$i+1$的上升子序列中末尾元素的最小值，$len$表示当前最长上升子序列的长度； 遍历数组，对于每一个元素，把它替换成尽量长的最长子序列的最后一个元素。 $O(n \\log n)$ 12345678910int n;cin &gt;&gt; n;dp[len++] = INF;for (int i = 0; i &lt; n; ++i) { cin &gt;&gt; arr[i]; int pos = lower_bound(dp, dp + len, arr[i]) - dp; dp[pos] = arr[i]; if (pos == len) ++len;}cout &lt;&lt; len &lt;&lt; '\\n'; 技巧 某些 dp 的状态可看作分层图，此时转移可用邻接矩阵，并使用矩阵快速幂进行状态转移。（在无权图中，设$A$为图的邻接矩阵，$A^n$为矩阵的 n 次幂，则$A^n$中的元素$(i, j)$表示顶点 i 到顶点 j 的长度为 n 的路径数） 数学数值分析大数运算12345678910111213141516171819202122232425262728293031323334353637import java.util.Scanner;import java.math.*; public class Main{ public static void main(String args[]){ Scanner cin = new Scanner(System.in); //使用Sacnner类创建cin对象 BigInteger a, b;//创建大数对象 while(cin.hasNext()){ a = cin.nextBigInteger(); b = cin.nextBigInteger(); System.out.println(\"a+b=\" + a.add(b)); System.out.println(\"a-b=\" + a.subtract(b)); System.out.println(\"a*b=\" + a.multiply(b)); System.out.println(\"a/b=\" + a.divide(b)); System.out.println(\"a%b=\" + a.remainder(b)); if(a.compareTo(b) == 0) //比较两数的大小 System.out.println(\"a==b\"); else if(a.compareTo(b) &gt; 0) System.out.println(\"a&gt;b\"); else System.out.println(\"a&lt;b\"); System.out.println(a.abs());//取绝对值 int e = 10; System.out.println(a.pow(e));//求a^e System.out.println(a.toString()); //将大数a转字符串输出 int p = 8; System.out.println(a.toString(p)); //将大数a转换成p进制后 按字符串输出 } }} 平方根占坑（ 矩阵1234567891011121314151617181920212223242526272829303132333435363738struct matrix { typedef LL ele_type; int r, c; vector&lt;vector&lt;ele_type&gt;&gt; ma; matrix(int r, int c): r(r), c(c), ma(r, vector&lt;ele_type&gt;(c)) {} matrix(matrix &amp;&amp;rhs) noexcept : r(rhs.r), c(rhs.c) { ma = move(rhs.ma); } matrix(const matrix &amp;rhs) = default; matrix&amp; operator= (matrix &amp;&amp;rhs) noexcept { if (this != &amp;rhs) { r = rhs.r; c = rhs.c; ma = move(rhs.ma); } return *this; } matrix operator* (const matrix &amp;rhs) const { matrix res(r, rhs.c); for (int i = 0; i &lt; r; ++i) { for (int j = 0; j &lt; c; ++j) { for (int k = 0; k &lt; rhs.c; ++k) { res.ma[i][k] += ma[i][j] * rhs.ma[j][k]; res.ma[i][k] %= MOD;// if (res.ma[i][k] &gt;= MOD2) res.ma[i][k] -= MOD2; // MOD2 == MOD * MOD } } } return res; } void setUnit() { for (int i = 0; i &lt; r; ++i) ma[i][i] = 1; }}; 快速傅里叶变换$O(n\\log n)$ 1234567891011121314151617181920212223242526complex&lt;double&gt; a[N &lt;&lt; 1];complex&lt;double&gt; b[N &lt;&lt; 1];void init_pos(complex&lt;double&gt; *a, int n) { // 逆向加法 for (int i = 0, j = 0; i != n; i++) { if (i &gt; j) swap(a[i], a[j]); for (int l = n &gt;&gt; 1; (j ^= l) &lt; l; l &gt;&gt;= 1); }}void FFT(int I, complex&lt;double&gt; *a, int n) { // 傅里叶变换(I==1) or 插值 init_pos(a, n); for (int i = 2, mid = 1; i &lt;= n; i &lt;&lt;= 1, mid &lt;&lt;= 1) { complex&lt;double&gt; wn(cos(2.0 * PI / i), sin(I * 2.0 * PI / i)); for (int j = 0; j &lt; n; j += i) { complex&lt;double&gt; w(1, 0); for (int k = j; k &lt; j + mid; k++, w = w * wn) { complex&lt;double&gt; l = a[k], r = w * a[k + mid]; a[k] = l + r; a[k + mid] = l - r; } } } if (I == 1) return; for (int i = 0; i &lt; n; i++) { a[i] /= n; }} 数论一些性质 (a - b) % k == 0 &lt;=&gt; a % k == b % k a % b &lt; a / 2 (a &gt;= b) 完全平方数有奇数个约数。1到n中有 $\\lfloor \\sqrt n \\rfloor$ 个完全平方数。 有 n 位的数的平方根有 $\\lceil \\frac n 2 \\rceil$ 位。 GCD &amp; LCM$O(\\log \\max (a, b))$ 12345678910111213inline int gcd(int a, int b) { int tmp; while (b != 0) { tmp = b; b = a % b; a = tmp; } return a;}inline int lcm(int a, int b) { return a / gcd(a, b) * b;} Extened GCD$O(\\log \\max(a, b))$ 12345678910111213141516171819// solve ax + by = gcd(a, b)int extgcd(int a, int b, int &amp;x, int &amp;y) { // return gcd(a, b) int d = a; if (b != 0) { d = extgcd(b, a % b, y, x); y -= (a / b) * x; } else { x = 1; y = 0; } return d;}// get inverse number of a modulo mint mod_inv(int a, int m) { int x, k; extgcd(a, m, x, k); return (x % m + m) % m;} 素数筛法$O(n\\log \\log n)$ 12345678910// Eratosthenes筛法int C[N]; // 若是素数则为0，否则为该数的最大素因子void sieve(int size) { for (int i = 2; i * i &lt; size; i++) { if (!C[i]) { for (int j = i * 2; j &lt; size; j += i) C[j] = i; } }} $O(n)$ 123456789101112// Euler筛法int C[N]; // 该数的最小质因数int prime[N], pn; // 素数表void sieve(int size) { for (int i = 2; i &lt; size; ++i) { // if (!C[i]) C[i] = prime[pn++] = i; for (int j = 0; i * prime[j] &lt; size; ++j) { C[i * prime[j]] = prime[j]; if (i % prime[j] == 0) break; // smallest prime factor of i is prime[j], so we need break } }} 欧拉函数欧拉函数 $\\phi(n)$ 定义为：$1 \\leq k \\leq n $ ，并且 $k$ 与 $n$ 互质的 $k$ 的个数。 1234567891011121314151617181920212223// use linear sieve to compute phi(x) for all x up to nint phi[N];int C[N];int p[N], pn;void getPhi(int n) { phi[1] = 1; for (int i = 2; i &lt; n; ++i) { if (!C[i]) { p[pn++] = i; phi[i] = i - 1; // ① i is prime } for (int j = 0; i * p[j] &lt; n; ++j) { C[i * p[j]] = p[j]; if (i % p[j] == 0) { phi[i * p[j]] = phi[i] * p[j]; // ② phi(ip) = phi(i) * p, if p divides i break; // smallest prime factor of i is p[j], so we need break } else { phi[i * p[j]] = phi[i] * phi[p[j]]; // ③ p does not divides i, i.e. they are co-prime, so phi(ip) = phi(i) * phi(p) due to phi is a multiplicative function } } }} 快速幂mul： $O(1)$ quickPow：$O(\\log n)$ 123456789101112131415161718LL mul(LL a, LL b, LL mod) { // 带模乘法 if (mod &lt;= 2000000000) return a * b % mod; LL d = llround((long double)a * b / mod); LL ans = a * b - d * mod; if (ans &lt; 0) ans += mod; return ans;}// 求a在模MOD下的逆元 | 费马小定理 | inv(a, MOD - 2, MOD)LL quickPow(LL a, LL n, LL mod) { // 带模快速幂 LL ans = 1; while (n) { if (n &amp; 1) ans = mul(ans, a, mod); a = mul(a, a, mod); n &gt;&gt;= 1; } return ans;} 素性检测$O(\\sqrt n)$ 1234567// 试除法bool isprime(int n) { for (int i = 2; i * i &lt;= n; ++i) { if (n % i == 0) return false; } return true;} $O(\\log n)$ 1234567891011121314151617181920212223242526272829303132// Miller-Rabin 素性检测bool isprime(LL n, int S = 7) { if (n == 2) return true; if (n &lt; 2 || n % 2 == 0) return false; LL u = n - 1, t = 0; while (u % 2 == 0) { u &gt;&gt;= 1; ++t; } const int SPRP[7] = {2, 325, 9375, 28178, 450775, 9780504, 1795265022}; // cover all numbers &lt; 2^64 for (int k = 0; k &lt; S; ++k) { LL a = SPRP[k] % n; if (a == 0 || a == 1 || a == n - 1) continue; LL x = qpow(a, u, n); // 带模快速幂 if (x == 1 || x == n - 1) continue; for (int i = 0; i &lt; t - 1; ++i) { x = mul(x, x, n); // 带模乘法 if (x == 1) return false; if (x == n - 1) break; } if (x == n - 1) continue; return false; } return true;} 质因数分解$O(\\sqrt n)$ 123456789101112// 直接小除到大vector&lt;int&gt; p; // 存放分解的质因数void factorize(int n) { for (int i = 2; i * i &lt;= n; ++i) { while (n % i == 0) { p.push_back(i); n /= i; } if (n == 1) return; } if (n &gt; 1) p.push_back(n);} $O(\\log n)$ 123456789101112// 预处理出各数的最小质因数，然后按最小质因数除int C[N]; // 最小质因数，可用欧拉筛获得vector&lt;int&gt; p;void factorize(int n) { for (int t = n; t &gt; 1; ) { int x = C[t]; // t的最小质因数 while (C[t] == x) { p.push_back(x); t /= C[t]; } }} Pollard’s ρ：$O(n^ \\frac 1 4)$（大约） factorize：$O(玄学)$ 123456789101112131415161718192021222324252627282930313233343536// Pollard's ρ 算法 POJ 1811inline LL g(LL x, int c, LL mod) { // （伪）随机数生成 return (mul(x, x, mod) + c) % mod; }LL pollard_rho(LL n, int c) { LL x = 2, y = 2, i = 1, k = 2; while (true) { x = g(x, c, n); // if (x == y) return n; LL d = __gcd(llabs(x - y), n); if (d &gt; 1 &amp;&amp; d &lt;= n) return d; if (++i == k) { y = x; k &lt;&lt;= 1; } }}vector&lt;LL&gt; factor; // 刚执行完后是无序的void factorize(LL n) { // 能够承受10000个数左右的分解（？） if (n == 1) return; if (isprime(n)) { factor.push_back(n); return; } LL d = n; for (int c = 1; d == n; ++c) { d = pollard_rho(n, c); } factorize(d); factorize(n / d);} 反素数对于任何正整数$x$，其约数的个数记作$g(x)$。例如$g(1)=1$、$g(6)=4$。 如果某个正整数$x$满足：$g(x)&gt;g(i) (0&lt;i&lt;x)$，则称$x$为反质数。 性质一：一个反素数的质因子必然是从2开始连续的质数 性质二：分解过后的形式（如 $p = 2^{t_1} * 3^{t_2} * 5^{t_3} * \\cdots$ ），必然有 $t1 \\geq t2 \\geq t3 \\geq \\cdots$ 1int anti_prime[] = {1396755360,1102701600,735134400,698377680,551350800,367567200,294053760,245044800,183783600,147026880,122522400,110270160,73513440,61261200,43243200,36756720,32432400,21621600,17297280,14414400,10810800,8648640,7207200,6486480,4324320,3603600,2882880,2162160,1441440,1081080,720720,665280,554400,498960,332640,277200,221760,166320,110880,83160,55440,50400,45360,27720,25200,20160,15120,10080,7560,5040,2520,1680,1260,840,720,360,240,180,120,60,48,36,24,12,6,4,2,1,0}; 图论一些性质 先从任意一个节点u开始深搜找到一个最远点v，再从v深搜找到最远点w，则v-&gt;w就是树的直径。 握手定理：任何一个无向图都有偶数个度数为奇数的顶点。 拓扑排序$O(V+E)$ 1234567891011121314151617181920212223242526// dfs版拓扑排序，可判断是否为有向无环图，若不是则返回 falsevector&lt;int&gt; topo; // 拓扑序的倒序bool dfs(int u) { vis[u] = -1; // -1为正在处理的节点，0为未处理的节点，1为已经处理完的节点 for (int v = 1; v &lt;= n; ++v) { // 对于每一个u的后继v if (g[u][v]) { if (vis[v] &lt; 0) return false; if (!vis[v] &amp;&amp; !dfs(v)) return false; // 若v没被处理并且v中发现环，则停止深搜，返回false // 若v是已被处理完的节点，则忽略 } } vis[u] = 1; topo.push_back(u); return true;}bool toposort() { memset(vis, 0, sizeof(vis)); topo.clear(); for (int u = 1; u &lt;= n; ++u) { if (!vis[u]) { if (!dfs(u)) return false; } } return true;} 123456789101112131415161718// bfs版拓扑排序，会遍历所有*不在*环中的节点void toposort() { // 无向图版 queue&lt;int&gt; q; for (int i = 1; i &lt;= n; ++i) { if (degree[i] == 1) q.push(i); } while (!q.empty()) { int u = q.front(); q.pop(); // operation here for (int i = 0; i &lt; g[u].size(); ++i) { int v = g[u][i]; if (--degree[v] == 1) { // 具体操作 q.push(v); } } }} 最短路Bellman-Ford (SPFA)$O(VE)$（对于大部分图 SPFA 还是很快的） 12345678910111213141516171819202122232425// 单纯判环 UVA 11090double d[N];bool vis[N];bool SPFA(int u) { if (vis[u]) return true; vis[u] = true; for (int i = g[u]; ~i; i = es[i].next) { double tmp = d[u] + es[i].v; if (tmp &lt; d[es[i].b]) { d[es[i].b] = tmp; if (SPFA(es[i].b)) return true; } } vis[u] = false; return false;}bool detect() { for (int i = 1; i &lt;= n; ++i) { vis[i] = false; d[i] = 0; } for (int i = 1; i &lt;= n; ++i) if (SPFA(i)) return true; return false;} 12345678910111213141516171819202122232425262728293031// 求最短路并判环double d[N]; // 最短路长度int L[N]; // 源点到各个节点的最短路的边数bool inq[N];bool SPFA(int s) { // true表示无环，false表示有环 memset(d, 0x3f, sizeof(d)); memset(inq, 0, sizeof(inq)); memset(L, 0, sizeof(L)); queue&lt;int&gt; q; d[s] = 0; q.push(s); while (!q.empty()) { int u = q.front(); q.pop(); inq[u] = false; for (int i = g[u]; ~i; i = es[i].next) { int v = es[i].b; double val = es[i].v; double tmp = d[u] + val; if (tmp &lt; d[v]) { L[v] = L[u] + 1; if (L[v] &gt;= n) return false; // 最短路长度大于等于顶点数即有环 d[v] = tmp; if (!inq[v]) { q.push(v); inq[v] = true; } } } } return true;} Dijkstra$O(E\\log E)$ 12345678910111213141516171819202122int d[N];bool vis[N];void dijkstra(int s) { memset(d, 0x3f, sizeof(d)); memset(vis, 0, sizeof(vis)); priority_queue&lt;pair&lt;int, int&gt;&gt; q; d[s] = 0; q.push({0, s}); while (!q.empty()) { int u = q.top().second; q.pop(); if (vis[u]) continue; vis[u] = true; for (auto &amp;e : g[u]) { int v = e.first, w = e.second; int tmp = d[u] + w; if (tmp &lt; d[v]) { d[v] = tmp; q.push({-tmp, v}); } } }} Floyd$O(V^3)$ 12345678910111213141516int d[N][N];int g[N][N];for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= n; j++) { if (i == j) d[i][j] = 0; else if (g[i][j]) d[i][j] = g[i][j]; else d[i][j] = INF; }}for (int k = 1; k &lt;= n; ++k) { for (int i = 1; i &lt;= n; ++i) { for (int j = 1; j &lt;= n; ++j) { d[i][j] = min(d[i][j], d[i][k] + d[k][j]); } }} K短路$O(玄学)$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475// POJ 2449#include &lt;bits/stdc++.h&gt;using namespace std;const int INF = 0x3f3f3f3f;const double EPS = 1e-8;//const double PI = acos(-1.0);//const int MOD = 1000000007;typedef long long LL;typedef unsigned long long uLL;const int N = 1000+10;int S, T, K;vector&lt;pair&lt;int, int&gt; &gt; g[N];vector&lt;pair&lt;int, int&gt; &gt; rev[N]; // 将所有边反向的逆图int h[N];int cnt[N]; // 每个节点的访问次数bool vis[N];void dij() { // 求出最优的h，即每个节点到终点的最短路长度 memset(h, 0x3f, sizeof(h)); priority_queue&lt;pair&lt;int, int&gt; &gt; q; h[T] = 0; q.push({0, T}); while (!q.empty()) { int u = q.top().second; q.pop(); if (vis[u]) continue; vis[u] = true; for (int i = 0; i &lt; rev[u].size(); ++i) { int tmp = h[u] + rev[u][i].second; if (tmp &lt; h[rev[u][i].first]) { h[rev[u][i].first] = tmp; q.push({-tmp, rev[u][i].first}); } } }}int astar() { priority_queue&lt;pair&lt;int, int&gt; &gt; q; q.push({-h[S], S}); while (!q.empty()) { int u = q.top().second, val = -q.top().first; q.pop(); if (++cnt[u] == K &amp;&amp; u == T) return val; // 访问K次即K短路 if (cnt[u] &gt; K) continue; for (int i = 0; i &lt; g[u].size(); ++i) { int v = g[u][i].first, t = g[u][i].second; if (cnt[v] &lt; K) { q.push({-val + h[u] - t - h[v], v}); } } } return -1;}int main() { ios::sync_with_stdio(false); cin.tie(0); int n, m; scanf(\"%d%d\", &amp;n, &amp;m); while (m--) { int a, b, t; scanf(\"%d%d%d\", &amp;a, &amp;b, &amp;t); g[a].push_back({b, t}); rev[b].push_back({a, t}); } scanf(\"%d%d%d\", &amp;S, &amp;T, &amp;K); if (S == T) ++K; dij(); printf(\"%d\\n\", astar()); return 0;} 生成树Kruskal对边排序然后贪心 $O(E\\log E)$ Prim和Dijkstra相似 $O(E\\log E)$ 次小生成树$O(E\\log E+V^2)$ or $O(E\\log E+V\\log V)$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110// POJ 1679#include &lt;bits/stdc++.h&gt;using namespace std;const int INF = 0x3f3f3f3f;const double EPS = 1e-8;// const double PI = acos(-1.0);// const int MOD = 1000000007;typedef long long LL;typedef unsigned long long uLL;const int N = 100 + 10;const int M = 2000000 + 10;int n, m;struct edge { int a, b, w; bool operator&lt;(const edge &amp;r) const { return w &lt; r.w; }};vector&lt;edge&gt; es;int fa[N];int find(int u) { return (fa[u] &lt; 0 ? u : (fa[u] = find(fa[u]))); }vector&lt;pair&lt;int, int&gt; &gt; spt[N]; // 最小生成树vector&lt;int&gt; candi; // 次小生成树的候选边（即不在最小生成树中的边）void setUnion(int a, int b) { int r1 = find(a), r2 = find(b); if (r1 == r2) return; if (fa[r1] &lt; fa[r2]) { fa[r2] = r1; return; } if (fa[r1] == fa[r2]) --fa[r2]; fa[r1] = r2;}int kruskal() { memset(fa, -1, sizeof(fa)); candi.clear(); sort(es.begin(), es.end()); int ans = 0; for (int i = 0; i &lt; es.size(); ++i) { edge &amp;e = es[i]; if (find(e.a) != find(e.b)) { setUnion(e.a, e.b); spt[e.a].push_back({e.b, e.w}); spt[e.b].push_back({e.a, e.w}); ans += e.w; } else { candi.push_back(i); } } return ans;}int F[N][N]; // 最小生成树中任意两点路径中最大边权bool vis[N];void dfs(int u, int fa, int ans, int a) { for (int i = 0; i &lt; spt[u].size(); ++i) { int v = spt[u][i].first; if (v != fa) { dfs(v, u, F[a][v] = max(ans, spt[u][i].second), a); } }}void pre() { // 求出F，可利用LCA与区间查询将复杂度将为O(nlogn) for (int i = 1; i &lt;= n; ++i) dfs(i, -1, -1, i);}void addedge(int u, int v, int w) { es.push_back({u, v, w}); }int solve(int ori) { int ans = INF; for (int i = 0; i &lt; candi.size(); ++i) { // 枚举每条候选边 edge &amp;e = es[candi[i]]; ans = min(ori - F[e.a][e.b] + e.w, ans); // 将它与F[e.a][e.b]的边替换 } return ans;}int main() { ios::sync_with_stdio(false); cin.tie(0); int T; scanf(\"%d\", &amp;T); while (T--) { scanf(\"%d%d\", &amp;n, &amp;m); es.clear(); for (int i = 1; i &lt;= n; ++i) spt[i].clear(); for (int i = 0; i &lt; m; ++i) { int u, v, w; scanf(\"%d%d%d\", &amp;u, &amp;v, &amp;w); addedge(u, v, w); } int ans = kruskal(); pre(); int tmp = solve(ans); if (tmp == ans) // 若次小生成树权值与最小生成树相同 printf(\"Not Unique!\\n\"); else printf(\"%d\\n\", ans); } return 0;} $O(E\\log E)$ 123456789101112131415161718192021222324252627// codeforces contest 1108 F// improved kruskal// return the number of alternative edges of MSTint kruskal() { int ret = 0; memset(fa, -1, sizeof(fa)); sort(es.begin(), es.end()); map&lt;int, set&lt;pii&gt;&gt; mp; int cnt = 0; for (int i = 0; i &lt; es.size(); ++i) { auto &amp;e = es[i]; if (i + 1 == es.size() || es[i + 1].w != e.w) { for (int j = i; j &gt;= 0 &amp;&amp; es[j].w == e.w; --j) { if (find(es[j].u) != find(es[j].v)) ++cnt; } for (int j = i; j &gt;= 0 &amp;&amp; es[j].w == e.w; --j) { if (find(es[j].u) != find(es[j].v)) { unite(find(es[j].u), find(es[j].v)); --cnt; } } ret += cnt; cnt = 0; } } return ret;} 网络流Edmonds-Karp$O(VE^2)$ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// UVA 820struct edge { int a, b, cap;};vector&lt;edge&gt; es;vector&lt;int&gt; g[N];int p[N]; // 每次增广的路径记录int flows[N]; // 记录每次增广流大小顺便用于bfs（inline void addedge(int a, int b, int cap) { es.push_back({a, b, cap}); es.push_back({b, a, 0}); int i = es.size(); g[a].push_back(i - 2); g[b].push_back(i - 1);}int bfs(int s, int d) { memset(flows, 0, sizeof(flows)); queue&lt;int&gt; q; q.push(s); flows[s] = INF; while (!q.empty()) { int u = q.front(); q.pop(); for (int ee = 0; ee &lt; g[u].size(); ++ee) { const int &amp;e = g[u][ee]; const edge &amp;eg = es[e]; if (!flows[eg.b] &amp;&amp; eg.cap &gt; 0) { flows[eg.b] = min(flows[u], eg.cap); p[eg.b] = e; // 记录此次增广的路径，用于更新 if (eg.b == d) return flows[d]; q.push(eg.b); } } } return flows[d];}int ekalgo(int s, int d) { int maxflow = 0; while (true) { if (!bfs(s, d)) break; for (int u = d; u != s; u = es[p[u]].a) { es[p[u]].cap -= flows[d]; es[p[u]^1].cap += flows[d]; } maxflow += flows[d]; } return maxflow;} Scaling$O(E^2\\log c)$ (c is the initial threshold) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// UVA 820struct edge { int a, b, cap;};vector&lt;edge&gt; es;vector&lt;int&gt; g[N];int p[N]; // 用于dfs的标识数组inline void addedge(int a, int b, int cap) { es.push_back({a, b, cap}); es.push_back({b, a, 0}); int i = es.size(); g[a].push_back(i - 2); g[b].push_back(i - 1);}int dfs(int u, int f) { // 每次只增广大小大于等于阈值的流，若无则返回0 if (u == d) { return f; } p[u] = 1; for (auto ee : g[u]) { edge &amp;e = es[ee]; if (!p[e.b] &amp;&amp; e.cap &gt;= thre) { int flow = dfs(e.b, min(f, e.cap)); if (flow &gt;= thre) { e.cap -= flow; es[ee^1].cap += flow; return flow; } } } return 0;}int scal() { int maxflow = 0; thre = 1000; // 阈值 while (thre) { while (true) { memset(p, 0, sizeof(p)); int flow = dfs(s, INF); if (!flow) break; maxflow += flow; } thre &gt;&gt;= 1; } return maxflow;} Dinic$O(V^2E)$ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647int d[N];bool bfs() { memset(d, -1, sizeof(d)); queue&lt;int&gt; q; q.push(0); d[0] = 0; while (!q.empty()) { int u = q.front(); q.pop(); for (int v = 1; v &lt;= n; ++v) { if (d[v] &lt; 0 &amp;&amp; g[u][v] &gt; 0) { d[v] = d[u] + 1; q.push(v); } } } return d[n] &gt;= 0;}bool vis[N];int dfs(int u, int f) { if (u == n) return f; int ans = 0; vis[u] = true; for (int v = 1; v &lt;= n; ++v) { if (!vis[v] &amp;&amp; d[v] == d[u] + 1 &amp;&amp; g[u][v] &gt; 0) { int flow = dfs(v, min(f, g[u][v])); if (flow &gt; 0) { g[u][v] -= flow; g[v][u] += flow; ans += flow; f -= flow; if (f &lt;= 0) break; } } } return ans;}int dinic() { int ans = 0; while (bfs()) { int flow; while (memset(vis, 0, sizeof(vis)), flow = dfs(0, INF)) ans += flow; // O(EV) } return ans;} 上下界可行流建一个特殊的图然后跑网络流（具体参见“图论总结 by amber.pdf”） 连通分量强连通分量（Kosaraju）$O(V+E)$ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465// POJ 2186：分解强连通分量，如果图中任何一个点都能到最后一个连通分量，则输出最后一个连通分量所含节点数int n, m;vector&lt;int&gt; g[N];vector&lt;int&gt; rev[N];bool vis[N];int s[N], stop; // 第一次dfs得到的dfs序列int ord[N]; // 节点所在强连通分量的拓扑序void dfs1(int u) { vis[u] = true; for (int i = 0; i &lt; g[u].size(); ++i) { if (!vis[g[u][i]]) dfs1(g[u][i]); } s[stop++] = u;}void dfs2(int u, int k) { ord[u] = k; for (int i = 0; i &lt; rev[u].size(); ++i) { if (!ord[rev[u][i]]) dfs2(rev[u][i], k); }}int cnt;void check(int u) { vis[u] = true; ++cnt; for (int i = 0; i &lt; rev[u].size(); ++i) { if (!vis[rev[u][i]]) check(rev[u][i]); }}int main() { ios::sync_with_stdio(false); cin.tie(0); scanf(\"%d%d\", &amp;n, &amp;m); while (m--) { int a, b; scanf(\"%d%d\", &amp;a, &amp;b); g[a].push_back(b); rev[b].push_back(a); } for (int i = 1; i &lt;= n; ++i) if (!vis[i]) dfs1(i); int k = 0; while (stop &gt; 0) { // Kosaraju here int u = s[--stop]; if (ord[u]) continue; dfs2(u, ++k); // 按栈中的顺序处理结点得到的是拓扑序 } int ans = 0; int u = 0; for (int i = 1; i &lt;= n; ++i) { if (ord[i] == k) { // 拓扑序中最后一个连通分量，即无出边的分量 u = i; ++ans; } } memset(vis, 0, sizeof(vis)); check(u); // 查看是否任意节点都可达该分量 if (cnt != n) printf(\"0\\n\"); else printf(\"%d\\n\", ans); return 0;} 强连通分量（Tarjan）$O(V+E)$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081// POJ 2186：分解强连通分量，如果图中任何一个点都能到最后一个连通分量，则输出最后一个连通分量所含节点数#include &lt;bits/stdc++.h&gt;using namespace std;const int INF = 0x3f3f3f3f;const double EPS = 1e-8;//const double PI = acos(-1.0);//const int MOD = 1000000007;typedef long long LL;typedef unsigned long long uLL;const int N = 10000+10;int n, m;vector&lt;int&gt; g[N];int cnt; // dfs访问过程中的时间标记int s[N], stop; // 存放还未被决定连通分量的节点，在栈中的节点一定有路径到当前访问的节点int ord[N]; // 节点属于哪个连通分量，同时连通分量是拓扑有序的bool ins[N]; // 是否在栈中int dfn[N]; // 时间戳int low[N]; // 各个节点能到达的时间戳最早的节点int cpn;void dfs(int u) { // 本质上就是一个模板 dfs 而已 s[stop++] = u; ins[u] = true; dfn[u] = low[u] = ++cnt; for (int i = 0; i &lt; g[u].size(); ++i) { if (!dfn[g[u][i]]) { // 如果该节点没有被访问 dfs(g[u][i]); low[u] = min(low[u], low[g[u][i]]); } else if (ins[g[u][i]]) // 如果该节点在栈中 low[u] = min(low[u], dfn[g[u][i]]); } if (dfn[u] == low[u]) { // 新连通分量，u是该连通分量的“根” ++cpn; int t; // 存放栈顶元素 do { t = s[--stop]; ins[t] = false; ord[t] = cpn; } while (t != u); // 栈顶到u的顶点都属于该连通分量 }}int out[N];int main() { ios::sync_with_stdio(false); cin.tie(0); scanf(\"%d%d\", &amp;n, &amp;m); while (m--) { int a, b; scanf(\"%d%d\", &amp;a, &amp;b); g[a].push_back(b); } for (int i = 1; i &lt;= n; ++i) // Tarjan here if (!dfn[i]) dfs(i); for (int i = 1; i &lt;= n; ++i) { for (int j = 0; j &lt; g[i].size(); ++j) { if (ord[i] != ord[g[i][j]]) ++out[ord[i]]; } } int cnt = 0; for (int i = 1; i &lt;= cpn; ++i) if (!out[i]) { ++cnt; } if (cnt &gt; 1) printf(\"0\\n\"); else { int ans = 0; for (int i = 1; i &lt;= n; ++i) if (!out[ord[i]]) ++ans; printf(\"%d\\n\", ans); } return 0;} 双连通分量（Tarjan）性质：点双连通图的所有节点都在一个环上，所有节点都在一个环上的图是双连通的 $O(V+E)$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120// POJ 2942// 点双连通图就是没有任何一个单独的点可以成为割点的图#include &lt;bits/stdc++.h&gt;using namespace std;const int INF = 0x3f3f3f3f;const double EPS = 1e-8;//const double PI = acos(-1.0);//const int MOD = 1000000007;typedef long long LL;typedef unsigned long long uLL;const int N = 1000+10;int n, m;vector&lt;int&gt; g[N];bool hate[N][N];int cnt; // dfs访问过程中的时间戳int s[N], stop;bool ins[N];int dfn[N]; // 每个节点的时间戳int low[N]; // 每个节点不经过父节点能到达的最小节点的时间戳int ord[N];int cpn;int tmp[N];int color[N];bool expelled[N];inline void init() { for (int i = 1; i &lt;= n; ++i) g[i].clear(); memset(hate, 0, sizeof(hate)); cnt = stop = cpn = 0; memset(ins, 0, sizeof(ins)); memset(dfn, 0, sizeof(dfn)); memset(ord, 0, sizeof(ord)); memset(expelled, 1, sizeof(expelled));}bool bipartite(int u) { // 二分图判定 for (int i = 0; i &lt; g[u].size(); ++i) { int v = g[u][i]; if (ord[v] == cpn) { if (!color[v] &amp;&amp; !bipartite((color[v] = -color[u], v))) return false; if (color[v] &amp;&amp; color[v] == color[u]) return false; } } return true;}void dfs(int u, int fa) { // 本质上就是一个模板 dfs 而已 s[stop++] = u; ins[u] = true; // 点双连通分量所以存点 dfn[u] = low[u] = ++cnt; for (int i = 0; i &lt; g[u].size(); ++i) { int v = g[u][i]; if (!dfn[v]) { dfs(v, u); low[u] = min(low[u], low[v]); // 另：low[v] &gt; dnf[u] 就说明V-U是桥 if (low[v] &gt;= dfn[u]) { // u是该双连通分量的“根”，也是图中的一个割点 ++cpn; // 新的双连通分量 int cnt = 0; int t; // 存放栈顶元素 do { t = s[--stop]; ins[t] = false; tmp[cnt++] = t; // 该数组中的元素为同一个连通分量中的点，用于后面的二分图判断 ord[t] = cpn; } while (t != v); tmp[cnt++] = u; // u也属于该连通分量 ord[u] = cpn; // 同一节点可能属于多个点双连通分量 memset(color, 0, sizeof(color)); color[u] = 1; if (cnt &gt;= 3 &amp;&amp; !bipartite(u)) { // 不是二分图即有奇圈 for (int i = 0; i &lt; cnt; ++i) expelled[tmp[i]] = false; } } } else if (ins[v] &amp;&amp; v != fa) low[u] = min(low[u], dfn[v]); }}int solve() { int ans = 0; for (int i = 1; i &lt;= n; ++i) if (expelled[i]) ++ans; return ans;}int main() { ios::sync_with_stdio(false); cin.tie(0); while (scanf(\"%d%d\", &amp;n, &amp;m) &amp;&amp; n) { init(); for (int i = 0; i &lt; m; ++i) { int a, b; scanf(\"%d%d\", &amp;a, &amp;b); hate[a][b] = hate[b][a] = true; } for (int i = 1; i &lt;= n; ++i) { for (int j = i + 1; j &lt;= n; ++j) { if (!hate[i][j]) { g[i].push_back(j); g[j].push_back(i); } } } for (int i = 1; i &lt;= n; ++i) // Tarjan here if (!dfn[i]) dfs(i, 0); printf(\"%d\\n\", solve()); } return 0;} LCATarjan 离线算法$O((V+E)+(V+Q)\\log V)$ (Q is the number of queries) 123456789101112131415161718192021222324252627282930313233343536373839// POJ 1470// call: tarjan(root);int fa[N];bool vis[N];vector&lt;int&gt; g[N];vector&lt;int&gt; qs[N];int ans[N];int root;int find(int u) { if (fa[u] &lt; 0) return u; return fa[u] = find(fa[u]);}inline void setUnion(int a, int b) { int r1 = find(a), r2 = find(b); if (r1 == r2) return; fa[r1] = r2;}void tarjan(int u) { vis[u] = true; for (int i = 0; i &lt; qs[u].size(); ++i) { // 处理该节点对应的查询 int q = qs[u][i]; if (vis[q]) ++ans[find(q)]; // 如果对应的节点已被访问，则其所在集合的代表就是lca } for (int i = 0; i &lt; g[u].size(); ++i) { // dfs int ch = g[u][i]; tarjan(ch); setUnion(ch, u); // 处理完一个儿子后就将其与父亲合并 }}inline void init() { memset(fa, -1, sizeof(fa)); memset(vis, 0, sizeof(vis)); memset(ans, 0, sizeof(ans));} 倍增法init： $O(V\\log V)$ getLCA： $O(\\log V)$ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758// 预处理后任意两点的LCAint dep[N];vector&lt;int&gt; g[N];int ans[N];int root;int anc[20][N];int n;void dfs(int u, int fa, int w) { anc[0][u] = fa; maxe[0][u] = w; for (int k = 1; k &lt; LOGN; ++k) { if ((1&lt;&lt;k) &gt; dep[u]) break; anc[k][u] = anc[k-1][anc[k-1][u]]; maxe[k][u] = max(maxe[k-1][anc[k-1][u]], maxe[k-1][u]); } for (auto &amp;e : spt[u]) { int v = e.first; if (v == fa) continue; dep[v] = dep[u] + 1; dfs(v, u, e.second); }}void init() { // 预处理 dep[root] = 0; dfs(root, root, 0);}inline int getk(int u, int k) { // 得到节点u的第k个祖先 if (k &gt; dep[u]) return root; for (int i = 0; (1&lt;&lt;i) &lt;= k; ++i) { if ((1&lt;&lt;i) &amp; k) u = anc[i][u]; } return u;}int getLCA(int u, int v) { if (dep[u] &gt; dep[v]) swap(u, v); v = getk(v, dep[v] - dep[u]); // 先让v走到和u相同深度的节点 // if (u == v) return u; // for (int k = LOG_V; k &gt;= 0; --k) { // if (anc[k][u] != anc[k][v]) { // u = anc[k][u]; // v = anc[k][v]; // } // } // return anc[0][u]; int l = 0, r = dep[u]; while (l &lt; r) { // 二分搜索找到u、v最低的公共祖先 int mid = l + (r - l) / 2; if (getk(u, mid) == getk(v, mid)) { r = mid; } else { l = mid + 1; } } return getk(u, l);} 匹配与覆盖占坑（ Floyd判圈算法$O(n)$ 12345678910111213141516171819// 求出环中有多少个节点int n, a, b;while (cin &gt;&gt; n &amp;&amp; n) { cin &gt;&gt; a &gt;&gt; b; auto nxt = [&amp;](LL x) { return (a * x % n * x + b) % n; }; LL fast = 0, slow = 0; int cnt = 0; do { fast = nxt(nxt(fast)); slow = nxt(slow); } while (fast != slow); do { slow = nxt(slow); ++cnt; } while (slow != fast); cout &lt;&lt; n - cnt &lt;&lt; '\\n';} 欧拉通路/回路定义：图上每条边都经过且只经过一次。 存在性： 无向图：所有点连通且 每个点的度都是偶数（回路） 恰好两个点的度是奇数，其他都是偶数（通路）（奇数点即通路的起点与终点） 有向图：所有点连通且 每个点的入度都等于出度（回路） 一个点的入度比出度大 1（终点），另一个点的出度比入度大 1（起点），其他点入度等于出度（通路） 字符串算法字符串哈希算法$O(n)$ 123456789101112131415unsigned BKDRhash (char *str) { const unsigned seed = 131; // 31 131 1313 13131 131313 etc.. unsigned hash = 0; while (*str) { hash = hash * seed + (*str++); } return hash % hashSize;}unsigned DJBhash(const char str[]) { unsigned h = 5381; for (int i = 0; str[i]; ++i) { h += (h &lt;&lt; 5) + (str[i]); } return h % hashSize;} Karp-Rabinpreprocess： $O(n)$ getval： $O(1)$ 12345678910111213141516171819const int A = 911382323;const int B = 972663749;int h[N]; // h[k] contains the hash value of the prefix s[0...k]int p[N]; // p[k] == Ak mod Bvoid preprocess(const char s[]) { int len = strlen(s); h[0] = s[0]; p[0] = 1; for (int i = 1; i &lt; len; ++i) { h[i] = ((LL)h[i-1] * A + s[i]) % B; p[i] = ((LL)p[i-1] * A) % B; }}int getval(int a, int b) { // 子串[a,b]的哈希值 if (a == 0) return h[b]; int tmp = (h[b] - ((LL)h[a - 1] * p[b - a + 1]) % B) % B; return (tmp &lt; 0 ? tmp + B : tmp);} Z-algorithmZ数组的使用：把模式串 P 加在被匹配串 S 前，中间隔一个无干扰字符，如 P#S ，再对这个字符串计算 Z-array，则 Z-array 中值为 P 的长度的位置即是模式串出现的位置。 $O(n)$ 1234567891011int z[N]; // z[i]为以位置i为起点的是s的前缀的最长子串的长度void Z(const char s[]) { // compute z-array int len = strlen(s); int x = 0, y = 0; for (int i = 1; i &lt; len; ++i) { z[i] = max(0, min(z[i-x], y - i + 1)); // 若i在[x, y]之外，则z[i]为0，否则为min(z[i-x], y - i + 1) while (i + z[i] &lt; len &amp;&amp; s[z[i]] == s[i + z[i]]) { x = i; y = i + z[i]; ++z[i]; } }} KMPKMP可用来求串的最大循环节。 $O(n)$ 123456789101112131415161718192021222324252627282930template&lt;typename T&gt;vector&lt;int&gt; kmp(const T &amp;a) { // fail[i]是为a[0...i]的后缀的最长前缀 int n = a.size(); vector&lt;int&gt; fail(n); fail[0] = -1; for (int i = 1; i &lt; n; ++i) { fail[i] = fail[i - 1]; while (~fail[i] &amp;&amp; a[fail[i] + 1] != a[i]) { fail[i] = fail[fail[i]]; } if (a[fail[i] + 1] == a[i]) { ++fail[i]; } } return fail;}vector&lt;int&gt; KMP(const string &amp;s, const string &amp;p) { auto &amp;&amp;fail = kmp(p); vector&lt;int&gt; res; for (int i = 0, j = 0; i &lt; s.size(); ++i) { while (s[i] != p[j] &amp;&amp; j &gt; 0) j = fail[j - 1] + (fail[j - 1] != j - 1); if (s[i] == p[j]) { if (++j == p.size()) { res.push_back(i - p.size() + 2); j = fail[j - 1] + (fail[j - 1] != j - 1); } } } return res;} AC自动机AC自动机就是把pattern从一个字符串变成了一个trie树（即有多个pattern串，即字典）的KMP 建字典：$O(cS)$ (c is the size of the charset and S is the total length of all words in the trie) 匹配：$O(n+z)$ (n is the length of the original string and z is the total time that the patterns appear) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061// HDU 2222 2896// 失配后回溯到是字典中的某个词的前缀的后缀的位置struct ACautomaton { int trie[N][26]; int fail[N]; int cnt[N]; int tol = 0; int newnode() { for (int i = 0; i &lt; 26; ++i) trie[tol][i] = 0; fail[tol] = 0; cnt[tol] = 0; return tol++; } void init() { tol = 0; newnode(); } void add(const char s[]) { // 在字典中新加入一个词 int cur = 0; for (int i = 0; s[i]; ++i) { int c = s[i] - 'a'; if (trie[cur][c] == 0) trie[cur][c] = newnode(); cur = trie[cur][c]; } ++cnt[cur]; } void build() { // bfs queue&lt;int&gt; q; q.push(0); while (!q.empty()) { int u = q.front(); q.pop(); for (int i = 0; i &lt; 26; ++i) { int &amp;v = trie[u][i]; if (v) { if (u != 0) fail[v] = trie[fail[u]][i]; // 非根节点失配才回溯 // 如果trie[fail[u]][i]存在，即该位置就是fail节点v的失配指针 // 如果不存在，则它保存着节点fail[u]失配时的失配指针 q.push(v); } else { // 不存在 v = trie[fail[u]][i]; // 保存u的失配指针 } } } } int count(const char s[]) { // 返回字典的词在s中总共出现了多少次（有重复） int ans = 0; int u = 0; for (int i = 0; s[i]; ++i) { int c = s[i] - 'a'; u = trie[u][c]; int p = u; while (p &amp;&amp; cnt[p]) { // 后缀 ans += cnt[p]; cnt[p] = 0; p = fail[p]; } } return ans; }} ac; 后缀数组LCP：Longest Common Prefix ![suffix array](suffix array.png) 倍增法构造： $O(n\\log n)$ 计算LCP： $O(n)$ LCP定理：设$i&lt;j$，则$LCP(i,j)=\\min &lt;!–￼58–&gt;\\rfloor, \\lfloor\\frac r {n^{\\frac 2 3}}\\rfloor, t)$三元组从小到大排序，$t$表示这个询问之前经过了多少次修改。 $O(n^\\frac 5 3)$ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// BZOJ 2120void udTime(int x, int op) { int pos = ms[x].a, val = ms[x].b, pre = ms[x].p; if (op &gt; 0) { if (pos &lt;= R &amp;&amp; pos &gt;= L) { if (--cnt[a[pos]] == 0) --now; if (++cnt[val] == 1) ++now; } a[pos] = val; } else { if (pos &lt;= R &amp;&amp; pos &gt;= L) { if (--cnt[a[pos]] == 0) --now; if (++cnt[pre] == 1) ++now; } a[pos] = pre; }}void update(int x, int op) { if (x == 0) return; cnt[a[x]] += op; if (cnt[a[x]] == 0 &amp;&amp; op &lt; 0) --now; if (cnt[a[x]] == 1 &amp;&amp; op &gt; 0) ++now;}void moveto(int l, int r, int t) { while (T &lt; t) udTime(++T, 1); while (T &gt; t) udTime(T--, -1); while (L &lt; l) update(L++, -1); while (L &gt; l) update(--L, 1); while (R &lt; r) update(++R, 1); while (R &gt; r) update(R--, -1);}void solve() { S = pow(n, 2.0 / 3); sort(qs, qs + qn); now = 0; L = R = 0; T = mn; for (int i = 0; i &lt; qn; ++i) { const qry &amp;q = qs[i]; moveto(q.l, q.r, q.t); ans[q.i] = now; }} 其他枚举技巧枚举排列12345678910111213// 比一般的生成法稍快，但生成的排列不按字典序int num[N] = {1,2,3,4,5,6,7,8,9};void go(int i) { // 函数开始时会得到一个新排列 for (; i &lt; N; ++i) { for (int j = i + 1; j &lt; N; ++j) { swap(num[i], num[j]); go(i + 1); swap(num[i], num[j]); } }} 枚举子集12345678910111213141516inline void genSub(int s) { // s可为任意的集合 for (int i = s; i; i = (i - 1) &amp; s) { // i 即为一个子集 }}inline void genRsub(int n, int r) { // n 为原始集合大小，枚举大小为 r 的子集 for (int s = (1 &lt;&lt; r) - 1; s &lt; (1 &lt;&lt; n); ) { // s 即为一个子集 int x = s &amp; -s, y = s + x; int t = s &amp; ~y; s = ((t / x) &gt;&gt; 1) | y; // s = (t &gt;&gt; (__builtin_ctz(t) + 1)) | y; // optimization }} 位运算魔法123456789101112131415161718192021inline bool isPowerOf2(unsigned n) { return (n &amp; (n-1)) == 0; // n &amp; (n-1) sets the last 1 bit of n to 0}inline int getLargestPowerOf2(unsigned v) { v |= v &gt;&gt; 1; v |= v &gt;&gt; 2; v |= v &gt;&gt; 4; v |= v &gt;&gt; 8; v |= v &gt;&gt; 16; return v ^ (v&gt;&gt;1);}inline int getRoundUpPowerOf2(unsigned v) { v--; v |= v &gt;&gt; 1; v |= v &gt;&gt; 2; v |= v &gt;&gt; 4; v |= v &gt;&gt; 8; v |= v &gt;&gt; 16; v++; return v;} 并查集$O(\\log n)$ 12345678910111213141516171819// 按秩求并的并查集int find(int u) { if (fa[u] &lt; 0) // 只有一个节点时高度为-1，因为有可能节点编号从0开始 return u; return fa[u] = find(fa[u]);}inline void setUnion(int a, int b) { int r1 = find(a), r2 = find(b); if (r1 == r2) return; if (fa[r1] &lt; fa[r2]) { fa[r2] = r1; return; } if (fa[r1] == fa[r2]) { --fa[r2]; } fa[r1] = r2;} 表达式树123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// ACM-ICPC 2018 沈阳赛区网络预赛 Bstruct node { int op; int l, r;} tree[N];int cnt;int build(string &amp;s, int x, int y) { bool ok = true; for (int i = x; i &lt; y; ++i) if (!isdigit(s[i])) { ok = false; break; } if (ok) { auto &amp;u = tree[++cnt]; u.l = u.r = 0; u.op = stoi(s.substr(x, y - x)); return cnt; } int p1 = -1, p2 = -1, p3 = -1, p = 0; for (int i = x; i &lt; y; ++i) { switch (s[i]) { case '(': p++; break; case ')': p--; break; case '+': case '-': if (!p) p1 = i; break; case '*': if (!p) p2 = i; break; case 'd': if (!p &amp;&amp; p3 &lt; 0) p3 = i; break; } } if (p1 &lt; 0) p1 = p2; // 没有括号外的加减号 if (p1 &lt; 0) p1 = p3; // 也没有乘号 if (p1 &lt; 0) return build(s, x + 1, y - 1); // 也没有d，则整个表达式被括号包着 int tmp = ++cnt; auto &amp;u = tree[tmp]; u.l = build(s, x, p1); u.r = build(s, p1 + 1, y); u.op = s[p1]; return tmp;} 整体二分1234567891011121314151617181920212223242526272829303132333435363738394041// BZOJ 3110：求区间第K大，支持插入（修改），查询。// 对于每个查询，二分之前的修改（限定修改的值的范围，若不在范围内则不执行该修改）// 由于需要对每个查询进行二分，所以需要依二分结果将操作分成两类void solve(int ql, int qr, int L, int R) { if (ql &gt; qr) return; if (L == R) { for (int i = ql; i &lt;= qr; ++i) { if (qs[i].op == 2) ans[qs[i].id] = L; } return; } int t1 = 0, t2 = 0, mid = L + (R - L) / 2; for (int i = ql; i &lt;= qr; ++i) { if (qs[i].op == 1) { if (qs[i].c &lt;= mid) q1[t1++] = qs[i]; else q2[t2++] = qs[i], add(qs[i].a, qs[i].b, 1, -n, n, 1); // interval add } else { LL tmp = sum(qs[i].a, qs[i].b, 1, -n, n); // interval sum if (tmp &lt; qs[i].c) qs[i].c -= tmp, q1[t1++] = qs[i]; else q2[t2++] = qs[i]; } } // sort queries and clear tree int qmid = ql + t1; for (int i = ql; i &lt; qmid; ++i) { qs[i] = q1[i - ql]; if (qs[i].op == 1 &amp;&amp; qs[i].c &gt; mid) add(qs[i].a, qs[i].b, 1, -n, n, -1); } for (int i = qmid; i &lt;= qr; ++i) { qs[i] = q2[i - qmid]; if (qs[i].op == 1 &amp;&amp; qs[i].c &gt; mid) add(qs[i].a, qs[i].b, 1, -n, n, -1); } solve(ql, qmid - 1, L, mid); solve(qmid, qr, mid + 1, R);} 一些杂七杂八的东西 某个元素在冒泡排序中被交换的次数等于其在逆序对中出现的次数。 $\\lceil \\frac a b \\rceil = \\frac {a - 1} b + 1$ .vimrc123456789101112131415syntax onset number &quot; line numberset cursorline &quot; show line cursorset shiftwidth=4set softtabstop=4set tabstop=4set expandtab &quot; change tab to blankset autoindentset smartindentset cindentset showmatch &quot; show match bracesset matchtime=3 &quot; time for vim to wait for showmatchset rulernnoremap &lt;F4&gt; :w &lt;CR&gt; :!g++ % -o %&lt; --std=c++14 -Wall -Wshadow -g -fsanitize=address -fsanitize=undefined &amp;&amp; for i in ./in*; do echo $i; ./%&lt; &lt; $i; done &lt;CR&gt; debug template1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#ifdef LOCALtemplate &lt;typename T&gt;auto is_printable_impl(int) -&gt; decltype(cout &lt;&lt; declval&lt;T &amp;&gt;(), std::true_type{});template &lt;typename T&gt;std::false_type is_printable_impl(...);template &lt;typename T&gt;using is_printable = decltype(is_printable_impl&lt;T&gt;(0));template &lt;typename Tuple, size_t N&gt;struct TuplePrinter;struct debug { template &lt;typename T&gt; typename enable_if&lt;!is_printable&lt;T&gt;::value, debug &amp;&gt;::type operator&lt;&lt;( const T &amp;x) { int i = 0; for (auto it = begin(x); it != end(x); ++it) *this &lt;&lt; \"[\" &lt;&lt; i++ &lt;&lt; \": \" &lt;&lt; *it &lt;&lt; \"] \"; return *this; } template &lt;typename T&gt; typename enable_if&lt;is_printable&lt;T&gt;::value, debug &amp;&gt;::type operator&lt;&lt;( const T &amp;x) { cout &lt;&lt; x; return *this; } template &lt;typename T1, typename T2&gt; // pair-printer debug &amp;operator&lt;&lt;(const pair&lt;T1, T2&gt; &amp;p) { *this &lt;&lt; \"{\" &lt;&lt; p.first &lt;&lt; \", \" &lt;&lt; p.second &lt;&lt; \"}\"; return *this; } template &lt;typename... Args&gt; debug &amp;operator&lt;&lt;(const tuple&lt;Args...&gt; &amp;t) { cout &lt;&lt; \"(\"; TuplePrinter&lt;decltype(t), sizeof...(Args) - 1&gt;::print(t); cout &lt;&lt; \")\"; return *this; } ~debug() { cout &lt;&lt; endl; }#elsestruct debug { template &lt;typename T&gt; debug &amp;operator&lt;&lt;(const T &amp;foo) { return *this; }#endif};template &lt;typename Tuple, size_t N&gt;struct TuplePrinter { static void print(const Tuple &amp;t) { TuplePrinter&lt;Tuple, N - 1&gt;::print(t); debug() &lt;&lt; get&lt;N&gt;(t); }};template &lt;typename Tuple&gt;struct TuplePrinter&lt;Tuple, 0&gt; { static void print(const Tuple &amp;t) { debug() &lt;&lt; get&lt;0&gt;(t); }};#define name(x) \"[\" #x \": \" &lt;&lt; x &lt;&lt; \"] \"template &lt;typename T&gt;void print2d(const vector&lt;vector&lt;T&gt;&gt; &amp;v) {#ifdef LOCAL for (int i = 0; i &lt; v.size(); ++i) { cout &lt;&lt; i &lt;&lt; \": \"; debug() &lt;&lt; name(v[i]); }#endif} 对拍相关随机数生成12mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());int r(int s, int e) { return uniform_int_distribution&lt;int&gt;(s, e)(rng); } 脚本12345678910111213141516// 对拍@echo off:loop data &gt; input.txt main &lt; input.txt &gt; output.txt test &lt; input.txt &gt; answer.txt fc output.txt answer.txt &gt; nulif not errorlevel 1 goto loop// checker@echo off:loop data &gt; input.txt main &lt; input.txt &gt; output.txt test &lt; output.txtif not errorlevel 1 goto loop 树数据生成12345678int main() { int n = r(2, 20); printf(\"%d\\n\", n); for(int i = 2; i &lt;= n; ++i) { printf(\"%d %d\\n\", r(1, i - 1), i); // 前者是后者的父节点 } return 0;}","link":"/2019/10/06/汕大acm模板/"}],"tags":[{"name":"ACMer","slug":"ACMer","link":"/tags/ACMer/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"MySQL","slug":"MySQL","link":"/tags/MySQL/"},{"name":"搭建网站","slug":"搭建网站","link":"/tags/搭建网站/"},{"name":"STL","slug":"STL","link":"/tags/STL/"},{"name":"数据库","slug":"数据库","link":"/tags/数据库/"},{"name":"UDP","slug":"UDP","link":"/tags/UDP/"},{"name":"编程环境","slug":"编程环境","link":"/tags/编程环境/"},{"name":"TCP","slug":"TCP","link":"/tags/TCP/"},{"name":"数据结构","slug":"数据结构","link":"/tags/数据结构/"},{"name":"多任务","slug":"多任务","link":"/tags/多任务/"},{"name":"时间表","slug":"时间表","link":"/tags/时间表/"},{"name":"ACM learning process","slug":"ACM-learning-process","link":"/tags/ACM-learning-process/"},{"name":"ACM","slug":"ACM","link":"/tags/ACM/"}],"categories":[{"name":"数论","slug":"数论","link":"/categories/数论/"},{"name":"搜索","slug":"搜索","link":"/categories/搜索/"},{"name":"操作系统","slug":"操作系统","link":"/categories/操作系统/"},{"name":"String","slug":"String","link":"/categories/String/"},{"name":"ACMer","slug":"ACMer","link":"/categories/ACMer/"},{"name":"大二上","slug":"大二上","link":"/categories/大二上/"},{"name":"网络通信概述","slug":"网络通信概述","link":"/categories/网络通信概述/"},{"name":"电脑配置","slug":"电脑配置","link":"/categories/电脑配置/"},{"name":"搜索二分","slug":"搜索二分","link":"/categories/搜索二分/"},{"name":"动态规划","slug":"动态规划","link":"/categories/动态规划/"},{"name":"多任务编程","slug":"多任务编程","link":"/categories/多任务编程/"},{"name":"图论","slug":"图论","link":"/categories/图论/"},{"name":"高级数据结构","slug":"高级数据结构","link":"/categories/高级数据结构/"},{"name":"ACM入门","slug":"ACM入门","link":"/categories/ACM入门/"},{"name":"递推与DP","slug":"递推与DP","link":"/categories/递推与DP/"}]}